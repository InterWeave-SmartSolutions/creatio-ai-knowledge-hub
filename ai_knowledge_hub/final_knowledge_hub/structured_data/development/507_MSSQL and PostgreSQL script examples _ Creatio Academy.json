{
  "id": 507,
  "url": "https://academy.creatio.com/docs/8.x/dev/development-on-creatio-platform/8.1/development-tools/database-tools/postgresql-features/examples/mssql-and-postgresql-script-examples",
  "title": "MSSQL and PostgreSQL script examples | Creatio Academy",
  "category": "development",
  "description": "Example 1 (views)",
  "content": "This is documentation for Creatio 8.1 . For up-to-date documentation, see the latest version ( 8.3 ). Version: 8.1 On this page Level: intermediate Example 1 (views) ​ Example Example of an SQL script that creates a view and triggers to add, modify, and delete records from the target table. MSSQL PostgreSQL -- View and triggers that let you modify the target table -- MSSQL IF EXISTS ( SELECT * FROM sys . views WHERE object_id = OBJECT_ID ( N '[dbo].[VwSysAdminUnit]' ) ) DROP VIEW [ dbo ] . [ VwSysAdminUnit ] GO CREATE VIEW [ dbo ] . [ VwSysAdminUnit ] AS SELECT [ SysAdminUnit ] . [ Id ] , [ SysAdminUnit ] . [ CreatedOn ] , [ SysAdminUnit ] . [ CreatedById ] , [ SysAdminUnit ] . [ ModifiedOn ] , [ SysAdminUnit ] . [ ModifiedById ] , [ SysAdminUnit ] . [ Name ] , [ SysAdminUnit ] . [ Description ] , [ SysAdminUnit ] . [ ParentRoleId ] , [ SysAdminUnit ] . [ ContactId ] , [ SysAdminUnit ] . [ IsDirectoryEntry ] , [ TimeZone ] . [ Id ] AS [ TimeZoneId ] , [ SysAdminUnit ] . [ UserPassword ] , [ SysAdminUnitType ] . [ Id ] AS [ SysAdminUnitTypeId ] , [ SysAdminUnit ] . [ AccountId ] , [ SysAdminUnit ] . [ Active ] , [ SysAdminUnit ] . [ LoggedIn ] , [ SysAdminUnit ] . [ SynchronizeWithLDAP ] , [ SysAdminUnit ] . [ LDAPEntry ] , [ SysAdminUnit ] . [ LDAPEntryId ] , [ SysAdminUnit ] . [ LDAPEntryDN ] , [ SysAdminUnit ] . [ SysCultureId ] , [ SysAdminUnit ] . [ ProcessListeners ] , [ SysAdminUnit ] . [ PasswordExpireDate ] , [ SysAdminUnit ] . [ HomePageId ] , [ SysAdminUnit ] . [ ConnectionType ] , [ ConnectionType ] . [ Id ] AS [ UserConnectionTypeId ] , [ SysAdminUnit ] . [ ForceChangePassword ] , [ SysAdminUnit ] . [ DateTimeFormatId ] , [ SysAdminUnit ] . [ Id ] as [ SysAdminUnitId ] , [ SysAdminUnit ] . [ SessionTimeout ] as [ SessionTimeout ] FROM [ SysAdminUnit ] INNER JOIN [ SysAdminUnitType ] ON [ SysAdminUnitType ] . [ Value ] = [ SysAdminUnit ] . [ SysAdminUnitTypeValue ] LEFT JOIN [ ConnectionType ] AS [ ConnectionType ] ON [ ConnectionType ] . [ Value ] = [ SysAdminUnit ] . [ ConnectionType ] LEFT JOIN [ TimeZone ] AS [ TimeZone ] ON [ TimeZone ] . [ Code ] = [ SysAdminUnit ] . [ TimeZoneId ] GO CREATE TRIGGER [ dbo ] . [ ITR_VwSysAdminUnit_I ] ON [ dbo ] . [ VwSysAdminUnit ] INSTEAD OF INSERT AS BEGIN SET NOCOUNT ON ; INSERT INTO [ SysAdminUnit ] ( [ Id ] , [ CreatedOn ] , [ CreatedById ] , [ ModifiedOn ] , [ ModifiedById ] , [ Name ] , [ Description ] , [ ParentRoleId ] , [ ContactId ] , [ IsDirectoryEntry ] , [ TimeZoneId ] , [ UserPassword ] , [ SysAdminUnitTypeValue ] , [ AccountId ] , [ Active ] , [ LoggedIn ] , [ SynchronizeWithLDAP ] , [ LDAPEntry ] , [ LDAPEntryId ] , [ LDAPEntryDN ] , [ SysCultureId ] , [ ProcessListeners ] , [ PasswordExpireDate ] , [ HomePageId ] , [ ConnectionType ] , [ ForceChangePassword ] , [ DateTimeFormatId ] , [ SessionTimeout ] ) SELECT [ Id ] , [ CreatedOn ] , [ CreatedById ] , [ ModifiedOn ] , [ ModifiedById ] , [ Name ] , [ Description ] , [ ParentRoleId ] , [ ContactId ] , [ IsDirectoryEntry ] , ( SELECT COALESCE ( ( SELECT [ TimeZone ] . [ Code ] FROM [ TimeZone ] WHERE [ TimeZone ] . [ Id ] = [ INSERTED ] . [ TimeZoneId ] ) , '' ) ) , [ UserPassword ] , ISNULL ( ( SELECT [ SysAdminUnitType ] . [ Value ] FROM [ SysAdminUnitType ] WHERE [ SysAdminUnitType ] . [ Id ] = [ INSERTED ] . [ SysAdminUnitTypeId ] ) , 4 ) , [ AccountId ] , [ Active ] , ISNULL ( [ LoggedIn ] , 0 ) , [ SynchronizeWithLDAP ] , [ LDAPEntry ] , [ LDAPEntryId ] , [ LDAPEntryDN ] , [ SysCultureId ] , [ ProcessListeners ] , [ PasswordExpireDate ] , [ HomePageId ] , COALESCE ( [ INSERTED ] . [ ConnectionType ] , ( SELECT [ ConnectionType ] . [ Value ] FROM [ ConnectionType ] WHERE [ ConnectionType ] . [ Id ] = [ INSERTED ] . [ UserConnectionTypeId ] ) , 0 ) , ISNULL ( [ ForceChangePassword ] , 0 ) , [ DateTimeFormatId ] , [ SessionTimeout ] FROM [ INSERTED ] END GO CREATE TRIGGER [ dbo ] . [ ITR_VwSysAdminUnit_U ] ON [ dbo ] . [ VwSysAdminUnit ] INSTEAD OF UPDATE AS BEGIN SET NOCOUNT ON ; UPDATE [ SysAdminUnit ] SET [ SysAdminUnit ] . [ CreatedOn ] = [ INSERTED ] . [ CreatedOn ] , [ SysAdminUnit ] . [ CreatedById ] = [ INSERTED ] . [ CreatedById ] , [ SysAdminUnit ] . [ ModifiedOn ] = [ INSERTED ] . [ ModifiedOn ] , [ SysAdminUnit ] . [ ModifiedById ] = [ INSERTED ] . [ ModifiedById ] , [ SysAdminUnit ] . [ Name ] = [ INSERTED ] . [ Name ] , [ SysAdminUnit ] . [ Description ] = [ INSERTED ] . [ Description ] , [ SysAdminUnit ] . [ ParentRoleId ] = [ INSERTED ] . [ ParentRoleId ] , [ SysAdminUnit ] . [ ContactId ] = [ INSERTED ] . [ ContactId ] , [ SysAdminUnit ] . [ IsDirectoryEntry ] = [ INSERTED ] . [ IsDirectoryEntry ] , [ SysAdminUnit ] . [ TimeZoneId ] = ( SELECT COALESCE ( ( SELECT [ TimeZone ] . [ Code ] FROM [ TimeZone ] WHERE [ TimeZone ] . [ Id ] = [ INSERTED ] . [ TimeZoneId ] ) , '' ) ) , [ SysAdminUnit ] . [ UserPassword ] = [ INSERTED ] . [ UserPassword ] , [ SysAdminUnit ] . [ SysAdminUnitTypeValue ] = ( SELECT [ SysAdminUnitType ] . [ Value ] FROM [ SysAdminUnitType ] WHERE [ SysAdminUnitType ] . [ Id ] = [ INSERTED ] . [ SysAdminUnitTypeId ] ) , [ SysAdminUnit ] . [ AccountId ] = [ INSERTED ] . [ AccountId ] , [ SysAdminUnit ] . [ Active ] = [ INSERTED ] . [ Active ] , [ SysAdminUnit ] . [ LoggedIn ] = [ INSERTED ] . [ LoggedIn ] , [ SysAdminUnit ] . [ SynchronizeWithLDAP ] = [ INSERTED ] . [ SynchronizeWithLDAP ] , [ SysAdminUnit ] . [ LDAPEntry ] = [ INSERTED ] . [ LDAPEntry ] , [ SysAdminUnit ] . [ LDAPEntryId ] = [ INSERTED ] . [ LDAPEntryId ] , [ SysAdminUnit ] . [ LDAPEntryDN ] = [ INSERTED ] . [ LDAPEntryDN ] , [ SysAdminUnit ] . [ SysCultureId ] = [ INSERTED ] . [ SysCultureId ] , [ SysAdminUnit ] . [ ProcessListeners ] = [ INSERTED ] . [ ProcessListeners ] , [ SysAdminUnit ] . [ PasswordExpireDate ] = [ INSERTED ] . [ PasswordExpireDate ] , [ SysAdminUnit ] . [ HomePageId ] = [ INSERTED ] . [ HomePageId ] , [ SysAdminUnit ] . [ ConnectionType ] = COALESCE ( [ INSERTED ] . [ ConnectionType ] , ( SELECT [ ConnectionType ] . [ Value ] FROM [ ConnectionType ] WHERE [ ConnectionType ] . [ Id ] = [ INSERTED ] . [ UserConnectionTypeId ] ) , 0 ) , [ SysAdminUnit ] . [ ForceChangePassword ] = [ INSERTED ] . [ ForceChangePassword ] , [ SysAdminUnit ] . [ DateTimeFormatId ] = [ INSERTED ] . [ DateTimeFormatId ] , [ SysAdminUnit ] . [ SessionTimeout ] = [ INSERTED ] . [ SessionTimeout ] FROM [ SysAdminUnit ] INNER JOIN [ INSERTED ] ON [ SysAdminUnit ] . [ Id ] = [ INSERTED ] . [ Id ] END GO CREATE TRIGGER [ dbo ] . [ ITR_VwSysAdminUnit_D ] ON [ dbo ] . [ VwSysAdminUnit ] INSTEAD OF DELETE AS BEGIN SET NOCOUNT ON ; DELETE FROM [ SysAdminUnit ] WHERE EXISTS ( SELECT * FROM [ DELETED ] WHERE [ SysAdminUnit ] . [ Id ] = [ DELETED ] . [ Id ] ) END GO -- View and triggers that let you modify the target table -- PostgreSQL DROP FUNCTION IF EXISTS \"public\" . \"ITR_VwSysLookup_IUD_Func\" CASCADE ; DROP VIEW IF EXISTS \"public\" . \"VwSysLookup\" ; CREATE VIEW \"public\" . \"VwSysLookup\" AS SELECT \"SysLookup\" . \"Id\" , \"SysLookup\" . \"CreatedOn\" , \"SysLookup\" . \"CreatedById\" , \"SysLookup\" . \"ModifiedOn\" , \"SysLookup\" . \"ModifiedById\" , \"SysLookup\" . \"Name\" , \"SysLookup\" . \"Description\" , \"SysLookup\" . \"SysFolderId\" , \"SysLookup\" . \"SysEntitySchemaUId\" , \"SysLookup\" . \"SysGridPageSchemaUId\" , \"SysLookup\" . \"SysEditPageSchemaUId\" , \"VwSysSchemaInfo\" . \"SysWorkspaceId\" , \"SysLookup\" . \"ProcessListeners\" , \"SysLookup\" . \"IsSystem\" , \"SysLookup\" . \"IsSimple\" FROM \"public\" . \"SysLookup\" INNER JOIN \"public\" . \"VwSysSchemaInfo\" ON \"SysLookup\" . \"SysEntitySchemaUId\" = \"VwSysSchemaInfo\" . \"UId\" ; CREATE FUNCTION \"public\" . \"ITR_VwSysLookup_IUD_Func\" ( ) RETURNS TRIGGER AS $$ BEGIN IF TG_OP = 'INSERT' THEN INSERT INTO \"public\" . \"SysLookup\" ( \"Id\" , \"CreatedOn\" , \"CreatedById\" , \"ModifiedOn\" , \"ModifiedById\" , \"Name\" , \"Description\" , \"SysFolderId\" , \"SysEntitySchemaUId\" , \"SysGridPageSchemaUId\" , \"SysEditPageSchemaUId\" , \"ProcessListeners\" , \"IsSystem\" , \"IsSimple\" ) SELECT NEW . \"Id\" , NEW . \"CreatedOn\" , NEW . \"CreatedById\" , NEW . \"ModifiedOn\" , NEW . \"ModifiedById\" , NEW . \"Name\" , NEW . \"Description\" , NEW . \"SysFolderId\" , NEW . \"SysEntitySchemaUId\" , NEW . \"SysGridPageSchemaUId\" , NEW . \"SysEditPageSchemaUId\" , NEW . \"ProcessListeners\" , NEW . \"IsSystem\" , NEW . \"IsSimple\" ; RETURN NEW ; ELSIF TG_OP = 'UPDATE' THEN UPDATE \"public\" . \"SysLookup\" SET \"CreatedOn\" = NEW . \"CreatedOn\" , \"CreatedById\" = NEW . \"CreatedById\" , \"ModifiedOn\" = NEW . \"ModifiedOn\" , \"ModifiedById\" = NEW . \"ModifiedById\" , \"Name\" = NEW . \"Name\" , \"Description\" = NEW . \"Description\" , \"SysFolderId\" = NEW . \"SysFolderId\" , \"SysEntitySchemaUId\" = NEW . \"SysEntitySchemaUId\" , \"SysGridPageSchemaUId\" = NEW . \"SysGridPageSchemaUId\" , \"SysEditPageSchemaUId\" = NEW . \"SysEditPageSchemaUId\" , \"ProcessListeners\" = NEW . \"ProcessListeners\" , \"IsSystem\" = NEW . \"IsSystem\" , \"IsSimple\" = NEW . \"IsSimple\" WHERE \"SysLookup\" . \"Id\" = NEW . \"Id\" ; RETURN NEW ; ELSIF TG_OP = 'DELETE' THEN DELETE FROM \"public\" . \"SysLookup\" WHERE OLD . \"Id\" = \"SysLookup\" . \"Id\" ; RETURN OLD ; END IF ; RETURN NEW ; END ; $$ LANGUAGE plpgsql ; CREATE TRIGGER \"ITR_VwSysLookup_IUD\" INSTEAD OF INSERT OR UPDATE OR DELETE ON \"public\" . \"VwSysLookup\" FOR EACH ROW EXECUTE PROCEDURE \"public\" . \"ITR_VwSysLookup_IUD_Func\" ( ) ; Example 2 (views) ​ Example Example of an SQL script that demonstrates how to use a RULE instead of the INSTEAD OF trigger in PostgreSQL. MSSQL PostgreSQL -- Use the RULE instead of the INSTEAD OF trigger -- MSSQL IF EXISTS ( SELECT * FROM sys . views WHERE object_id = OBJECT_ID ( N '[dbo].[VwAdministrativeObjects]' ) ) DROP VIEW [ dbo ] . [ VwAdministrativeObjects ] GO CREATE VIEW [ dbo ] . [ VwAdministrativeObjects ] AS WITH [ SysSchemaAdministrationProperties ] AS ( SELECT [ AdministrationPropertiesAll ] . [ Id ] AS [ SysSchemaId ] , max ( [ AdministrationPropertiesAll ] . [ AdministratedByOperations ] ) AS [ AdministratedByOperations ] , max ( [ AdministrationPropertiesAll ] . [ AdministratedByColumns ] ) AS [ AdministratedByColumns ] , max ( [ AdministrationPropertiesAll ] . [ AdministratedByRecords ] ) AS [ AdministratedByRecords ] , max ( [ AdministrationPropertiesAll ] . [ IsTrackChangesInDB ] ) AS [ IsTrackChangesInDB ] FROM ( SELECT [ SysSchema ] . [ Id ] , ( CASE WHEN EXISTS ( SELECT 1 FROM [ SysSchemaProperty ] WHERE ( ( [ SysSchemaProperty ] . [ SysSchemaId ] = [ SysSchema ] . [ Id ] AND [ SysSchema ] . [ ExtendParent ] = 0 ) OR [ SysSchemaProperty ] . [ SysSchemaId ] = [ DerivedSysSchema ] . [ Id ] ) AND [ SysSchemaProperty ] . [ Name ] = 'AdministratedByOperations' AND [ SysSchemaProperty ] . [ Value ] = 'True' AND [ SysSchemaProperty ] . [ SysSchemaId ] IS NOT NULL ) THEN 1 ELSE 0 END ) AS [ AdministratedByOperations ] , ( CASE WHEN EXISTS ( SELECT 1 FROM [ SysSchemaProperty ] WHERE ( ( [ SysSchemaProperty ] . [ SysSchemaId ] = [ SysSchema ] . [ Id ] AND [ SysSchema ] . [ ExtendParent ] = 0 ) OR [ SysSchemaProperty ] . [ SysSchemaId ] = [ DerivedSysSchema ] . [ Id ] ) AND [ SysSchemaProperty ] . [ Name ] = 'AdministratedByColumns' AND [ SysSchemaProperty ] . [ Value ] = 'True' AND [ SysSchemaProperty ] . [ SysSchemaId ] IS NOT NULL ) THEN 1 ELSE 0 END ) AS [ AdministratedByColumns ] , ( CASE WHEN EXISTS ( SELECT 1 FROM [ SysSchemaProperty ] WHERE ( ( [ SysSchemaProperty ] . [ SysSchemaId ] = [ SysSchema ] . [ Id ] AND [ SysSchema ] . [ ExtendParent ] = 0 ) OR [ SysSchemaProperty ] . [ SysSchemaId ] = [ DerivedSysSchema ] . [ Id ] ) AND [ SysSchemaProperty ] . [ Name ] = 'AdministratedByRecords' AND [ SysSchemaProperty ] . [ Value ] = 'True' AND [ SysSchemaProperty ] . [ SysSchemaId ] IS NOT NULL ) THEN 1 ELSE 0 END ) AS [ AdministratedByRecords ] , ( CASE WHEN EXISTS ( SELECT 1 FROM [ SysSchemaProperty ] WHERE ( ( [ SysSchemaProperty ] . [ SysSchemaId ] = [ SysSchema ] . [ Id ] AND [ SysSchema ] . [ ExtendParent ] = 0 ) OR [ SysSchemaProperty ] . [ SysSchemaId ] = [ DerivedSysSchema ] . [ Id ] ) AND [ SysSchemaProperty ] . [ Name ] = 'IsTrackChangesInDB' AND [ SysSchemaProperty ] . [ Value ] = 'True' AND [ SysSchemaProperty ] . [ SysSchemaId ] IS NOT NULL ) THEN 1 ELSE 0 END ) AS [ IsTrackChangesInDB ] FROM [ SysSchema ] LEFT OUTER JOIN [ SysSchema ] AS [ DerivedSysSchema ] ON ( [ SysSchema ] . [ Id ] = [ DerivedSysSchema ] . [ ParentId ] AND [ DerivedSysSchema ] . [ ExtendParent ] = 1 ) WHERE [ SysSchema ] . [ ManagerName ] = 'EntitySchemaManager' AND [ SysSchema ] . [ ExtendParent ] = 0 ) AS [ AdministrationPropertiesAll ] GROUP BY [ AdministrationPropertiesAll ] . [ Id ] ) SELECT [ BaseSchemas ] . [ UId ] AS [ Id ] , [ BaseSchemas ] . [ UId ] , [ BaseSchemas ] . [ CreatedOn ] , [ BaseSchemas ] . [ CreatedById ] , [ BaseSchemas ] . [ ModifiedOn ] , [ BaseSchemas ] . [ ModifiedById ] , [ BaseSchemas ] . [ Name ] , [ VwSysSchemaExtending ] . [ TopExtendingCaption ] as Caption , [ BaseSchemas ] . [ Description ] , ( CASE WHEN EXISTS ( SELECT 1 FROM [ SysLookup ] WHERE [ SysLookup ] . [ SysEntitySchemaUId ] = [ BaseSchemas ] . [ UId ] ) THEN 1 ELSE 0 END ) AS [ IsLookup ] , ( CASE WHEN EXISTS ( SELECT 1 FROM [ SysModule ] INNER JOIN [ SysModuleEntity ] ON [ SysModuleEntity ] . [ Id ] = [ SysModule ] . [ SysModuleEntityId ] WHERE [ BaseSchemas ] . [ UId ] = [ SysModuleEntity ] . [ SysEntitySchemaUId ] ) THEN 1 ELSE 0 END ) AS [ IsModule ] , [ SysSchemaAdministrationProperties ] . [ AdministratedByOperations ] , [ SysSchemaAdministrationProperties ] . [ AdministratedByColumns ] , [ SysSchemaAdministrationProperties ] . [ AdministratedByRecords ] , [ SysSchemaAdministrationProperties ] . [ IsTrackChangesInDB ] , [ SysWorkspaceId ] , [ BaseSchemas ] . [ ProcessListeners ] , ( CASE WHEN EXISTS ( SELECT 1 FROM [ SysSSPEntitySchemaAccessList ] WHERE [ SysSSPEntitySchemaAccessList ] . [ EntitySchemaUId ] = [ BaseSchemas ] . [ UId ] ) THEN 1 ELSE 0 END ) AS [ IsInSSPEntitySchemaAccessList ] FROM [ SysSchema ] as [ BaseSchemas ] INNER JOIN [ VwSysSchemaExtending ] ON BaseSchemas . [ Id ] = [ VwSysSchemaExtending ] . [ BaseSchemaId ] INNER JOIN [ SysPackage ] on [ BaseSchemas ] . [ SysPackageId ] = [ SysPackage ] . [ Id ] INNER JOIN [ SysSchemaAdministrationProperties ] ON [ BaseSchemas ] . [ Id ] = [ SysSchemaAdministrationProperties ] . [ SysSchemaId ] GO CREATE TRIGGER [ dbo ] . [ TRVwAdministrativeObjects_IU ] ON [ dbo ] . [ VwAdministrativeObjects ] INSTEAD OF UPDATE AS BEGIN SET NOCOUNT ON ; RETURN END GO -- Use the RULE instead of the INSTEAD OF trigger -- PostgreSQL DROP VIEW IF EXISTS public . \"VwAdministrativeObjects\" ; DROP RULE IF EXISTS RU_VwAdministrativeObjects ON \"VwAdministrativeObjects\" ; CREATE VIEW public . \"VwAdministrativeObjects\" AS WITH SysSchemaAdministrationProperties AS ( SELECT AdministrationPropertiesAll . Id \"SysSchemaId\" , MAX ( AdministrationPropertiesAll . AdministratedByOperations ) \"AdministratedByOperations\" , MAX ( AdministrationPropertiesAll . AdministratedByColumns ) \"AdministratedByColumns\" , MAX ( AdministrationPropertiesAll . AdministratedByRecords ) \"AdministratedByRecords\" , MAX ( AdministrationPropertiesAll . IsTrackChangesInDB ) \"IsTrackChangesInDB\" FROM ( SELECT ss . \"Id\" Id , ( CASE WHEN EXISTS ( SELECT 1 FROM \"SysSchemaProperty\" ssp WHERE ( ( ssp . \"SysSchemaId\" = ss . \"Id\" AND NOT ss . \"ExtendParent\" ) OR ssp . \"SysSchemaId\" = DerivedSysSchema . \"Id\" ) AND ssp . \"Name\" = 'AdministratedByOperations' AND ssp . \"Value\" = 'True' AND ssp . \"SysSchemaId\" IS NOT NULL ) THEN 1 ELSE 0 END ) AdministratedByOperations , ( CASE WHEN EXISTS ( SELECT 1 FROM \"SysSchemaProperty\" ssp WHERE ( ( ssp . \"SysSchemaId\" = ss . \"Id\" AND NOT ss . \"ExtendParent\" ) OR ssp . \"SysSchemaId\" = DerivedSysSchema . \"Id\" ) AND ssp . \"Name\" = 'AdministratedByColumns' AND ssp . \"Value\" = 'True' AND ssp . \"SysSchemaId\" IS NOT NULL ) THEN 1 ELSE 0 END ) AdministratedByColumns , ( CASE WHEN EXISTS ( SELECT 1 FROM \"SysSchemaProperty\" ssp WHERE ( ( ssp . \"SysSchemaId\" = ss . \"Id\" AND NOT ss . \"ExtendParent\" ) OR ssp . \"SysSchemaId\" = DerivedSysSchema . \"Id\" ) AND ssp . \"Name\" = 'AdministratedByRecords' AND ssp . \"Value\" = 'True' AND ssp . \"SysSchemaId\" IS NOT NULL ) THEN 1 ELSE 0 END ) AdministratedByRecords , ( CASE WHEN EXISTS ( SELECT 1 FROM \"SysSchemaProperty\" ssp WHERE ( ( ssp . \"SysSchemaId\" = ss . \"Id\" AND NOT ss . \"ExtendParent\" ) OR ssp . \"SysSchemaId\" = DerivedSysSchema . \"Id\" ) AND ssp . \"Name\" = 'IsTrackChangesInDB' AND ssp . \"Value\" = 'True' AND ssp . \"SysSchemaId\" IS NOT NULL ) THEN 1 ELSE 0 END ) IsTrackChangesInDB FROM \"SysSchema\" ss LEFT OUTER JOIN \"SysSchema\" DerivedSysSchema ON ( ss . \"Id\" = DerivedSysSchema . \"ParentId\" AND DerivedSysSchema . \"ExtendParent\" ) WHERE ss . \"ManagerName\" = 'EntitySchemaManager' AND NOT ss . \"ExtendParent\" ) AdministrationPropertiesAll GROUP BY AdministrationPropertiesAll . Id ) SELECT BaseSchema . \"UId\" \"Id\" , BaseSchema . \"UId\" , BaseSchema . \"CreatedOn\" , BaseSchema . \"CreatedById\" , BaseSchema . \"ModifiedOn\" , BaseSchema . \"ModifiedById\" , BaseSchema . \"Name\" , public . \"VwSysSchemaExtending\" . \"TopExtendingCaption\" \"Caption\" , BaseSchema . \"Description\" , EXISTS ( SELECT 1 FROM \"SysLookup\" WHERE \"SysEntitySchemaUId\" = BaseSchema . \"UId\" ) \"IsLookup\" , EXISTS ( SELECT 1 FROM \"SysModule\" sm INNER JOIN \"SysModuleEntity\" sme ON sme . \"Id\" = sm . \"SysModuleEntityId\" WHERE BaseSchema . \"UId\" = sme . \"SysEntitySchemaUId\" ) \"IsModule\" , SysSchemaAdministrationProperties . \"AdministratedByOperations\" :: BOOLEAN , SysSchemaAdministrationProperties . \"AdministratedByColumns\" :: BOOLEAN , SysSchemaAdministrationProperties . \"AdministratedByRecords\" :: BOOLEAN , SysSchemaAdministrationProperties . \"IsTrackChangesInDB\" :: BOOLEAN , \"SysWorkspaceId\" , BaseSchema . \"ProcessListeners\" , EXISTS ( SELECT 1 FROM \"SysSSPEntitySchemaAccessList\" WHERE \"EntitySchemaUId\" = BaseSchema . \"UId\" ) \"IsInSSPEntitySchemaAccessList\" FROM \"SysSchema\" BaseSchema INNER JOIN \"VwSysSchemaExtending\" ON BaseSchema . \"Id\" = \"VwSysSchemaExtending\" . \"BaseSchemaId\" INNER JOIN \"SysPackage\" on BaseSchema . \"SysPackageId\" = \"SysPackage\" . \"Id\" INNER JOIN SysSchemaAdministrationProperties ON BaseSchema . \"Id\" = SysSchemaAdministrationProperties . \"SysSchemaId\" ; CREATE RULE RU_VwAdministrativeObjects AS ON UPDATE TO \"VwAdministrativeObjects\" DO INSTEAD NOTHING ; Example 3 (stored procedures) ​ Example Example of an SQL script that creates a stored procedure. The stored procedure uses loops, cursors, and temporary tables. MSSQL PostgreSQL -- Stored procedure that uses loops, cursors, and temporary tables -- MSSQL IF NOT OBJECT_ID ( '[dbo].[tsp_ActualizeUserRoles]' ) IS NULL BEGIN DROP PROCEDURE [ dbo ] . [ tsp_ActualizeUserRoles ] END GO CREATE PROCEDURE dbo . tsp_ActualizeUserRoles ( @UserId uniqueidentifier ) AS BEGIN SET NOCOUNT ON IF OBJECT_ID ( 'tempdb..#AdminUnitListTemp' ) IS NOT NULL BEGIN DROP TABLE [ #AdminUnitListTemp]; END ; CREATE TABLE [ #AdminUnitListTemp] ( [ UserId ] uniqueidentifier NOT NULL , [ Id ] uniqueidentifier NOT NULL , [ Name ] NVARCHAR ( 250 ) NOT NULL , [ ParentRoleId ] uniqueidentifier NULL , [ Granted ] BIT NULL ) ; DECLARE @GetAdminUnitList TABLE ( [ Id ] uniqueidentifier NOT NULL , [ Name ] nvarchar ( 260 ) NOT NULL , [ ParentRoleId ] uniqueidentifier NULL ) ; DECLARE @NewRoles TABLE ( [ Id ] uniqueidentifier NOT NULL ) ; DECLARE @OldUserRoles TABLE ( [ Id ] uniqueidentifier NOT NULL ) ; DECLARE @getUserAdminUnits CURSOR ; DECLARE @SysAdminUnitRoles TABLE ( [ Id ] uniqueidentifier , [ Name ] nvarchar ( 260 ) , [ ParentRoleId ] uniqueidentifier ) ; DECLARE @ManagersBeforeActualization TABLE ( [ Id ] uniqueidentifier NOT NULL ) ; DECLARE @ManagersAfterActualization TABLE ( [ Id ] uniqueidentifier NOT NULL ) ; DECLARE @StillManagers TABLE ( [ Id ] uniqueidentifier NOT NULL ) ; DECLARE @NoLongerManagers TABLE ( [ Id ] uniqueidentifier NOT NULL ) ; DECLARE @NewManagers TABLE ( [ Id ] uniqueidentifier NOT NULL ) ; DECLARE @SysAdminUnitId uniqueidentifier ; -- Old user roles INSERT INTO @OldUserRoles SELECT DISTINCT [ SysAdminUnitInRole ] . [ SysAdminUnitRoleId ] [ Id ] FROM [ SysAdminUnitInRole ] WHERE [ SysAdminUnitInRole ] . [ SysAdminUnitId ] = @UserId -- Old user managers INSERT INTO @ManagersBeforeActualization SELECT DISTINCT [ SysUserInRole ] . [ SysUserId ] [ Id ] FROM [ SysAdminUnitInRole ] INNER JOIN [ SysAdminUnit ] [ Roles ] ON [ SysAdminUnitInRole ] . [ SysAdminUnitRoleId ] = [ Roles ] . [ Id ] INNER JOIN @OldUserRoles ON [ Roles ] . [ ParentRoleId ] = [ @OldUserRoles ] . [ Id ] INNER JOIN [ SysUserInRole ] ON [ SysUserInRole ] . [ SysRoleId ] = [ Roles ] . [ Id ] WHERE [ Roles ] . [ SysAdminUnitTypeValue ] = 2 -- Get and insert new user roles INSERT INTO @GetAdminUnitList EXEC [ tsp_GetAdminUnitList ] @UserId = @UserId ; INSERT INTO @NewRoles SELECT [ Id ] FROM @GetAdminUnitList ; DELETE FROM [ SysAdminUnitInRole ] WHERE [ SysAdminUnitId ] = @UserId ; INSERT INTO [ SysAdminUnitInRole ] ( [ SysAdminUnitId ] , [ SysAdminUnitRoleId ] ) SELECT DISTINCT @UserId , [ Id ] FROM @NewRoles ; -- User managers after actualization INSERT INTO @ManagersAfterActualization SELECT DISTINCT [ SysUserInRole ] . [ SysUserId ] [ Id ] FROM [ SysAdminUnitInRole ] INNER JOIN [ SysAdminUnit ] [ Roles ] ON [ SysAdminUnitInRole ] . [ SysAdminUnitRoleId ] = [ Roles ] . [ Id ] INNER JOIN @NewRoles NewRoles ON [ Roles ] . [ ParentRoleId ] = NewRoles . [ Id ] INNER JOIN [ SysUserInRole ] ON [ SysUserInRole ] . [ SysRoleId ] = [ Roles ] . [ Id ] WHERE [ Roles ] . [ SysAdminUnitTypeValue ] = 2 ; -- New (who were not but become) user managers INSERT INTO @NewManagers SELECT [ Id ] FROM @ManagersAfterActualization AS managersAfterActualization WHERE NOT EXISTS ( SELECT NULL FROM @ManagersBeforeActualization AS managersBeforeActualization WHERE managersBeforeActualization . [ Id ] = managersAfterActualization . [ Id ] ) ; -- Add all user roles to new managers and their grantee-users, if they arent already have SET @getUserAdminUnits = CURSOR FOR SELECT DISTINCT [ Id ] FROM ( SELECT [ Id ] FROM @NewManagers UNION SELECT [ GranteeSysAdminUnitId ] FROM [ SysAdminUnitGrantedRight ] WHERE EXISTS ( SELECT NULL FROM @NewManagers as newManagers WHERE [ SysAdminUnitGrantedRight ] . [ GrantorSysAdminUnitId ] = newManagers . [ Id ] ) ) Roles ; OPEN @getUserAdminUnits ; FETCH NEXT FROM @getUserAdminUnits INTO @SysAdminUnitId ; WHILE @ @FETCH_STATUS = 0 BEGIN INSERT INTO [ SysAdminUnitInRole ] ( [ SysAdminUnitId ] , [ SysAdminUnitRoleId ] ) SELECT DISTINCT @SysAdminUnitId , [ Id ] FROM @NewRoles AS newRoles WHERE NOT EXISTS ( SELECT 1 FROM [ SysAdminUnitInRole ] WHERE [ SysAdminUnitInRole ] . [ SysAdminUnitId ] = @SysAdminUnitId AND [ SysAdminUnitInRole ] . [ SysAdminUnitRoleId ] = newRoles . [ Id ] ) ; FETCH NEXT FROM @getUserAdminUnits INTO @SysAdminUnitId ; END ; CLOSE @getUserAdminUnits ; DEALLOCATE @getUserAdminUnits ; DECLARE @isUserLostAtLeastOneRole INT = ( SELECT COUNT ( * ) FROM @OldUserRoles AS oldUserRoles WHERE NOT EXISTS ( SELECT 1 FROM @NewRoles AS newUserRoles WHERE newUserRoles . [ Id ] = oldUserRoles . [ Id ] ) ) ; -- Still (who were and remained) user managers INSERT INTO @StillManagers SELECT DISTINCT managersAfterActualization . [ Id ] AS [ Id ] FROM @ManagersAfterActualization AS managersAfterActualization JOIN @ManagersBeforeActualization AS managersBeforeActualization ON managersAfterActualization . [ Id ] = managersBeforeActualization . [ Id ] ; -- If user lost at least one role, we need to actualize all his still-managers. -- If not (user only gained new roles) - we just add to still-managers and their grantee-users new user roles. IF ( @isUserLostAtLeastOneRole = 0 ) BEGIN -- Add all new user roles to his still-managers and to their grantee-users SET @getUserAdminUnits = CURSOR FOR SELECT DISTINCT [ Id ] FROM ( SELECT stillManagers . [ Id ] AS [ Id ] FROM @StillManagers AS stillManagers UNION SELECT [ GranteeSysAdminUnitId ] FROM [ SysAdminUnitGrantedRight ] WHERE EXISTS ( SELECT NULL FROM @StillManagers AS stillManagers WHERE stillManagers . [ Id ] = [ GrantorSysAdminUnitId ] ) ) Roles ; OPEN @getUserAdminUnits ; FETCH NEXT FROM @getUserAdminUnits INTO @SysAdminUnitId ; WHILE @ @FETCH_STATUS = 0 BEGIN INSERT INTO [ SysAdminUnitInRole ] ( [ SysAdminUnitId ] , [ SysAdminUnitRoleId ] ) SELECT DISTINCT @SysAdminUnitId , [ Id ] FROM @NewRoles AS newRoles WHERE NOT EXISTS ( SELECT 1 FROM [ SysAdminUnitInRole ] WHERE [ SysAdminUnitInRole ] . [ SysAdminUnitId ] = @SysAdminUnitId AND [ SysAdminUnitInRole ] . [ SysAdminUnitRoleId ] = newRoles . [ Id ] ) ; FETCH NEXT FROM @getUserAdminUnits INTO @SysAdminUnitId ; END ; CLOSE @getUserAdminUnits ; DEALLOCATE @getUserAdminUnits ; END ELSE BEGIN --Actualize all roles for still-managers SET @getUserAdminUnits = CURSOR FOR SELECT DISTINCT [ Id ] FROM @StillManagers UNION SELECT [ GranteeSysAdminUnitId ] FROM [ SysAdminUnitGrantedRight ] WHERE EXISTS ( SELECT NULL FROM @StillManagers AS stillManagers WHERE stillManagers . [ Id ] = [ GrantorSysAdminUnitId ] ) ; OPEN @getUserAdminUnits ; FETCH NEXT FROM @getUserAdminUnits INTO @SysAdminUnitId ; WHILE @ @FETCH_STATUS = 0 BEGIN DELETE FROM @SysAdminUnitRoles ; INSERT INTO @SysAdminUnitRoles EXEC [ tsp_GetAdminUnitList ] @UserId = @SysAdminUnitId ; BEGIN TRAN ; DELETE FROM [ dbo ] . [ SysAdminUnitInRole ] WHERE SysAdminUnitId = @SysAdminUnitId ; INSERT INTO [ dbo ] . [ SysAdminUnitInRole ] ( SysAdminUnitId , SysAdminUnitRoleId ) SELECT @SysAdminUnitId , [ Id ] FROM @SysAdminUnitRoles ; COMMIT ; FETCH NEXT FROM @getUserAdminUnits INTO @SysAdminUnitId ; END ; CLOSE @getUserAdminUnits ; DEALLOCATE @getUserAdminUnits ; END ; -- No longer (who were but not remained) user managers INSERT INTO @NoLongerManagers SELECT [ Id ] FROM @ManagersBeforeActualization as managersBeforeActualization WHERE NOT EXISTS ( SELECT NULL FROM @ManagersAfterActualization AS managersAfterActualization WHERE managersAfterActualization . [ Id ] = managersBeforeActualization . [ Id ] ) ; -- Actualize roles for all noLonger-managers, his grantee-users and all grantee-users of user SET @getUserAdminUnits = CURSOR FOR SELECT DISTINCT [ Id ] FROM ( SELECT [ Id ] FROM @NoLongerManagers UNION SELECT [ GranteeSysAdminUnitId ] FROM [ SysAdminUnitGrantedRight ] WHERE EXISTS ( SELECT NULL FROM @NoLongerManagers AS noLongerManagers WHERE noLongerManagers . [ Id ] = [ GrantorSysAdminUnitId ] ) UNION ALL SELECT GranteeSysAdminUnitId FROM SysAdminUnitGrantedRight WHERE GrantorSysAdminUnitId = @UserId ) Roles ; OPEN @getUserAdminUnits ; FETCH NEXT FROM @getUserAdminUnits INTO @SysAdminUnitId ; WHILE @ @FETCH_STATUS = 0 BEGIN DELETE FROM @SysAdminUnitRoles ; INSERT INTO @SysAdminUnitRoles EXEC [ tsp_GetAdminUnitList ] @UserId = @SysAdminUnitId ; BEGIN TRAN ; DELETE FROM [ dbo ] . [ SysAdminUnitInRole ] WHERE SysAdminUnitId = @SysAdminUnitId ; INSERT INTO [ dbo ] . [ SysAdminUnitInRole ] ( SysAdminUnitId , SysAdminUnitRoleId ) SELECT @SysAdminUnitId , [ Id ] FROM @SysAdminUnitRoles ; COMMIT ; FETCH NEXT FROM @getUserAdminUnits INTO @SysAdminUnitId ; END ; CLOSE @getUserAdminUnits ; DEALLOCATE @getUserAdminUnits ; IF OBJECT_ID ( 'tempdb..#AdminUnitListTemp' ) IS NOT NULL BEGIN DROP TABLE [ #AdminUnitListTemp]; END ; END ; GO -- Stored procedure that uses loops, cursors, and temporary tables -- PostgreSQL DROP FUNCTION IF EXISTS \"tsp_ActualizeUserRoles\" ; CREATE FUNCTION \"tsp_ActualizeUserRoles\" ( UserId UUID ) RETURNS VOID AS $$ DECLARE getUserNewManagers CURSOR FOR SELECT DISTINCT \"Id\" FROM ( SELECT \"Id\" FROM \"NewManagers\" UNION SELECT \"GranteeSysAdminUnitId\" FROM \"SysAdminUnitGrantedRight\" WHERE EXISTS ( SELECT NULL FROM \"NewManagers\" as \"newManagers\" WHERE \"SysAdminUnitGrantedRight\" . \"GrantorSysAdminUnitId\" = \"newManagers\" . \"Id\" ) ) \"Roles\" ; lostUserRolesCount INT ; getUserStillManagers CURSOR FOR SELECT DISTINCT \"stillManagers\" . \"Id\" AS \"Id\" FROM \"StillManagers\" AS \"stillManagers\" UNION SELECT \"GranteeSysAdminUnitId\" FROM \"SysAdminUnitGrantedRight\" WHERE EXISTS ( SELECT NULL FROM \"StillManagers\" AS \"stillManagers\" WHERE \"stillManagers\" . \"Id\" = \"GrantorSysAdminUnitId\" ) ; getUserNoLongerManagers CURSOR FOR SELECT DISTINCT \"Id\" FROM ( SELECT \"Id\" FROM \"NoLongerManagers\" UNION SELECT \"GranteeSysAdminUnitId\" FROM \"SysAdminUnitGrantedRight\" WHERE EXISTS ( SELECT NULL FROM \"NoLongerManagers\" AS \"noLongerManagers\" WHERE \"noLongerManagers\" . \"Id\" = \"GrantorSysAdminUnitId\" ) UNION ALL SELECT \"GranteeSysAdminUnitId\" FROM \"SysAdminUnitGrantedRight\" WHERE \"GrantorSysAdminUnitId\" = UserId ) \"Roles\" ; BEGIN DROP TABLE IF EXISTS \"GetAdminUnitListTmp\" ; CREATE TEMP TABLE \"GetAdminUnitListTmp\" ( \"Id\" UUID , \"Name\" VARCHAR ( 250 ) , \"ParentRoleId\" UUID ) ; DROP TABLE IF EXISTS \"SysAdminUnitRoles\" ; CREATE TEMP TABLE \"SysAdminUnitRoles\" ( \"Id\" UUID , \"Name\" VARCHAR ( 250 ) , \"ParentRoleId\" UUID ) ; -- Old user roles DROP TABLE IF EXISTS \"OldUserRoles\" ; CREATE TEMP TABLE \"OldUserRoles\" ( \"Id\" UUID ) ; INSERT INTO \"OldUserRoles\" SELECT DISTINCT \"SysAdminUnitInRole\" . \"SysAdminUnitRoleId\" \"Id\" FROM \"SysAdminUnitInRole\" WHERE \"SysAdminUnitInRole\" . \"SysAdminUnitId\" = UserId ; -- Old user managers DROP TABLE IF EXISTS \"ManagersBeforeActualization\" ; CREATE TEMP TABLE \"ManagersBeforeActualization\" ( \"Id\" UUID ) ; INSERT INTO \"ManagersBeforeActualization\" SELECT DISTINCT \"SysUserInRole\" . \"SysUserId\" \"Id\" FROM \"SysAdminUnitInRole\" INNER JOIN \"SysAdminUnit\" \"Roles\" ON \"SysAdminUnitInRole\" . \"SysAdminUnitRoleId\" = \"Roles\" . \"Id\" INNER JOIN \"OldUserRoles\" ON \"Roles\" . \"ParentRoleId\" = \"OldUserRoles\" . \"Id\" INNER JOIN \"SysUserInRole\" ON \"SysUserInRole\" . \"SysRoleId\" = \"Roles\" . \"Id\" WHERE \"Roles\" . \"SysAdminUnitTypeValue\" = 2 ; -- Get and insert new user roles DROP TABLE IF EXISTS \"GetAdminUnitList\" ; CREATE TEMP TABLE \"GetAdminUnitList\" ( \"Id\" UUID , \"Name\" VARCHAR ( 250 ) , \"ParentRoleId\" UUID ) ; DROP TABLE IF EXISTS \"NewRoles\" ; CREATE TEMP TABLE \"NewRoles\" ( \"Id\" UUID ) ; INSERT INTO \"GetAdminUnitList\" SELECT * FROM \"tsp_GetAdminUnitList\" ( UserId ) ; INSERT INTO \"NewRoles\" SELECT \"Id\" FROM \"GetAdminUnitList\" ; DELETE FROM \"SysAdminUnitInRole\" WHERE \"SysAdminUnitId\" = UserId ; INSERT INTO \"SysAdminUnitInRole\" ( \"SysAdminUnitId\" , \"SysAdminUnitRoleId\" ) SELECT DISTINCT UserId , \"Id\" FROM \"NewRoles\" ; -- User managers after actualization DROP TABLE IF EXISTS \"ManagersAfterActualization\" ; CREATE TEMP TABLE \"ManagersAfterActualization\" ( \"Id\" UUID ) ; INSERT INTO \"ManagersAfterActualization\" SELECT DISTINCT \"SysUserInRole\" . \"SysUserId\" \"Id\" FROM \"SysAdminUnitInRole\" INNER JOIN \"SysAdminUnit\" \"Roles\" ON \"SysAdminUnitInRole\" . \"SysAdminUnitRoleId\" = \"Roles\" . \"Id\" INNER JOIN \"NewRoles\" \"NewRoles\" ON \"Roles\" . \"ParentRoleId\" = \"NewRoles\" . \"Id\" INNER JOIN \"SysUserInRole\" ON \"SysUserInRole\" . \"SysRoleId\" = \"Roles\" . \"Id\" WHERE \"Roles\" . \"SysAdminUnitTypeValue\" = 2 ; -- New (who were not but become) user managers DROP TABLE IF EXISTS \"NewManagers\" ; CREATE TEMP TABLE \"NewManagers\" ( \"Id\" UUID ) ; INSERT INTO \"NewManagers\" SELECT \"Id\" FROM \"ManagersAfterActualization\" AS \"managersAfterActualization\" WHERE NOT EXISTS ( SELECT NULL FROM \"ManagersBeforeActualization\" AS \"managersBeforeActualization\" WHERE \"managersBeforeActualization\" . \"Id\" = \"managersAfterActualization\" . \"Id\" ) ; -- Add all user roles to new managers and their grantee-users, if they arent already have FOR UserNewManager IN getUserNewManagers LOOP EXIT WHEN UserNewManager = NULL ; INSERT INTO \"SysAdminUnitInRole\" ( \"SysAdminUnitId\" , \"SysAdminUnitRoleId\" ) SELECT DISTINCT UserNewManager . \"Id\" , \"Id\" FROM \"NewRoles\" AS \"newRoles\" WHERE NOT EXISTS ( SELECT 1 FROM \"SysAdminUnitInRole\" WHERE \"SysAdminUnitInRole\" . \"SysAdminUnitId\" = UserNewManager . \"Id\" AND \"SysAdminUnitInRole\" . \"SysAdminUnitRoleId\" = \"newRoles\" . \"Id\" ) ; END LOOP ; SELECT COUNT ( * ) INTO lostUserRolesCount FROM \"OldUserRoles\" AS \"oldUserRoles\" WHERE NOT EXISTS ( SELECT 1 FROM \"NewRoles\" AS \"newUserRoles\" WHERE \"newUserRoles\" . \"Id\" = \"oldUserRoles\" . \"Id\" ) ; -- Still (who were and remained) user managers DROP TABLE IF EXISTS \"StillManagers\" ; CREATE TEMP TABLE \"StillManagers\" ( \"Id\" UUID ) ; INSERT INTO \"StillManagers\" SELECT DISTINCT \"managersAfterActualization\" . \"Id\" AS \"Id\" FROM \"ManagersAfterActualization\" AS \"managersAfterActualization\" JOIN \"ManagersBeforeActualization\" AS \"managersBeforeActualization\" ON \"managersAfterActualization\" . \"Id\" = \"managersBeforeActualization\" . \"Id\" ; -- If user lost at least one role, we need to actualize all his still-managers. -- If not (user only gained new roles) - we just add to still-managers and their grantee-users new user roles. IF lostUserRolesCount = 0 THEN -- Add all new user roles to his still-managers and to their grantee-users FOR UserStillManager IN getUserStillManagers LOOP EXIT WHEN UserStillManager = NULL ; INSERT INTO \"SysAdminUnitInRole\" ( \"SysAdminUnitId\" , \"SysAdminUnitRoleId\" ) SELECT DISTINCT UserStillManager . \"Id\" , \"Id\" FROM \"NewRoles\" AS \"newRoles\" WHERE NOT EXISTS ( SELECT 1 FROM \"SysAdminUnitInRole\" WHERE \"SysAdminUnitInRole\" . \"SysAdminUnitId\" = UserStillManager . \"Id\" AND \"SysAdminUnitInRole\" . \"SysAdminUnitRoleId\" = \"newRoles\" . \"Id\" ) ; END LOOP ; ELSE --Actualize all roles for still-managers FOR UserStillManager IN getUserStillManagers LOOP EXIT WHEN UserStillManager = NULL ; DELETE FROM \"SysAdminUnitRoles\" ; INSERT INTO \"SysAdminUnitRoles\" SELECT * FROM \"tsp_GetAdminUnitList\" ( UserStillManager . \"Id\" ) ; DELETE FROM \"SysAdminUnitInRole\" WHERE \"SysAdminUnitId\" = UserStillManager . \"Id\" ; INSERT INTO \"SysAdminUnitInRole\" ( \"SysAdminUnitId\" , \"SysAdminUnitRoleId\" ) SELECT UserStillManager . \"Id\" , \"Id\" FROM \"SysAdminUnitRoles\" ; END LOOP ; END IF ; -- No longer (who were but not remained) user managers DROP TABLE IF EXISTS \"NoLongerManagers\" ; CREATE TEMP TABLE \"NoLongerManagers\" ( \"Id\" UUID ) ; INSERT INTO \"NoLongerManagers\" SELECT \"Id\" FROM \"ManagersBeforeActualization\" AS \"managersBeforeActualization\" WHERE NOT EXISTS ( SELECT NULL FROM \"ManagersAfterActualization\" AS \"managersAfterActualization\" WHERE \"managersAfterActualization\" . \"Id\" = \"managersBeforeActualization\" . \"Id\" ) ; -- Actualize roles for all noLonger-managers, his grantee-users and all grantee-users of user FOR UserNoLongerManager IN getUserNoLongerManagers LOOP EXIT WHEN UserNoLongerManager = NULL ; DELETE FROM \"SysAdminUnitRoles\" ; INSERT INTO \"SysAdminUnitRoles\" SELECT * FROM \"tsp_GetAdminUnitList\" ( UserNoLongerManager . \"Id\" ) ; DELETE FROM \"SysAdminUnitInRole\" WHERE \"SysAdminUnitId\" = UserNoLongerManager . \"Id\" ; INSERT INTO \"SysAdminUnitInRole\" ( \"SysAdminUnitId\" , \"SysAdminUnitRoleId\" ) SELECT UserNoLongerManager . \"Id\" , \"Id\" FROM \"SysAdminUnitRoles\" ; END LOOP ; DROP TABLE IF EXISTS \"GetAdminUnitListTmp\" ; END ; $$ LANGUAGE plpgsql ; Example 4 (stored procedures) ​ Example Example of a recursive stored procedure that returns a table and uses PERFORM . MSSQL PostgreSQL -- Recursive stored procedure that returns a table and uses PERFORM: -- MSSQL IF NOT OBJECT_ID ( '[dbo].[tsp_GetAdminUnitList]' ) IS NULL BEGIN DROP PROCEDURE [ dbo ] . [ tsp_GetAdminUnitList ] ; END ; GO CREATE PROCEDURE dbo . tsp_GetAdminUnitList ( @UserId uniqueidentifier , @Granted BIT = 0 ) AS BEGIN SET NOCOUNT ON ; DECLARE @StartNestedLevel INT ; IF object_id ( 'tempdb..#AdminUnitList' ) IS NULL BEGIN CREATE TABLE [ #AdminUnitList] ( [ Id ] uniqueidentifier NOT NULL , [ Name ] NVARCHAR ( 250 ) NULL , [ ParentRoleId ] uniqueidentifier NULL , [ Granted ] BIT NULL , Level INT NOT NULL ) ; SET @StartNestedLevel = @ @NESTLEVEL ; END ; DECLARE @ConnectionType INT = ( SELECT [ ConnectionType ] FROM SysAdminUnit WHERE [ Id ] = @UserId ) ; -- #AdminUnitListTemp should be created in tsp_ActualizeUserRoles or in tsp_ActualizeAdminUnitInRole DECLARE @IsAdminUnitListTempExists BIT = OBJECT_ID ( 'tempdb..#AdminUnitListTemp' ) ; IF ( @IsAdminUnitListTempExists IS NULL ) BEGIN WITH [ MainSelect ] AS ( SELECT [ Id ] [ Id ] , [ Name ] [ Name ] , [ ParentRoleId ] [ ParentRoleId ] FROM [ dbo ] . [ SysAdminUnit ] WHERE ( [ SysAdminUnitTypeValue ] <= 4 OR [ SysAdminUnitTypeValue ] = 6 ) AND [ ConnectionType ] = @ConnectionType UNION ALL SELECT [ Id ] [ Id ] , [ Name ] [ Name ] , [ ParentRoleId ] [ ParentRoleId ] FROM [ dbo ] . [ SysAdminUnit ] WHERE [ Id ] = @UserId ) , [ ChiefUnitsSelect ] AS ( ( SELECT [ Chief ] . [ ParentRoleId ] [ Id ] FROM [ dbo ] . [ SysUserInRole ] userInRole INNER JOIN [ dbo ] . [ SysAdminUnit ] sau ON ( sau . [ Id ] = userInRole . [ SysUserId ] ) INNER JOIN [ dbo ] . [ SysAdminUnit ] [ Chief ] ON ( [ Chief ] . [ Id ] = userInRole . [ SysRoleId ] ) WHERE sau . [ Id ] = @UserId AND NOT ( userInRole . [ SysRoleId ] IS NULL ) AND [ Chief ] . [ SysAdminUnitTypeValue ] = 2 UNION ALL SELECT [ Chief ] . [ ParentRoleId ] [ Id ] FROM [ dbo ] . [ SysAdminUnit ] [ Chief ] WHERE [ Chief ] . [ Id ] = @UserId AND [ Chief ] . [ SysAdminUnitTypeValue ] = 2 ) UNION ALL SELECT sau . [ Id ] FROM [ ChiefUnitsSelect ] INNER JOIN [ dbo ] . [ SysAdminUnit ] sau ON ( sau . [ ParentRoleId ] = [ ChiefUnitsSelect ] . [ Id ] ) WHERE sau . [ SysAdminUnitTypeValue ] < 4 ) , [ HierarchicalSelect ] AS ( SELECT [ Id ] , [ Name ] , [ ParentRoleId ] , 0 [ Level ] FROM [ MainSelect ] [ SelectStartLevel ] WHERE [ Id ] IN ( SELECT userInRole . [ SysRoleId ] FROM [ dbo ] . [ SysUserInRole ] userInRole INNER JOIN [ dbo ] . [ SysAdminUnit ] sau ON ( sau . [ Id ] = userInRole . [ SysUserId ] ) WHERE sau . [ Id ] = @UserId UNION ALL SELECT [ Id ] FROM [ ChiefUnitsSelect ] UNION ALL SELECT [ Id ] FROM [ dbo ] . [ SysAdminUnit ] WHERE ( [ ParentRoleId ] IS NULL OR [ Id ] = @UserId ) AND [ SysAdminUnitTypeValue ] < 4 UNION ALL SELECT [ FuncRoleId ] FROM [ dbo ] . [ SysFuncRoleInOrgRole ] WHERE [ SysFuncRoleInOrgRole ] . [ OrgRoleId ] = @UserId ) UNION ALL SELECT [ SelectPriorLevel ] . [ Id ] , [ SelectPriorLevel ] . [ Name ] , [ SelectPriorLevel ] . [ ParentRoleId ] , [ Level ] + 1 level FROM [ MainSelect ] [ SelectPriorLevel ] INNER JOIN [ HierarchicalSelect ] hierSelect ON ( hierSelect . [ ParentRoleId ] = [ SelectPriorLevel ] . [ Id ] ) ) , [ FuncRoleHierarchicalSelect ] AS ( SELECT [ Id ] , [ Name ] , [ ParentRoleId ] , 0 [ Level ] FROM [ MainSelect ] [ StartLevel ] WHERE EXISTS ( SELECT NULL FROM [ dbo ] . [ SysFuncRoleInOrgRole ] funcRoleInOrgRole INNER JOIN [ HierarchicalSelect ] hierSelect ON funcRoleInOrgRole . [ OrgRoleId ] = hierSelect . [ Id ] WHERE funcRoleInOrgRole . [ FuncRoleId ] = [ StartLevel ] . [ Id ] ) UNION ALL SELECT [ PriorLevel ] . [ Id ] , [ PriorLevel ] . [ Name ] , [ PriorLevel ] . [ ParentRoleId ] , [ Level ] + 1 level FROM [ MainSelect ] [ PriorLevel ] INNER JOIN [ FuncRoleHierarchicalSelect ] funcRoleHierSelect ON ( funcRoleHierSelect . [ ParentRoleId ] = [ PriorLevel ] . [ Id ] ) ) , [ DependentUserSelect ] AS ( SELECT mainSelect . [ Id ] [ Id ] , mainSelect . [ Name ] [ Name ] , mainSelect . [ ParentRoleId ] [ ParentRoleId ] , 0 [ Level ] FROM [ MainSelect ] mainSelect INNER JOIN [ SysUserInRole ] userInRole ON mainSelect . [ Id ] = userInRole . [ SysUserId ] INNER JOIN [ ChiefUnitsSelect ] [ AllUnits ] ON [ AllUnits ] . [ Id ] = userInRole . [ SysRoleId ] WHERE NOT EXISTS ( SELECT [ UserUnits ] . [ Id ] FROM [ ChiefUnitsSelect ] [ UserUnits ] INNER JOIN [ SysUserInRole ] [ UserInRole ] ON [ UserUnits ] . [ Id ] = [ UserInRole ] . [ SysRoleId ] INNER JOIN [ SysAdminUnit ] sau ON sau . [ Id ] = [ UserUnits ] . [ Id ] WHERE sau . [ SysAdminUnitTypeValue ] = 2 AND [ UserInRole ] . [ SysUserId ] = @UserId AND [ UserUnits ] . [ Id ] = [ AllUnits ] . [ Id ] ) ) INSERT INTO [ #AdminUnitList] ([Id], [Name], [ParentRoleId], [Granted], [Level]) SELECT DISTINCT [ Id ] , [ Name ] , [ ParentRoleId ] , @Granted , @ @NESTLEVEL FROM ( SELECT [ Id ] , [ Name ] , [ ParentRoleId ] FROM [ HierarchicalSelect ] UNION ALL SELECT [ Id ] , [ Name ] , [ ParentRoleId ] FROM [ dbo ] . [ SysAdminUnit ] WHERE [ Id ] = @UserId UNION ALL SELECT [ Id ] , [ Name ] , [ ParentRoleId ] FROM [ FuncRoleHierarchicalSelect ] UNION ALL SELECT [ Id ] , [ Name ] , [ ParentRoleId ] FROM [ DependentUserSelect ] ) [ AdminUnitList ] ; END ELSE BEGIN DECLARE @alreadyGotRolesForThisUser bit = 0 ; IF ( @IsAdminUnitListTempExists = 1 ) BEGIN SET @alreadyGotRolesForThisUser = ( SELECT CAST ( CASE WHEN EXISTS ( SELECT 1 FROM [ #AdminUnitListTemp] WHERE [ UserId ] = @UserId ) THEN 1 ELSE 0 END AS BIT ) ) ; END ; IF ( @alreadyGotRolesForThisUser = 1 ) BEGIN INSERT INTO [ #AdminUnitList] ([Id], [Name], [ParentRoleId], [Granted], [Level]) SELECT DISTINCT [ Id ] , [ Name ] , [ ParentRoleId ] , @Granted , @ @NESTLEVEL FROM [ #AdminUnitListTemp] WHERE UserId = @UserId; END ELSE BEGIN WITH [ MainSelect ] AS ( SELECT [ Id ] [ Id ] , [ Name ] [ Name ] , [ ParentRoleId ] [ ParentRoleId ] FROM [ dbo ] . [ SysAdminUnit ] WHERE ( [ SysAdminUnitTypeValue ] <= 4 OR [ SysAdminUnitTypeValue ] = 6 ) AND [ ConnectionType ] = @ConnectionType UNION ALL SELECT [ Id ] [ Id ] , [ Name ] [ Name ] , [ ParentRoleId ] [ ParentRoleId ] FROM [ dbo ] . [ SysAdminUnit ] WHERE [ Id ] = @UserId ) , [ ChiefUnitsSelect ] AS ( ( SELECT [ Chief ] . [ ParentRoleId ] [ Id ] FROM [ dbo ] . [ SysUserInRole ] sysUserInRole INNER JOIN [ dbo ] . [ SysAdminUnit ] sau ON ( sau . [ Id ] = sysUserInRole . [ SysUserId ] ) INNER JOIN [ dbo ] . [ SysAdminUnit ] [ Chief ] ON ( [ Chief ] . [ Id ] = sysUserInRole . [ SysRoleId ] ) WHERE sau . [ Id ] = @UserId AND NOT ( sysUserInRole . [ SysRoleId ] IS NULL ) AND [ Chief ] . [ SysAdminUnitTypeValue ] = 2 UNION ALL SELECT [ Chief ] . [ ParentRoleId ] [ Id ] FROM [ dbo ] . [ SysAdminUnit ] [ Chief ] WHERE [ Chief ] . [ Id ] = @UserId AND [ Chief ] . [ SysAdminUnitTypeValue ] = 2 ) UNION ALL SELECT sau . [ Id ] FROM [ ChiefUnitsSelect ] ChiefUnitsSelect INNER JOIN [ dbo ] . [ SysAdminUnit ] sau ON ( sau . [ ParentRoleId ] = [ ChiefUnitsSelect ] . [ Id ] ) WHERE sau . [ SysAdminUnitTypeValue ] < 4 ) , [ HierarchicalSelect ] AS ( SELECT [ Id ] , [ Name ] , [ ParentRoleId ] , 0 [ Level ] FROM [ MainSelect ] [ SelectStartLevel ] WHERE EXISTS ( SELECT NULL FROM ( SELECT [ SysUserInRole ] . [ SysRoleId ] AS RoleId FROM [ dbo ] . [ SysUserInRole ] INNER JOIN [ dbo ] . [ SysAdminUnit ] ON ( [ SysAdminUnit ] . [ Id ] = [ SysUserInRole ] . [ SysUserId ] ) WHERE [ SysAdminUnit ] . [ Id ] = @UserId UNION ALL SELECT [ Id ] AS RoleId FROM [ ChiefUnitsSelect ] UNION ALL SELECT [ Id ] AS RoleId FROM [ dbo ] . [ SysAdminUnit ] WHERE ( [ ParentRoleId ] IS NULL OR [ Id ] = @UserId ) AND [ SysAdminUnitTypeValue ] < 4 UNION ALL SELECT [ FuncRoleId ] AS RoleId FROM [ dbo ] . [ SysFuncRoleInOrgRole ] WHERE [ SysFuncRoleInOrgRole ] . [ OrgRoleId ] = @UserId ) AS Roles WHERE Roles . RoleId = [ SelectStartLevel ] . [ Id ] ) UNION ALL SELECT [ SelectPriorLevel ] . [ Id ] , [ SelectPriorLevel ] . [ Name ] , [ SelectPriorLevel ] . [ ParentRoleId ] , [ Level ] + 1 level FROM [ MainSelect ] [ SelectPriorLevel ] INNER JOIN [ HierarchicalSelect ] hierSelect ON ( hierSelect . [ ParentRoleId ] = [ SelectPriorLevel ] . [ Id ] ) ) , [ FuncRoleHierarchicalSelect ] AS ( SELECT [ Id ] , [ Name ] , [ ParentRoleId ] , 0 [ Level ] FROM [ MainSelect ] [ StartLevel ] WHERE EXISTS ( SELECT NULL FROM [ dbo ] . [ SysFuncRoleInOrgRole ] funcRoleInOrgRole INNER JOIN [ HierarchicalSelect ] hierSelect ON funcRoleInOrgRole . [ OrgRoleId ] = hierSelect . [ Id ] WHERE funcRoleInOrgRole . [ FuncRoleId ] = [ StartLevel ] . [ Id ] ) UNION ALL SELECT [ PriorLevel ] . [ Id ] , [ PriorLevel ] . [ Name ] , [ PriorLevel ] . [ ParentRoleId ] , [ Level ] + 1 FROM [ MainSelect ] [ PriorLevel ] INNER JOIN [ FuncRoleHierarchicalSelect ] funcRolesHierSelect ON ( funcRolesHierSelect . [ ParentRoleId ] = [ PriorLevel ] . [ Id ] ) ) , [ DependentUserSelect ] AS ( SELECT [ MainSelect ] . [ Id ] [ Id ] , [ MainSelect ] . [ Name ] [ Name ] , [ MainSelect ] . [ ParentRoleId ] [ ParentRoleId ] , 0 [ Level ] FROM [ MainSelect ] INNER JOIN [ SysUserInRole ] sysUserInRole ON [ MainSelect ] . [ Id ] = sysUserInRole . [ SysUserId ] INNER JOIN [ ChiefUnitsSelect ] [ AllUnits ] ON [ AllUnits ] . [ Id ] = sysUserInRole . [ SysRoleId ] WHERE NOT EXISTS ( SELECT [ UserUnits ] . [ Id ] FROM [ ChiefUnitsSelect ] [ UserUnits ] INNER JOIN [ SysUserInRole ] [ UserInRole ] ON [ UserUnits ] . [ Id ] = [ UserInRole ] . [ SysRoleId ] INNER JOIN [ SysAdminUnit ] sau ON sau . [ Id ] = [ UserUnits ] . [ Id ] WHERE sau . [ SysAdminUnitTypeValue ] = 2 AND [ UserInRole ] . [ SysUserId ] = @UserId AND [ UserUnits ] . [ Id ] = [ AllUnits ] . [ Id ] ) ) INSERT INTO #AdminUnitListTemp ([UserId], [Id], [Name], [ParentRoleId], [Granted]) SELECT DISTINCT @UserId , [ Id ] , [ Name ] , [ ParentRoleId ] , @Granted FROM ( SELECT [ Id ] , [ Name ] , [ ParentRoleId ] FROM [ HierarchicalSelect ] UNION ALL SELECT [ Id ] , [ Name ] , [ ParentRoleId ] FROM [ dbo ] . [ SysAdminUnit ] WHERE [ Id ] = @UserId UNION ALL SELECT [ Id ] , [ Name ] , [ ParentRoleId ] FROM [ FuncRoleHierarchicalSelect ] UNION ALL SELECT [ Id ] , [ Name ] , [ ParentRoleId ] FROM [ DependentUserSelect ] ) [ AdminUnitList ] ; INSERT INTO [ #AdminUnitList] ([Id], [Name], [ParentRoleId], [Granted], [Level]) SELECT DISTINCT [ Id ] , [ Name ] , [ ParentRoleId ] , @Granted , @ @NESTLEVEL FROM [ #AdminUnitListTemp] WHERE UserId = @UserId; END ; END ; DECLARE @DependentUserId uniqueidentifier ; DECLARE @DependentUsersList CURSOR ; SET @DependentUsersList = CURSOR FOR SELECT [ #AdminUnitList].[Id] FROM [ #AdminUnitList] INNER JOIN [ SysAdminUnit ] ON [ #AdminUnitList].[Id] = [SysAdminUnit].[Id] WHERE [ SysAdminUnit ] . [ SysAdminUnitTypeValue ] = 4 AND [ #AdminUnitList].[Id] <> @UserId AND [ #AdminUnitList].[Granted] <> 1 AND [#AdminUnitList].[Level] >= @@NESTLEVEL; OPEN @DependentUsersList ; FETCH NEXT FROM @DependentUsersList INTO @DependentUserId ; WHILE @ @FETCH_STATUS = 0 BEGIN EXEC [ tsp_GetAdminUnitList ] @UserId = @DependentUserId , @Granted = 1 ; FETCH NEXT FROM @DependentUsersList INTO @DependentUserId ; END ; CLOSE @DependentUsersList ; DEALLOCATE @DependentUsersList ; DECLARE @GrantorSysAdminUnitId uniqueidentifier ; DECLARE @getGrantorSysAdminUnitList CURSOR ; SET @getGrantorSysAdminUnitList = CURSOR FOR SELECT [ GrantorSysAdminUnitId ] FROM [ dbo ] . [ SysAdminUnitGrantedRight ] WHERE [ GranteeSysAdminUnitId ] = @UserId AND NOT EXISTS ( SELECT * FROM [ #AdminUnitList] WHERE [Id] = @UserId AND [Granted] = 1 AND [Level] < @@NESTLEVEL); OPEN @getGrantorSysAdminUnitList ; FETCH NEXT FROM @getGrantorSysAdminUnitList INTO @GrantorSysAdminUnitId ; WHILE @ @FETCH_STATUS = 0 BEGIN EXEC [ tsp_GetAdminUnitList ] @UserId = @GrantorSysAdminUnitId , @Granted = 1 ; FETCH NEXT FROM @getGrantorSysAdminUnitList INTO @GrantorSysAdminUnitId ; END ; CLOSE @getGrantorSysAdminUnitList ; DEALLOCATE @getGrantorSysAdminUnitList ; IF @ @NESTLEVEL = @StartNestedLevel BEGIN WITH QQ ( [ Id ] , [ Name ] , [ ParentRoleId ] , SysAdminUnitTypeValue ) as ( SELECT DISTINCT adminUnitList . [ Id ] , adminUnitList . [ Name ] , adminUnitList . [ ParentRoleId ] , sau . SysAdminUnitTypeValue FROM [ #AdminUnitList] adminUnitList INNER JOIN SysAdminUnit sau on sau . Id = adminUnitList . [ Id ] ) SELECT [ Id ] , [ Name ] , [ ParentRoleId ] FROM QQ ORDER BY SysAdminUnitTypeValue DESC ; END ; END ; GO -- Recursive stored procedure that returns a table and uses PERFORM: -- PostgreSQL DROP FUNCTION IF EXISTS \"tsp_GetAdminUnitList\" ; CREATE FUNCTION \"tsp_GetAdminUnitList\" ( UserId UUID , IsGranted BOOLEAN = FALSE , NestLevel INT = 0 ) RETURNS TABLE ( \"Id\" UUID , \"Name\" VARCHAR ( 250 ) , \"ParentRoleId\" UUID ) AS $$ DECLARE ConnectionType INT ; IsAdminUnitListTempExists BOOLEAN = FALSE ; DependentUserId UUID ; DependentUsersList CURSOR FOR SELECT \"AdminUnitList\" . \"Id\" FROM \"AdminUnitList\" INNER JOIN \"SysAdminUnit\" ON \"AdminUnitList\" . \"Id\" = \"SysAdminUnit\" . \"Id\" WHERE \"SysAdminUnit\" . \"SysAdminUnitTypeValue\" = 4 AND \"AdminUnitList\" . \"Id\" <> UserId AND \"AdminUnitList\" . \"Granted\" = FALSE AND \"AdminUnitList\" . \"Level\" >= NestLevel ; GrantorSysAdminUnitId UUID ; GetGrantorSysAdminUnitList CURSOR FOR SELECT \"GrantorSysAdminUnitId\" AS \"Id\" FROM \"SysAdminUnitGrantedRight\" WHERE \"GranteeSysAdminUnitId\" = UserId AND NOT EXISTS ( SELECT * FROM \"AdminUnitList\" WHERE \"AdminUnitList\" . \"Id\" = UserId AND \"AdminUnitList\" . \"Granted\" = TRUE AND \"AdminUnitList\" . \"Level\" < NestLevel ) ; ParentRoleId UUID = NULL ; BEGIN IF NestLevel = 0 THEN CREATE TEMPORARY TABLE IF NOT EXISTS \"AdminUnitList\" ( \"Id\" UUID , \"Name\" VARCHAR ( 250 ) , \"ParentRoleId\" UUID , \"Granted\" BOOLEAN , \"Level\" INT ) ; TRUNCATE TABLE \"AdminUnitList\" ; END IF ; SELECT \"ConnectionType\" INTO ConnectionType FROM \"SysAdminUnit\" WHERE \"SysAdminUnit\" . \"Id\" = UserId ; WITH RECURSIVE \"MainSelect\" AS ( SELECT \"SysAdminUnit\" . \"Id\" \"Id\" , \"SysAdminUnit\" . \"Name\" \"Name\" , \"SysAdminUnit\" . \"ParentRoleId\" \"ParentRoleId\" FROM \"SysAdminUnit\" WHERE ( \"SysAdminUnitTypeValue\" <= 4 OR \"SysAdminUnitTypeValue\" = 6 ) AND \"ConnectionType\" = ConnectionType UNION ALL SELECT \"SysAdminUnit\" . \"Id\" \"Id\" , \"SysAdminUnit\" . \"Name\" \"Name\" , \"SysAdminUnit\" . \"ParentRoleId\" \"ParentRoleId\" FROM \"SysAdminUnit\" WHERE \"SysAdminUnit\" . \"Id\" = UserId ) , \"ChiefUnitsSelect\" AS ( SELECT \"chief\" . \"ParentRoleId\" \"Id\" FROM \"SysUserInRole\" AS \"userInRole\" INNER JOIN \"SysAdminUnit\" AS \"sau\" ON ( \"sau\" . \"Id\" = \"userInRole\" . \"SysUserId\" ) INNER JOIN \"SysAdminUnit\" AS \"chief\" ON ( \"chief\" . \"Id\" = \"userInRole\" . \"SysRoleId\" ) WHERE \"sau\" . \"Id\" = UserId AND \"userInRole\" . \"SysRoleId\" IS NOT NULL AND \"chief\" . \"SysAdminUnitTypeValue\" = 2 UNION ALL SELECT \"chief\" . \"ParentRoleId\" \"Id\" FROM \"SysAdminUnit\" \"chief\" WHERE \"chief\" . \"Id\" = UserId AND \"chief\" . \"SysAdminUnitTypeValue\" = 2 UNION ALL SELECT \"sau\" . \"Id\" FROM \"ChiefUnitsSelect\" INNER JOIN \"SysAdminUnit\" \"sau\" ON ( \"sau\" . \"ParentRoleId\" = \"ChiefUnitsSelect\" . \"Id\" ) WHERE \"sau\" . \"SysAdminUnitTypeValue\" < 4 ) , \"HierarchicalSelect\" AS ( SELECT \"SelectStartLevel\" . \"Id\" , \"SelectStartLevel\" . \"Name\" , \"SelectStartLevel\" . \"ParentRoleId\" , 0 \"Level\" FROM \"MainSelect\" \"SelectStartLevel\" WHERE \"SelectStartLevel\" . \"Id\" IN ( SELECT \"userInRole\" . \"SysRoleId\" FROM \"SysUserInRole\" AS \"userInRole\" INNER JOIN \"SysAdminUnit\" AS \"sau\" ON ( \"sau\" . \"Id\" = \"userInRole\" . \"SysUserId\" ) WHERE \"sau\" . \"Id\" = UserId UNION ALL SELECT \"ChiefUnitsSelect\" . \"Id\" FROM \"ChiefUnitsSelect\" UNION ALL SELECT \"SysAdminUnit\" . \"Id\" FROM \"SysAdminUnit\" WHERE ( \"SysAdminUnit\" . \"ParentRoleId\" IS NULL OR \"SysAdminUnit\" . \"Id\" = UserId ) AND \"SysAdminUnitTypeValue\" < 4 UNION ALL SELECT \"FuncRoleId\" FROM \"SysFuncRoleInOrgRole\" WHERE \"SysFuncRoleInOrgRole\" . \"OrgRoleId\" = UserId ) UNION ALL SELECT \"SelectPriorLevel\" . \"Id\" , \"SelectPriorLevel\" . \"Name\" , \"SelectPriorLevel\" . \"ParentRoleId\" , \"Level\" + 1 \"level\" FROM \"MainSelect\" \"SelectPriorLevel\" INNER JOIN \"HierarchicalSelect\" AS \"hierSelect\" ON ( \"hierSelect\" . \"ParentRoleId\" = \"SelectPriorLevel\" . \"Id\" ) ) , \"FuncRoleHierarchicalSelect\" AS ( SELECT \"StartLevel\" . \"Id\" , \"StartLevel\" . \"Name\" , \"StartLevel\" . \"ParentRoleId\" , 0 \"Level\" FROM \"MainSelect\" \"StartLevel\" WHERE EXISTS ( SELECT NULL FROM \"SysFuncRoleInOrgRole\" AS \"funcRoleInOrgRole\" INNER JOIN \"HierarchicalSelect\" AS \"hierSelect\" ON \"funcRoleInOrgRole\" . \"OrgRoleId\" = \"hierSelect\" . \"Id\" WHERE \"funcRoleInOrgRole\" . \"FuncRoleId\" = \"StartLevel\" . \"Id\" ) UNION ALL SELECT \"PriorLevel\" . \"Id\" , \"PriorLevel\" . \"Name\" , \"PriorLevel\" . \"ParentRoleId\" , \"Level\" + 1 \"level\" FROM \"MainSelect\" \"PriorLevel\" INNER JOIN \"FuncRoleHierarchicalSelect\" AS \"funcRoleHierSelect\" ON ( \"funcRoleHierSelect\" . \"ParentRoleId\" = \"PriorLevel\" . \"Id\" ) ) , \"DependentUserSelect\" AS ( SELECT \"mainSelect\" . \"Id\" \"Id\" , \"mainSelect\" . \"Name\" \"Name\" , \"mainSelect\" . \"ParentRoleId\" \"ParentRoleId\" , 0 \"Level\" FROM \"MainSelect\" AS \"mainSelect\" INNER JOIN \"SysUserInRole\" AS \"userInRole\" ON \"mainSelect\" . \"Id\" = \"userInRole\" . \"SysUserId\" INNER JOIN \"ChiefUnitsSelect\" AS \"AllUnits\" ON \"AllUnits\" . \"Id\" = \"userInRole\" . \"SysRoleId\" WHERE NOT EXISTS ( SELECT \"UserUnits\" . \"Id\" FROM \"ChiefUnitsSelect\" AS \"UserUnits\" INNER JOIN \"SysUserInRole\" AS \"UserInRole\" ON \"UserUnits\" . \"Id\" = \"UserInRole\" . \"SysRoleId\" INNER JOIN \"SysAdminUnit\" AS \"sau\" ON \"sau\" . \"Id\" = \"UserUnits\" . \"Id\" WHERE \"sau\" . \"SysAdminUnitTypeValue\" = 2 AND \"UserInRole\" . \"SysUserId\" = UserId AND \"UserUnits\" . \"Id\" = \"AllUnits\" . \"Id\" ) ) INSERT INTO \"AdminUnitList\" ( \"Id\" , \"Name\" , \"ParentRoleId\" , \"Granted\" , \"Level\" ) SELECT DISTINCT \"AdminUnitList\" . \"Id\" , \"AdminUnitList\" . \"Name\" , \"AdminUnitList\" . \"ParentRoleId\" , IsGranted , NestLevel FROM ( SELECT \"HierarchicalSelect\" . \"Id\" , \"HierarchicalSelect\" . \"Name\" , \"HierarchicalSelect\" . \"ParentRoleId\" FROM \"HierarchicalSelect\" UNION ALL SELECT \"SysAdminUnit\" . \"Id\" , \"SysAdminUnit\" . \"Name\" , \"SysAdminUnit\" . \"ParentRoleId\" FROM \"SysAdminUnit\" WHERE \"SysAdminUnit\" . \"Id\" = UserId UNION ALL SELECT \"FuncRoleHierarchicalSelect\" . \"Id\" , \"FuncRoleHierarchicalSelect\" . \"Name\" , \"FuncRoleHierarchicalSelect\" . \"ParentRoleId\" FROM \"FuncRoleHierarchicalSelect\" UNION ALL SELECT \"DependentUserSelect\" . \"Id\" , \"DependentUserSelect\" . \"Name\" , \"DependentUserSelect\" . \"ParentRoleId\" FROM \"DependentUserSelect\" ) AS \"AdminUnitList\" ; DependentUsersList : = 'DependentUsersList' || NestLevel ; FOR DependentUser IN DependentUsersList LOOP EXIT WHEN DependentUser = NULL ; DependentUserId = DependentUser . \"Id\" ; PERFORM \"tsp_GetAdminUnitList\" ( DependentUserId , 1 , NestLevel + 1 ) ; END LOOP ; GetGrantorSysAdminUnitList : = 'GetGrantorSysAdminUnitList' || NestLevel ; FOR GrantorSysAdminUnit IN GetGrantorSysAdminUnitList LOOP EXIT WHEN GrantorSysAdminUnit = NULL ; GrantorSysAdminUnitId = GrantorSysAdminUnit . \"Id\" ; PERFORM \"tsp_GetAdminUnitList\" ( GrantorSysAdminUnitId , 1 , NestLevel + 1 ) ; END LOOP ; IF NestLevel = 0 THEN RETURN QUERY SELECT \"QQ\" . \"Id\" , \"QQ\" . \"Name\" , \"QQ\" . \"ParentRoleId\" FROM ( SELECT DISTINCT \"AdminUnitList\" . \"Id\" , \"AdminUnitList\" . \"Name\" , \"AdminUnitList\" . \"ParentRoleId\" , \"sau\" . \"SysAdminUnitTypeValue\" FROM \"AdminUnitList\" INNER JOIN \"SysAdminUnit\" AS \"sau\" ON \"sau\" . \"Id\" = \"AdminUnitList\" . \"Id\" ) AS \"QQ\" ORDER BY \"QQ\" . \"SysAdminUnitTypeValue\" DESC ; END IF ; END ; $$ LANGUAGE plpgsql ; Example 5 (stored procedures) ​ Example Example of a stored procedure that uses exception handling and executes a custom script. MSSQL PostgreSQL -- Stored procedure that uses exception handling and executes a custom script -- MSSQL IF EXISTS ( SELECT * FROM sys . objects WHERE object_id = OBJECT_ID ( N '[dbo].[tsp_CanConvertData]' ) AND type IN ( N 'P' , N 'PC' ) ) DROP PROCEDURE [ dbo ] . [ tsp_CanConvertData ] GO CREATE PROCEDURE [ dbo ] . [ tsp_CanConvertData ] @EntitySchemaName SYSNAME , @SourceColumnName SYSNAME , @NewColumnDataType SYSNAME , @Result BIT OUT AS BEGIN SET NOCOUNT ON SET @Result = 0 DECLARE @sql NVARCHAR ( MAX ) DECLARE @unicodeCharLength INT = 2 DECLARE @dataTypeName SYSNAME DECLARE @dataTypeSize INT DECLARE @dataTypePrecision INT SELECT @dataTypeName = UPPER ( DATA_TYPE ) , @dataTypeSize = CASE WHEN CHARACTER_MAXIMUM_LENGTH IS NULL THEN NUMERIC_PRECISION ELSE CHARACTER_MAXIMUM_LENGTH END , @dataTypePrecision = ISNULL ( NUMERIC_SCALE , 0 ) FROM INFORMATION_SCHEMA . COLUMNS WHERE TABLE_NAME = @EntitySchemaName AND COLUMN_NAME = @SourceColumnName IF ( @dataTypeName IS NULL ) BEGIN RETURN END DECLARE @newDataTypeName SYSNAME DECLARE @newDataTypeSize INT DECLARE @newDataTypePrecision INT DEClARE @i INT DECLARE @newDataTypeSizeDefinition NVARCHAR ( MAX ) SET @i = CHARINDEX ( '(' , @NewColumnDataType ) IF ( @i = 0 ) BEGIN SET @newDataTypeName = @NewColumnDataType SET @newDataTypeSize = 0 SET @newDataTypePrecision = 0 END ELSE BEGIN SET @newDataTypeName = UPPER ( LTRIM ( RTRIM ( SUBSTRING ( @NewColumnDataType , 1 , @i - 1 ) ) ) ) SET @newDataTypeSizeDefinition = LTRIM ( RTRIM ( SUBSTRING ( @NewColumnDataType , @i + 1 , LEN ( @NewColumnDataType ) ) ) ) SET @i = CHARINDEX ( ')' , @newDataTypeSizeDefinition ) IF ( @i > 0 ) BEGIN SET @newDataTypeSizeDefinition = LTRIM ( RTRIM ( SUBSTRING ( @newDataTypeSizeDefinition , 1 , @i - 1 ) ) ) END SET @i = CHARINDEX ( ',' , @newDataTypeSizeDefinition ) IF ( @i > 0 ) BEGIN SET @newDataTypeSize = CAST ( LTRIM ( RTRIM ( SUBSTRING ( @newDataTypeSizeDefinition , 1 , @i - 1 ) ) ) AS INT ) SET @newDataTypePrecision = CAST ( LTRIM ( RTRIM ( SUBSTRING ( @newDataTypeSizeDefinition , @i + 1 , LEN ( @newDataTypeSizeDefinition ) ) ) ) AS INT ) END ELSE BEGIN SET @newDataTypePrecision = 0 IF ( UPPER ( @newDataTypeSizeDefinition ) = 'MAX' ) BEGIN SET @newDataTypeSize = - 1 END ELSE BEGIN SET @newDataTypeSize = CAST ( @newDataTypeSizeDefinition AS INT ) END END END DECLARE @ImplicitDataConvertTable TABLE ( SourceDataType SYSNAME , DestinationDataType SYSNAME ) INSERT INTO @ImplicitDataConvertTable SELECT 'INT' , 'INT' UNION ALL SELECT 'INT' , 'BIT' UNION ALL SELECT 'INT' , 'DECIMAL' UNION ALL SELECT 'INT' , 'VARCHAR' UNION ALL SELECT 'INT' , 'NVARCHAR' UNION ALL SELECT 'INT' , 'VARBINARY' UNION ALL SELECT 'BIT' , 'BIT' UNION ALL SELECT 'BIT' , 'INT' UNION ALL SELECT 'BIT' , 'DECIMAL' UNION ALL SELECT 'BIT' , 'VARCHAR' UNION ALL SELECT 'BIT' , 'NVARCHAR' UNION ALL SELECT 'BIT' , 'VARBINARY' UNION ALL SELECT 'DECIMAL' , 'BIT' UNION ALL SELECT 'UNIQUEIDENTIFIER' , 'UNIQUEIDENTIFIER' UNION ALL SELECT 'UNIQUEIDENTIFIER' , 'VARBINARY' UNION ALL SELECT 'VARCHAR' , 'INT' UNION ALL SELECT 'VARCHAR' , 'BIT' UNION ALL SELECT 'VARCHAR' , 'UNIQUEIDENTIFIER' UNION ALL SELECT 'DATETIME2' , 'DATETIME2' UNION ALL SELECT 'DATETIME2' , 'DATE' UNION ALL SELECT 'DATETIME2' , 'TIME' UNION ALL SELECT 'DATETIME2' , 'VARCHAR' UNION ALL SELECT 'DATE' , 'DATE' UNION ALL SELECT 'DATE' , 'DATETIME2' UNION ALL SELECT 'DATE' , 'VARCHAR' UNION ALL SELECT 'DATE' , 'NVARCHAR' UNION ALL SELECT 'TIME' , 'TIME' UNION ALL SELECT 'TIME' , 'DATETIME2' UNION ALL SELECT 'TIME' , 'VARCHAR' UNION ALL SELECT 'TIME' , 'NVARCHAR' UNION ALL SELECT 'VARBINARY' , 'INT' UNION ALL SELECT 'VARBINARY' , 'BIT' UNION ALL SELECT 'VARBINARY' , 'UNIQUEIDENTIFIER' IF EXISTS ( SELECT * FROM @ImplicitDataConvertTable WHERE SourceDataType = @dataTypeName AND DestinationDataType = @newDataTypeName ) BEGIN SET @Result = 1 RETURN END DECLARE @ImplicitDataOverflowConvertTable TABLE ( SourceDataType SYSNAME , DestinationDataType SYSNAME ) INSERT INTO @ImplicitDataOverflowConvertTable SELECT 'DECIMAL' , 'INT' UNION ALL SELECT 'DECIMAL' , 'DECIMAL' UNION ALL SELECT 'DECIMAL' , 'VARCHAR' UNION ALL SELECT 'DECIMAL' , 'NVARCHAR' UNION ALL SELECT 'DECIMAL' , 'VARBINARY' UNION ALL SELECT 'UNIQUEIDENTIFIER' , 'VARCHAR' UNION ALL SELECT 'UNIQUEIDENTIFIER' , 'NVARCHAR' UNION ALL SELECT 'VARCHAR' , 'INT' UNION ALL SELECT 'VARCHAR' , 'BIT' UNION ALL SELECT 'VARCHAR' , 'DECIMAL' UNION ALL SELECT 'VARCHAR' , 'VARCHAR' UNION ALL SELECT 'VARCHAR' , 'NVARCHAR' UNION ALL SELECT 'NVARCHAR' , 'INT' UNION ALL SELECT 'NVARCHAR' , 'BIT' UNION ALL SELECT 'NVARCHAR' , 'DECIMAL' UNION ALL SELECT 'NVARCHAR' , 'VARCHAR' UNION ALL SELECT 'NVARCHAR' , 'NVARCHAR' UNION ALL SELECT 'VARBINARY' , 'VARCHAR' UNION ALL SELECT 'VARBINARY' , 'NVARCHAR' UNION ALL SELECT 'VARBINARY' , 'VARBINARY' IF EXISTS ( SELECT * FROM @ImplicitDataOverflowConvertTable WHERE SourceDataType = @dataTypeName AND DestinationDataType = @newDataTypeName ) BEGIN SET @sql = N 'IF EXISTS(SELECT * FROM [' + @EntitySchemaName + ']) SET @Result = 0 ELSE SET @Result = 1' EXEC sp_executesql @sql , N '@Result BIT OUT' , @Result = @Result OUT IF ( @Result = 1 ) BEGIN RETURN END BEGIN TRY IF ( @dataTypeName = 'DECIMAL' AND @newDataTypeName = 'INT' ) OR ( @dataTypeName = 'DECIMAL' AND @newDataTypeName = 'VARCHAR' ) OR ( @dataTypeName = 'DECIMAL' AND @newDataTypeName = 'NVARCHAR' ) OR ( @dataTypeName = 'DECIMAL' AND @newDataTypeName = 'VARBINARY' ) OR ( @dataTypeName = 'DECIMAL' AND @newDataTypeName = 'DECIMAL' ) BEGIN DECLARE @cnt INT DECLARE @ConvertDescription NVARCHAR ( MAX ) SET @ConvertDescription = 'CONVERT(' + @NewColumnDataType + ', [' + @SourceColumnName + '])' SET @sql = N 'IF EXISTS(SELECT * FROM [' + @EntitySchemaName + \\ * '] WHERE ' + @ConvertDescription + ' = ' + @ConvertDescription + ') SET @cnt = 1 ELSE SET @cnt = 0' EXEC sp_executesql @sql , N '@cnt INT OUT' , @cnt = @cnt OUT SET @Result = 1 END ELSE BEGIN DECLARE @dl INT SET @sql = N 'SELECT @dl = MAX(DATALENGTH([' + @SourceColumnName + '])) ' + 'FROM [' + @EntitySchemaName + ']' EXEC sp_executesql @sql , N '@dl INT OUT' , @dl = @dl OUT IF ( @newDataTypeName IN ( 'VARCHAR' , 'NVARCHAR' , 'VARBINARY' ) AND @newDataTypeSize = - 1 ) BEGIN SET @Result = 1 END ELSE IF ( @dl <= @newDataTypeSize OR ( @newDataTypeName IN ( 'NVARCHAR' , 'NCHAR' ) AND ( @dl / @unicodeCharLength ) <= @newDataTypeSize ) ) BEGIN SET @Result = 1 END ELSE BEGIN SET @Result = 0 END END END TRY BEGIN CATCH SET @Result = 0 END CATCH END ELSE BEGIN SET @Result = 0 END END GO -- Stored procedure that uses exception handling and executes a custom scrip -- PostgreSQL DROP FUNCTION IF EXISTS public . \"tsp_CanConvertData\" CASCADE ; CREATE FUNCTION public . \"tsp_CanConvertData\" ( EntitySchemaName NAME , SourceColumnName NAME , NewColumnDataType NAME , CanConvert OUT BOOLEAN ) AS $BODY$ DECLARE dataTypeName NAME ; newDataTypeName NAME ; newDataTypeSize INTEGER ; countRow INTEGER ; dataLength INTEGER ; convertDescription TEXT ; unicodeCharLength INTEGER = 2 ; sqlQuery TEXT ; castQuery TEXT ; BEGIN CanConvert = FALSE ; dataTypeName = ( SELECT UPPER ( data_type ) FROM information_schema . columns WHERE table_name = EntitySchemaName AND column_name = SourceColumnName ) ; IF dataTypeName IS NULL THEN RETURN ; END IF ; SELECT \"fn_ParseDataType\" . DataTypeName , \"fn_ParseDataType\" . DataTypeSize FROM public . \"fn_ParseDataType\" ( NewColumnDataType ) INTO newDataTypeName , newDataTypeSize ; DROP TABLE IF EXISTS \"NotConvertTable\" ; CREATE TEMP TABLE \"NotConvertTable\" ( SourceDataType NAME , DestinationDataType NAME ) ; INSERT INTO \"NotConvertTable\" VALUES ( 'INTEGER' , 'UUID' ) , ( 'INTEGER' , 'TIMESTAMP WITHOUT TIME ZONE' ) , ( 'INTEGER' , 'DATE' ) , ( 'INTEGER' , 'TIME WITHOUT TIME ZONE' ) , ( 'NUMERIC' , 'UUID' ) , ( 'NUMERIC' , 'TIMESTAMP WITHOUT TIME ZONE' ) , ( 'NUMERIC' , 'DATE' ) , ( 'NUMERIC' , 'TIME WITHOUT TIME ZONE' ) , ( 'BOOLEAN' , 'UUID' ) , ( 'BOOLEAN' , 'TIMESTAMP WITHOUT TIME ZONE' ) , ( 'BOOLEAN' , 'DATE' ) , ( 'BOOLEAN' , 'TIME WITHOUT TIME ZONE' ) , ( 'UUID' , 'INTEGER' ) , ( 'UUID' , 'NUMERIC' ) , ( 'UUID' , 'BOOLEAN' ) , ( 'UUID' , 'TIMESTAMP WITHOUT TIME ZONE' ) , ( 'UUID' , 'DATE' ) , ( 'UUID' , 'TIME WITHOUT TIME ZONE' ) , ( 'TIMESTAMP WITHOUT TIME ZONE' , 'INTEGER' ) , ( 'TIMESTAMP WITHOUT TIME ZONE' , 'NUMERIC' ) , ( 'TIMESTAMP WITHOUT TIME ZONE' , 'BOOLEAN' ) , ( 'TIMESTAMP WITHOUT TIME ZONE' , 'UUID' ) , ( 'DATE' , 'INTEGER' ) , ( 'DATE' , 'NUMERIC' ) , ( 'DATE' , 'BOOLEAN' ) , ( 'DATE' , 'UUID' ) , ( 'DATE' , 'TIME WITHOUT TIME ZONE' ) , ( 'TIME WITHOUT TIME ZONE' , 'INTEGER' ) , ( 'TIME WITHOUT TIME ZONE' , 'NUMERIC' ) , ( 'TIME WITHOUT TIME ZONE' , 'BOOLEAN' ) , ( 'TIME WITHOUT TIME ZONE' , 'UUID' ) , ( 'TIME WITHOUT TIME ZONE' , 'DATE' ) ; IF EXISTS ( SELECT SourceDataType , DestinationDataType FROM \"NotConvertTable\" WHERE SourceDataType = dataTypeName AND DestinationDataType = newDataTypeName ) THEN RETURN ; END IF ; DROP TABLE IF EXISTS ImplicitDataConvertTable ; CREATE TEMP TABLE ImplicitDataConvertTable ( SourceDataType NAME , DestinationDataType NAME ) ; INSERT INTO ImplicitDataConvertTable VALUES ( 'INTEGER' , 'INTEGER' ) , ( 'INTEGER' , 'NUMERIC' ) , ( 'INTEGER' , 'BOOLEAN' ) , ( 'INTEGER' , 'CHARACTER VARYING' ) , ( 'INTEGER' , 'TEXT' ) , ( 'NUMERIC' , 'CHARACTER VARYING' ) , ( 'NUMERIC' , 'TEXT' ) , ( 'BOOLEAN' , 'INTEGER' ) , ( 'BOOLEAN' , 'BOOLEAN' ) , ( 'BOOLEAN' , 'CHARACTER VARYING' ) , ( 'BOOLEAN' , 'TEXT' ) , ( 'CHARACTER VARYING' , 'TEXT' ) , ( 'CHARACTER VARYING' , 'BYTEA' ) , ( 'TEXT' , 'TEXT' ) , ( 'TEXT' , 'BYTEA' ) , ( 'BYTEA' , 'BYTEA' ) , ( 'UUID' , 'CHARACTER VARYING' ) , ( 'UUID' , 'TEXT' ) , ( 'UUID' , 'UUID' ) , ( 'TIMESTAMP WITHOUT TIME ZONE' , 'CHARACTER VARYING' ) , ( 'TIMESTAMP WITHOUT TIME ZONE' , 'TEXT' ) , ( 'TIMESTAMP WITHOUT TIME ZONE' , 'TIMESTAMP WITHOUT TIME ZONE' ) , ( 'DATE' , 'CHARACTER VARYING' ) , ( 'DATE' , 'TEXT' ) , ( 'DATE' , 'TIMESTAMP WITHOUT TIME ZONE' ) , ( 'DATE' , 'DATE' ) , ( 'TIME WITHOUT TIME ZONE' , 'CHARACTER VARYING' ) , ( 'TIME WITHOUT TIME ZONE' , 'TEXT' ) , ( 'TIME WITHOUT TIME ZONE' , 'TIMESTAMP WITHOUT TIME ZONE' ) , ( 'TIME WITHOUT TIME ZONE' , 'TIME WITHOUT TIME ZONE' ) , ( 'TIMESTAMP WITHOUT TIME ZONE' , 'DATE' ) , ( 'TIMESTAMP WITHOUT TIME ZONE' , 'TIME WITHOUT TIME ZONE' ) , ( 'INTEGER' , 'BYTEA' ) , ( 'NUMERIC' , 'BOOLEAN' ) , ( 'NUMERIC' , 'BYTEA' ) , ( 'BOOLEAN' , 'NUMERIC' ) , ( 'BOOLEAN' , 'BYTEA' ) , ( 'UUID' , 'BYTEA' ) , ( 'TIMESTAMP WITHOUT TIME ZONE' , 'BYTEA' ) , ( 'DATE' , 'BYTEA' ) , ( 'TIME WITHOUT TIME ZONE' , 'BYTEA' ) , ( 'NUMERIC' , 'INTEGER' ) , ( 'NUMERIC' , 'NUMERIC' ) ; IF EXISTS ( SELECT SourceDataType , DestinationDataType FROM ImplicitDataConvertTable WHERE SourceDataType = dataTypeName AND DestinationDataType = newDataTypeName ) THEN CanConvert = TRUE ; RETURN ; END IF ; EXECUTE FORMAT ( 'SELECT count(*) FROM %1$I' , EntitySchemaName ) INTO countRow ; CanConvert = ( countRow = 0 ) ; IF CanConvert THEN RETURN ; END IF ; DROP TABLE IF EXISTS \"ExplicitDataConvertTable\" ; CREATE TEMP TABLE \"ExplicitDataConvertTable\" ( SourceDataType NAME , DestinationDataType NAME ) ; INSERT INTO \"ExplicitDataConvertTable\" VALUES ( 'CHARACTER VARYING' , 'INTEGER' ) , ( 'CHARACTER VARYING' , 'NUMERIC' ) , ( 'CHARACTER VARYING' , 'BOOLEAN' ) , ( 'CHARACTER VARYING' , 'UUID' ) , ( 'CHARACTER VARYING' , 'TIMESTAMP WITHOUT TIME ZONE' ) , ( 'CHARACTER VARYING' , 'DATE' ) , ( 'CHARACTER VARYING' , 'TIME WITHOUT TIME ZONE' ) , ( 'TEXT' , 'INTEGER' ) , ( 'TEXT' , 'NUMERIC' ) , ( 'TEXT' , 'BOOLEAN' ) , ( 'TEXT' , 'UUID' ) , ( 'TEXT' , 'TIMESTAMP WITHOUT TIME ZONE' ) , ( 'TEXT' , 'DATE' ) , ( 'TEXT' , 'TIME WITHOUT TIME ZONE' ) , ( 'BYTEA' , 'INTEGER' ) , ( 'BYTEA' , 'NUMERIC' ) , ( 'BYTEA' , 'BOOLEAN' ) , ( 'BYTEA' , 'UUID' ) , ( 'BYTEA' , 'TIMESTAMP WITHOUT TIME ZONE' ) , ( 'BYTEA' , 'DATE' ) , ( 'BYTEA' , 'TEXT' ) , ( 'BYTEA' , 'TIME WITHOUT TIME ZONE' ) , ( 'NUMERIC' , 'BOOLEAN' ) ; IF EXISTS ( SELECT SourceDataType , DestinationDataType FROM \"ExplicitDataConvertTable\" WHERE SourceDataType = dataTypeName AND DestinationDataType = newDataTypeName ) THEN castQuery = FORMAT ( 'CAST(%1$I%3$s AS %2$s)' , SourceColumnName , NewColumnDataType , CASE WHEN dataTypeName = 'BYTEA' THEN '::TEXT' WHEN dataTypeName = 'NUMERIC' THEN '::INTEGER' ELSE '' END ) ; sqlQuery = FORMAT ( 'SELECT COUNT(*) FROM %1$I WHERE %2$s = %2$s' , EntitySchemaName , castQuery ) ; BEGIN EXECUTE sqlQuery ; CanConvert = TRUE ; EXCEPTION WHEN OTHERS THEN CanConvert = FALSE ; END ; RETURN ; END IF ; DROP TABLE IF EXISTS \"ImplicitDataOverflowConvertTable\" ; CREATE TEMP TABLE \"ImplicitDataOverflowConvertTable\" ( SourceDataType NAME , DestinationDataType NAME ) ; INSERT INTO \"ImplicitDataOverflowConvertTable\" VALUES ( 'CHARACTER VARYING' , 'CHARACTER VARYING' ) , ( 'TEXT' , 'CHARACTER VARYING' ) , ( 'BYTEA' , 'CHARACTER VARYING' ) ; IF EXISTS ( SELECT SourceDataType , DestinationDataType FROM \"ImplicitDataOverflowConvertTable\" WHERE SourceDataType = dataTypeName AND DestinationDataType = newDataTypeName ) THEN EXECUTE FORMAT ( 'SELECT count(*) FROM %1$I' , EntitySchemaName ) INTO countRow ; CanConvert = ( countRow = 0 ) ; IF CanConvert THEN RETURN ; END IF ; BEGIN EXECUTE FORMAT ( 'SELECT MAX(PG_COLUMN_SIZE(%1$I)) FROM %2$I' , SourceColumnName , EntitySchemaName ) INTO dataLength ; IF ( dataLength <= newDataTypeSize ) THEN CanConvert = TRUE ; ELSE CanConvert = FALSE ; END IF ; EXCEPTION WHEN OTHERS THEN CanConvert = FALSE ; END ; END IF ; END ; $BODY$ LANGUAGE 'plpgsql' ; Example 6 (functions) ​ Example Example of a function. MSSQL PostgreSQL -- Function -- MSSQL IF EXISTS ( SELECT * FROM sys . objects WHERE object_id = OBJECT_ID ( N '[dbo].[fn_IsGuid]' ) AND type = N 'FN' ) DROP FUNCTION [ dbo ] . [ fn_IsGuid ] GO CREATE FUNCTION [ dbo ] . [ fn_IsGuid ] ( @ValidateValue NVARCHAR ( MAX ) ) RETURNS BIT AS BEGIN DECLARE @hasLeftBraces BIT IF @ValidateValue LIKE '{%' BEGIN SET @ValidateValue = SUBSTRING ( @ValidateValue , 2 , LEN ( @ValidateValue ) - 1 ) SET @hasLeftBraces = 1 END ELSE BEGIN SET @hasLeftBraces = 0 END DECLARE @hasRightBraces BIT IF @ValidateValue LIKE '%}' BEGIN SET @ValidateValue = SUBSTRING ( @ValidateValue , 1 , LEN ( @ValidateValue ) - 1 ) SET @hasRightBraces = 1 END ELSE BEGIN SET @hasRightBraces = 0 END DECLARE @Result BIT IF @ValidateValue LIKE '[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F]-[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F]-[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F]-[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F]-[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F]' BEGIN SET @Result = 1 END ELSE BEGIN SET @Result = 0 END IF @hasLeftBraces = @hasRightBraces BEGIN RETURN @Result END ELSE BEGIN SET @Result = 0 END RETURN @Result END GO -- Function -- PostgreSQL DROP FUNCTION IF EXISTS \"public\" . \"fn_IsGuid\" ; CREATE OR REPLACE FUNCTION public . \"fn_IsGuid\" ( ValidateValue IN VARCHAR ) RETURNS BOOLEAN AS $$ BEGIN IF ( regexp_matches ( ValidateValue , '^\\{?[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\\}?$' ) ) [ 1 ] IS NOT NULL THEN RETURN TRUE ; ELSE RETURN FALSE ; END IF ; END ; $$ LANGUAGE plpgsql ; Resources ​ Official PostgreSQL documentation Example 1 (views) Example 2 (views) Example 3 (stored procedures) Example 4 (stored procedures) Example 5 (stored procedures) Example 6 (functions) Resources",
  "markdown": "This is documentation for Creatio **8.1**.\n\nFor up-to-date documentation, see the **[latest version](/docs/8.x/dev/development-on-creatio-platform/development-tools/database-tools/postgresql-features/examples/mssql-and-postgresql-script-examples)** (8.3).\n\nVersion: 8.1\n\nOn this page\n\nLevel: intermediate\n\n## Example 1 (views)​\n\nExample\n\nExample of an SQL script that creates a view and triggers to add, modify, and delete records from the target table.\n\n  * MSSQL\n  * PostgreSQL\n\n\n    \n    \n    -- View and triggers that let you modify the target table  \n    -- MSSQL  \n    IF EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[VwSysAdminUnit]'))  \n    DROP VIEW [dbo].[VwSysAdminUnit]  \n    GO  \n    CREATE VIEW [dbo].[VwSysAdminUnit]  \n    AS  \n    SELECT [SysAdminUnit].[Id]  \n        ,[SysAdminUnit].[CreatedOn]  \n        ,[SysAdminUnit].[CreatedById]  \n        ,[SysAdminUnit].[ModifiedOn]  \n        ,[SysAdminUnit].[ModifiedById]  \n        ,[SysAdminUnit].[Name]  \n        ,[SysAdminUnit].[Description]  \n        ,[SysAdminUnit].[ParentRoleId]  \n        ,[SysAdminUnit].[ContactId]  \n        ,[SysAdminUnit].[IsDirectoryEntry]  \n        ,[TimeZone].[Id] AS [TimeZoneId]  \n        ,[SysAdminUnit].[UserPassword]  \n        ,[SysAdminUnitType].[Id] AS [SysAdminUnitTypeId]  \n        ,[SysAdminUnit].[AccountId]  \n        ,[SysAdminUnit].[Active]  \n        ,[SysAdminUnit].[LoggedIn]  \n        ,[SysAdminUnit].[SynchronizeWithLDAP]  \n        ,[SysAdminUnit].[LDAPEntry]  \n        ,[SysAdminUnit].[LDAPEntryId]  \n        ,[SysAdminUnit].[LDAPEntryDN]  \n        ,[SysAdminUnit].[SysCultureId]  \n        ,[SysAdminUnit].[ProcessListeners]  \n        ,[SysAdminUnit].[PasswordExpireDate]  \n        ,[SysAdminUnit].[HomePageId]  \n        ,[SysAdminUnit].[ConnectionType]  \n        ,[ConnectionType].[Id] AS [UserConnectionTypeId]  \n        ,[SysAdminUnit].[ForceChangePassword]  \n        ,[SysAdminUnit].[DateTimeFormatId]  \n        ,[SysAdminUnit].[Id] as [SysAdminUnitId]  \n        ,[SysAdminUnit].[SessionTimeout] as [SessionTimeout]  \n    FROM [SysAdminUnit]  \n    INNER JOIN [SysAdminUnitType] ON [SysAdminUnitType].[Value] = [SysAdminUnit].[SysAdminUnitTypeValue]  \n    LEFT JOIN [ConnectionType] AS [ConnectionType] ON [ConnectionType].[Value] = [SysAdminUnit].[ConnectionType]  \n    LEFT JOIN [TimeZone] AS [TimeZone] ON [TimeZone].[Code] = [SysAdminUnit].[TimeZoneId]  \n    GO  \n    CREATE TRIGGER [dbo].[ITR_VwSysAdminUnit_I]  \n    ON [dbo].[VwSysAdminUnit]  \n        INSTEAD OF INSERT  \n    AS  \n    BEGIN  \n    SET NOCOUNT ON;  \n    INSERT INTO [SysAdminUnit](  \n        [Id]  \n        ,[CreatedOn]  \n        ,[CreatedById]  \n        ,[ModifiedOn]  \n        ,[ModifiedById]  \n        ,[Name]  \n        ,[Description]  \n        ,[ParentRoleId]  \n        ,[ContactId]  \n        ,[IsDirectoryEntry]  \n        ,[TimeZoneId]  \n        ,[UserPassword]  \n        ,[SysAdminUnitTypeValue]  \n        ,[AccountId]  \n        ,[Active]  \n        ,[LoggedIn]  \n        ,[SynchronizeWithLDAP]  \n        ,[LDAPEntry]  \n        ,[LDAPEntryId]  \n        ,[LDAPEntryDN]  \n        ,[SysCultureId]  \n        ,[ProcessListeners]  \n        ,[PasswordExpireDate]  \n        ,[HomePageId]  \n        ,[ConnectionType]  \n        ,[ForceChangePassword]  \n        ,[DateTimeFormatId]  \n        ,[SessionTimeout])  \n    SELECT [Id]  \n        ,[CreatedOn]  \n        ,[CreatedById]  \n        ,[ModifiedOn]  \n        ,[ModifiedById]  \n        ,[Name]  \n        ,[Description]  \n        ,[ParentRoleId]  \n        ,[ContactId]  \n        ,[IsDirectoryEntry]  \n        ,(SELECT COALESCE(  \n            (SELECT [TimeZone].[Code] FROM [TimeZone]  \n                WHERE [TimeZone].[Id] = [INSERTED].[TimeZoneId]), ''))  \n        ,[UserPassword]  \n        ,ISNULL((SELECT [SysAdminUnitType].[Value] FROM [SysAdminUnitType]  \n            WHERE [SysAdminUnitType].[Id] = [INSERTED].[SysAdminUnitTypeId]), 4)  \n        ,[AccountId]  \n        ,[Active]  \n        ,ISNULL([LoggedIn], 0)  \n        ,[SynchronizeWithLDAP]  \n        ,[LDAPEntry]  \n        ,[LDAPEntryId]  \n        ,[LDAPEntryDN]  \n        ,[SysCultureId]  \n        ,[ProcessListeners]  \n        ,[PasswordExpireDate]  \n        ,[HomePageId]  \n        ,COALESCE([INSERTED].[ConnectionType],  \n            (SELECT [ConnectionType].[Value] FROM [ConnectionType]  \n            WHERE [ConnectionType].[Id] = [INSERTED].[UserConnectionTypeId]), 0)  \n        ,ISNULL([ForceChangePassword], 0)  \n        ,[DateTimeFormatId]  \n        ,[SessionTimeout]  \n    FROM [INSERTED]  \n    END  \n    GO  \n    CREATE TRIGGER [dbo].[ITR_VwSysAdminUnit_U]  \n    ON [dbo].[VwSysAdminUnit]  \n        INSTEAD OF UPDATE  \n    AS  \n    BEGIN  \n    SET NOCOUNT ON;  \n    UPDATE [SysAdminUnit]  \n    SET [SysAdminUnit].[CreatedOn] = [INSERTED].[CreatedOn]  \n        ,[SysAdminUnit].[CreatedById] = [INSERTED].[CreatedById]  \n        ,[SysAdminUnit].[ModifiedOn] =[INSERTED].[ModifiedOn]  \n        ,[SysAdminUnit].[ModifiedById] = [INSERTED].[ModifiedById]  \n        ,[SysAdminUnit].[Name] = [INSERTED].[Name]  \n        ,[SysAdminUnit].[Description] = [INSERTED].[Description]  \n        ,[SysAdminUnit].[ParentRoleId] = [INSERTED].[ParentRoleId]  \n        ,[SysAdminUnit].[ContactId] = [INSERTED].[ContactId]  \n        ,[SysAdminUnit].[IsDirectoryEntry] = [INSERTED].[IsDirectoryEntry]  \n        ,[SysAdminUnit].[TimeZoneId] =  \n            (SELECT COALESCE(  \n                (SELECT [TimeZone].[Code] FROM [TimeZone]  \n                    WHERE [TimeZone].[Id] = [INSERTED].[TimeZoneId]), ''))  \n        ,[SysAdminUnit].[UserPassword] = [INSERTED].[UserPassword]  \n        ,[SysAdminUnit].[SysAdminUnitTypeValue] =  \n            (SELECT [SysAdminUnitType].[Value] FROM [SysAdminUnitType]  \n                WHERE [SysAdminUnitType].[Id] = [INSERTED].[SysAdminUnitTypeId])  \n        ,[SysAdminUnit].[AccountId] = [INSERTED].[AccountId]  \n        ,[SysAdminUnit].[Active] = [INSERTED].[Active]  \n        ,[SysAdminUnit].[LoggedIn] = [INSERTED].[LoggedIn]  \n        ,[SysAdminUnit].[SynchronizeWithLDAP] = [INSERTED].[SynchronizeWithLDAP]  \n        ,[SysAdminUnit].[LDAPEntry] = [INSERTED].[LDAPEntry]  \n        ,[SysAdminUnit].[LDAPEntryId] = [INSERTED].[LDAPEntryId]  \n        ,[SysAdminUnit].[LDAPEntryDN] = [INSERTED].[LDAPEntryDN]  \n        ,[SysAdminUnit].[SysCultureId] = [INSERTED].[SysCultureId]  \n        ,[SysAdminUnit].[ProcessListeners] = [INSERTED].[ProcessListeners]  \n        ,[SysAdminUnit].[PasswordExpireDate] = [INSERTED].[PasswordExpireDate]  \n        ,[SysAdminUnit].[HomePageId] = [INSERTED].[HomePageId]  \n        ,[SysAdminUnit].[ConnectionType] = COALESCE([INSERTED].[ConnectionType],  \n            (SELECT [ConnectionType].[Value] FROM [ConnectionType]  \n            WHERE [ConnectionType].[Id] = [INSERTED].[UserConnectionTypeId]), 0)  \n        ,[SysAdminUnit].[ForceChangePassword] = [INSERTED].[ForceChangePassword]  \n        ,[SysAdminUnit].[DateTimeFormatId] = [INSERTED].[DateTimeFormatId]  \n        ,[SysAdminUnit].[SessionTimeout] = [INSERTED].[SessionTimeout]  \n    FROM [SysAdminUnit]  \n    INNER JOIN [INSERTED] ON [SysAdminUnit].[Id] = [INSERTED].[Id]  \n    END  \n    GO  \n    CREATE TRIGGER [dbo].[ITR_VwSysAdminUnit_D]  \n    ON [dbo].[VwSysAdminUnit]  \n        INSTEAD OF DELETE  \n    AS  \n    BEGIN  \n    SET NOCOUNT ON;  \n    DELETE FROM [SysAdminUnit]  \n    WHERE EXISTS(SELECT * FROM [DELETED] WHERE [SysAdminUnit].[Id] = [DELETED].[Id])  \n    END  \n    GO  \n    \n    \n    \n    -- View and triggers that let you modify the target table  \n    -- PostgreSQL  \n    DROP FUNCTION IF EXISTS \"public\".\"ITR_VwSysLookup_IUD_Func\" CASCADE;  \n    DROP VIEW IF EXISTS \"public\".\"VwSysLookup\";  \n      \n    CREATE VIEW \"public\".\"VwSysLookup\" AS  \n    SELECT \"SysLookup\".\"Id\"  \n        ,\"SysLookup\".\"CreatedOn\"  \n        ,\"SysLookup\".\"CreatedById\"  \n        ,\"SysLookup\".\"ModifiedOn\"  \n        ,\"SysLookup\".\"ModifiedById\"  \n        ,\"SysLookup\".\"Name\"  \n        ,\"SysLookup\".\"Description\"  \n        ,\"SysLookup\".\"SysFolderId\"  \n        ,\"SysLookup\".\"SysEntitySchemaUId\"  \n        ,\"SysLookup\".\"SysGridPageSchemaUId\"  \n        ,\"SysLookup\".\"SysEditPageSchemaUId\"  \n        ,\"VwSysSchemaInfo\".\"SysWorkspaceId\"  \n        ,\"SysLookup\".\"ProcessListeners\"  \n        ,\"SysLookup\".\"IsSystem\"  \n        ,\"SysLookup\".\"IsSimple\"  \n    FROM \"public\".\"SysLookup\"  \n    INNER JOIN \"public\".\"VwSysSchemaInfo\" ON \"SysLookup\".\"SysEntitySchemaUId\" = \"VwSysSchemaInfo\".\"UId\";  \n      \n    CREATE FUNCTION \"public\".\"ITR_VwSysLookup_IUD_Func\"() RETURNS TRIGGER AS $$  \n        BEGIN  \n            IF TG_OP = 'INSERT' THEN  \n                INSERT INTO \"public\".\"SysLookup\"(  \n                    \"Id\"  \n                    ,\"CreatedOn\"  \n                    ,\"CreatedById\"  \n                    ,\"ModifiedOn\"  \n                    ,\"ModifiedById\"  \n                    ,\"Name\"  \n                    ,\"Description\"  \n                    ,\"SysFolderId\"  \n                    ,\"SysEntitySchemaUId\"  \n                    ,\"SysGridPageSchemaUId\"  \n                    ,\"SysEditPageSchemaUId\"  \n                    ,\"ProcessListeners\"  \n                    ,\"IsSystem\"  \n                    ,\"IsSimple\")  \n                SELECT NEW.\"Id\"  \n                    ,NEW.\"CreatedOn\"  \n                    ,NEW.\"CreatedById\"  \n                    ,NEW.\"ModifiedOn\"  \n                    ,NEW.\"ModifiedById\"  \n                    ,NEW.\"Name\"  \n                    ,NEW.\"Description\"  \n                    ,NEW.\"SysFolderId\"  \n                    ,NEW.\"SysEntitySchemaUId\"  \n                    ,NEW.\"SysGridPageSchemaUId\"  \n                    ,NEW.\"SysEditPageSchemaUId\"  \n                    ,NEW.\"ProcessListeners\"  \n                    ,NEW.\"IsSystem\"  \n                    ,NEW.\"IsSimple\";  \n                RETURN NEW;  \n            ELSIF TG_OP = 'UPDATE' THEN  \n                UPDATE \"public\".\"SysLookup\"  \n                SET \"CreatedOn\" = NEW.\"CreatedOn\"  \n                    ,\"CreatedById\" = NEW.\"CreatedById\"  \n                    ,\"ModifiedOn\" = NEW.\"ModifiedOn\"  \n                    ,\"ModifiedById\" = NEW.\"ModifiedById\"  \n                    ,\"Name\" = NEW.\"Name\"  \n                    ,\"Description\" = NEW.\"Description\"  \n                    ,\"SysFolderId\" = NEW.\"SysFolderId\"  \n                    ,\"SysEntitySchemaUId\" = NEW.\"SysEntitySchemaUId\"  \n                    ,\"SysGridPageSchemaUId\" = NEW.\"SysGridPageSchemaUId\"  \n                    ,\"SysEditPageSchemaUId\" = NEW.\"SysEditPageSchemaUId\"  \n                    ,\"ProcessListeners\" = NEW.\"ProcessListeners\"  \n                    ,\"IsSystem\" = NEW.\"IsSystem\"  \n                    ,\"IsSimple\" = NEW.\"IsSimple\"  \n                WHERE \"SysLookup\".\"Id\" = NEW.\"Id\";  \n                RETURN NEW;  \n            ELSIF TG_OP = 'DELETE' THEN  \n                DELETE FROM \"public\".\"SysLookup\" WHERE OLD.\"Id\" = \"SysLookup\".\"Id\";  \n                RETURN OLD;  \n            END IF;  \n            RETURN NEW;  \n        END;  \n    $$ LANGUAGE plpgsql;  \n    CREATE TRIGGER \"ITR_VwSysLookup_IUD\"  \n        INSTEAD OF INSERT OR UPDATE OR DELETE ON \"public\".\"VwSysLookup\"  \n        FOR EACH ROW EXECUTE PROCEDURE \"public\".\"ITR_VwSysLookup_IUD_Func\"();  \n    \n\n## Example 2 (views)​\n\nExample\n\nExample of an SQL script that demonstrates how to use a RULE instead of the INSTEAD OF trigger in PostgreSQL.\n\n  * MSSQL\n  * PostgreSQL\n\n\n    \n    \n    -- Use the RULE instead of the INSTEAD OF trigger  \n    -- MSSQL  \n    IF EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[VwAdministrativeObjects]'))  \n    DROP VIEW [dbo].[VwAdministrativeObjects]  \n    GO  \n    CREATE VIEW [dbo].[VwAdministrativeObjects]  \n    AS  \n    WITH  \n    [SysSchemaAdministrationProperties] AS (  \n    SELECT [AdministrationPropertiesAll].[Id] AS [SysSchemaId],  \n        max([AdministrationPropertiesAll].[AdministratedByOperations]) AS [AdministratedByOperations],  \n        max([AdministrationPropertiesAll].[AdministratedByColumns]) AS [AdministratedByColumns],  \n        max([AdministrationPropertiesAll].[AdministratedByRecords]) AS [AdministratedByRecords],  \n        max([AdministrationPropertiesAll].[IsTrackChangesInDB]) AS [IsTrackChangesInDB]  \n    FROM (  \n        SELECT [SysSchema].[Id],  \n                (CASE WHEN EXISTS (  \n                    SELECT 1  \n                    FROM [SysSchemaProperty]  \n                    WHERE (([SysSchemaProperty].[SysSchemaId] = [SysSchema].[Id] AND [SysSchema].[ExtendParent] = 0)  \n                        OR [SysSchemaProperty].[SysSchemaId] = [DerivedSysSchema].[Id])  \n                        AND [SysSchemaProperty].[Name] = 'AdministratedByOperations'  \n                        AND [SysSchemaProperty].[Value] = 'True'  \n                        AND [SysSchemaProperty].[SysSchemaId] IS NOT NULL  \n                    )  \n                THEN 1 ELSE 0 END) AS [AdministratedByOperations],  \n                (CASE WHEN EXISTS (  \n                    SELECT 1  \n                    FROM [SysSchemaProperty]  \n                    WHERE (([SysSchemaProperty].[SysSchemaId] = [SysSchema].[Id] AND [SysSchema].[ExtendParent] = 0)  \n                        OR [SysSchemaProperty].[SysSchemaId] = [DerivedSysSchema].[Id])  \n                        AND [SysSchemaProperty].[Name] = 'AdministratedByColumns'  \n                        AND [SysSchemaProperty].[Value] = 'True'  \n                        AND [SysSchemaProperty].[SysSchemaId] IS NOT NULL  \n                    )  \n                THEN 1 ELSE 0 END) AS [AdministratedByColumns],  \n                (CASE WHEN EXISTS (  \n                    SELECT 1  \n                    FROM [SysSchemaProperty]  \n                    WHERE (([SysSchemaProperty].[SysSchemaId] = [SysSchema].[Id] AND [SysSchema].[ExtendParent] = 0)  \n                        OR [SysSchemaProperty].[SysSchemaId] = [DerivedSysSchema].[Id])  \n                        AND [SysSchemaProperty].[Name] = 'AdministratedByRecords'  \n                        AND [SysSchemaProperty].[Value] = 'True'  \n                        AND [SysSchemaProperty].[SysSchemaId] IS NOT NULL  \n                    )  \n                THEN 1 ELSE 0 END) AS [AdministratedByRecords],  \n                (CASE WHEN EXISTS (  \n                    SELECT 1  \n                    FROM [SysSchemaProperty]  \n                    WHERE (([SysSchemaProperty].[SysSchemaId] = [SysSchema].[Id] AND [SysSchema].[ExtendParent] = 0)  \n                        OR [SysSchemaProperty].[SysSchemaId] = [DerivedSysSchema].[Id])  \n                        AND [SysSchemaProperty].[Name] = 'IsTrackChangesInDB'  \n                        AND [SysSchemaProperty].[Value] = 'True'  \n                        AND [SysSchemaProperty].[SysSchemaId] IS NOT NULL  \n                    )  \n                THEN 1 ELSE 0 END) AS [IsTrackChangesInDB]  \n        FROM [SysSchema]  \n        LEFT OUTER JOIN [SysSchema] AS [DerivedSysSchema] ON ([SysSchema].[Id] = [DerivedSysSchema].[ParentId] AND [DerivedSysSchema].[ExtendParent] = 1)  \n        WHERE [SysSchema].[ManagerName] = 'EntitySchemaManager'  \n            AND [SysSchema].[ExtendParent] = 0  \n    ) AS [AdministrationPropertiesAll]  \n    GROUP BY [AdministrationPropertiesAll].[Id]  \n    )  \n    SELECT [BaseSchemas].[UId] AS [Id],  \n        [BaseSchemas].[UId],  \n        [BaseSchemas].[CreatedOn],  \n        [BaseSchemas].[CreatedById],  \n        [BaseSchemas].[ModifiedOn],  \n        [BaseSchemas].[ModifiedById],  \n        [BaseSchemas].[Name],  \n        [VwSysSchemaExtending].[TopExtendingCaption] as Caption,  \n        [BaseSchemas].[Description],  \n        (CASE WHEN EXISTS (  \n            SELECT 1  \n            FROM [SysLookup]  \n            WHERE [SysLookup].[SysEntitySchemaUId] = [BaseSchemas].[UId])  \n            THEN 1 ELSE 0 END) AS [IsLookup],  \n        (CASE WHEN EXISTS (  \n            SELECT 1 FROM [SysModule]  \n            INNER JOIN [SysModuleEntity] ON [SysModuleEntity].[Id] = [SysModule].[SysModuleEntityId]  \n            WHERE [BaseSchemas].[UId] = [SysModuleEntity].[SysEntitySchemaUId])  \n            THEN 1 ELSE 0 END) AS [IsModule],  \n        [SysSchemaAdministrationProperties].[AdministratedByOperations],  \n        [SysSchemaAdministrationProperties].[AdministratedByColumns],  \n        [SysSchemaAdministrationProperties].[AdministratedByRecords],  \n        [SysSchemaAdministrationProperties].[IsTrackChangesInDB],  \n        [SysWorkspaceId],  \n        [BaseSchemas].[ProcessListeners],  \n        (CASE WHEN EXISTS (  \n            SELECT 1  \n            FROM [SysSSPEntitySchemaAccessList]  \n            WHERE [SysSSPEntitySchemaAccessList].[EntitySchemaUId] = [BaseSchemas].[UId]  \n            )  \n            THEN 1 ELSE 0 END) AS [IsInSSPEntitySchemaAccessList]  \n    FROM  [SysSchema] as [BaseSchemas]  \n    INNER JOIN [VwSysSchemaExtending] ON BaseSchemas.[Id] = [VwSysSchemaExtending].[BaseSchemaId]  \n    INNER JOIN [SysPackage] on [BaseSchemas].[SysPackageId] = [SysPackage].[Id]  \n    INNER JOIN [SysSchemaAdministrationProperties] ON [BaseSchemas].[Id] = [SysSchemaAdministrationProperties].[SysSchemaId]  \n    GO  \n    CREATE TRIGGER [dbo].[TRVwAdministrativeObjects_IU]  \n    ON [dbo].[VwAdministrativeObjects]  \n        INSTEAD OF UPDATE  \n    AS  \n    BEGIN  \n        SET NOCOUNT ON;  \n        RETURN  \n    END  \n    GO  \n    \n    \n    \n    -- Use the RULE instead of the INSTEAD OF trigger  \n    -- PostgreSQL  \n    DROP VIEW IF EXISTS public.\"VwAdministrativeObjects\";  \n    DROP RULE IF EXISTS RU_VwAdministrativeObjects ON \"VwAdministrativeObjects\";  \n      \n    CREATE VIEW public.\"VwAdministrativeObjects\" AS  \n    WITH SysSchemaAdministrationProperties AS (  \n        SELECT AdministrationPropertiesAll.Id \"SysSchemaId\",  \n            MAX(AdministrationPropertiesAll.AdministratedByOperations) \"AdministratedByOperations\",  \n            MAX(AdministrationPropertiesAll.AdministratedByColumns) \"AdministratedByColumns\",  \n            MAX(AdministrationPropertiesAll.AdministratedByRecords) \"AdministratedByRecords\",  \n            MAX(AdministrationPropertiesAll.IsTrackChangesInDB) \"IsTrackChangesInDB\"  \n        FROM (  \n            SELECT ss.\"Id\" Id  \n                ,(CASE WHEN EXISTS (  \n                    SELECT 1  \n                    FROM \"SysSchemaProperty\" ssp  \n                    WHERE ((ssp.\"SysSchemaId\" = ss.\"Id\" AND NOT ss.\"ExtendParent\") OR ssp.\"SysSchemaId\" = DerivedSysSchema.\"Id\")  \n                        AND ssp.\"Name\" = 'AdministratedByOperations'  \n                        AND ssp.\"Value\" = 'True'  \n                        AND ssp.\"SysSchemaId\" IS NOT NULL  \n                ) THEN 1 ELSE 0 END) AdministratedByOperations  \n                ,(CASE WHEN EXISTS (  \n                    SELECT 1  \n                    FROM \"SysSchemaProperty\" ssp  \n                    WHERE ((ssp.\"SysSchemaId\" = ss.\"Id\" AND NOT ss.\"ExtendParent\") OR ssp.\"SysSchemaId\" = DerivedSysSchema.\"Id\")  \n                        AND ssp.\"Name\" = 'AdministratedByColumns'  \n                        AND ssp.\"Value\" = 'True'  \n                        AND ssp.\"SysSchemaId\" IS NOT NULL  \n                ) THEN 1 ELSE 0 END) AdministratedByColumns  \n                ,(CASE WHEN EXISTS (  \n                    SELECT 1  \n                    FROM \"SysSchemaProperty\" ssp  \n                    WHERE ((ssp.\"SysSchemaId\" = ss.\"Id\" AND NOT ss.\"ExtendParent\") OR ssp.\"SysSchemaId\" = DerivedSysSchema.\"Id\")  \n                        AND ssp.\"Name\" = 'AdministratedByRecords'  \n                        AND ssp.\"Value\" = 'True'  \n                        AND ssp.\"SysSchemaId\" IS NOT NULL  \n                ) THEN 1 ELSE 0 END) AdministratedByRecords  \n                ,(CASE WHEN EXISTS (  \n                    SELECT 1  \n                    FROM \"SysSchemaProperty\" ssp WHERE ((ssp.\"SysSchemaId\" = ss.\"Id\" AND NOT ss.\"ExtendParent\")  \n                        OR ssp.\"SysSchemaId\" = DerivedSysSchema.\"Id\")  \n                        AND ssp.\"Name\" = 'IsTrackChangesInDB'  \n                        AND ssp.\"Value\" = 'True'  \n                        AND ssp.\"SysSchemaId\" IS NOT NULL  \n                ) THEN 1 ELSE 0 END) IsTrackChangesInDB  \n            FROM \"SysSchema\" ss  \n            LEFT OUTER JOIN \"SysSchema\" DerivedSysSchema ON (ss.\"Id\" = DerivedSysSchema.\"ParentId\" AND DerivedSysSchema.\"ExtendParent\")  \n            WHERE ss.\"ManagerName\" = 'EntitySchemaManager' AND NOT ss.\"ExtendParent\"  \n        ) AdministrationPropertiesAll  \n        GROUP BY AdministrationPropertiesAll.Id  \n    )  \n    SELECT BaseSchema.\"UId\" \"Id\"  \n        ,BaseSchema.\"UId\"  \n        ,BaseSchema.\"CreatedOn\"  \n        ,BaseSchema.\"CreatedById\"  \n        ,BaseSchema.\"ModifiedOn\"  \n        ,BaseSchema.\"ModifiedById\"  \n        ,BaseSchema.\"Name\"  \n        ,public.\"VwSysSchemaExtending\".\"TopExtendingCaption\" \"Caption\"  \n        ,BaseSchema.\"Description\"  \n        ,EXISTS (  \n            SELECT 1  \n            FROM \"SysLookup\"  \n            WHERE \"SysEntitySchemaUId\" = BaseSchema.\"UId\"  \n        ) \"IsLookup\"  \n        ,EXISTS (  \n            SELECT 1  \n            FROM \"SysModule\" sm  \n            INNER JOIN \"SysModuleEntity\" sme ON sme.\"Id\" = sm.\"SysModuleEntityId\"  \n            WHERE BaseSchema.\"UId\" = sme.\"SysEntitySchemaUId\"  \n        ) \"IsModule\"  \n        ,SysSchemaAdministrationProperties.\"AdministratedByOperations\"::BOOLEAN  \n        ,SysSchemaAdministrationProperties.\"AdministratedByColumns\"::BOOLEAN  \n        ,SysSchemaAdministrationProperties.\"AdministratedByRecords\"::BOOLEAN  \n        ,SysSchemaAdministrationProperties.\"IsTrackChangesInDB\"::BOOLEAN  \n        ,\"SysWorkspaceId\"  \n        ,BaseSchema.\"ProcessListeners\"  \n        ,EXISTS (  \n            SELECT 1  \n            FROM \"SysSSPEntitySchemaAccessList\"  \n            WHERE \"EntitySchemaUId\" = BaseSchema.\"UId\"  \n        ) \"IsInSSPEntitySchemaAccessList\"  \n    FROM \"SysSchema\" BaseSchema  \n    INNER JOIN \"VwSysSchemaExtending\" ON BaseSchema.\"Id\" = \"VwSysSchemaExtending\".\"BaseSchemaId\"  \n    INNER JOIN \"SysPackage\" on BaseSchema.\"SysPackageId\" = \"SysPackage\".\"Id\"  \n    INNER JOIN SysSchemaAdministrationProperties ON BaseSchema.\"Id\" = SysSchemaAdministrationProperties.\"SysSchemaId\";  \n      \n    CREATE RULE RU_VwAdministrativeObjects AS  \n        ON UPDATE TO \"VwAdministrativeObjects\"  \n        DO INSTEAD NOTHING;  \n    \n\n## Example 3 (stored procedures)​\n\nExample\n\nExample of an SQL script that creates a stored procedure. The stored procedure uses loops, cursors, and temporary tables.\n\n  * MSSQL\n  * PostgreSQL\n\n\n    \n    \n    -- Stored procedure that uses loops, cursors, and temporary tables  \n    -- MSSQL  \n    IF NOT OBJECT_ID('[dbo].[tsp_ActualizeUserRoles]') IS NULL  \n    BEGIN  \n        DROP PROCEDURE [dbo].[tsp_ActualizeUserRoles]  \n    END  \n    GO  \n      \n    CREATE PROCEDURE dbo.tsp_ActualizeUserRoles (@UserId uniqueidentifier)  \n    AS  \n    BEGIN  \n        SET NOCOUNT ON  \n      \n        IF OBJECT_ID('tempdb..#AdminUnitListTemp') IS NOT NULL  \n        BEGIN  \n            DROP TABLE [#AdminUnitListTemp];  \n        END;  \n        CREATE TABLE [#AdminUnitListTemp] (  \n            [UserId] uniqueidentifier NOT NULL,  \n            [Id] uniqueidentifier NOT NULL,  \n            [Name] NVARCHAR(250) NOT NULL,  \n            [ParentRoleId] uniqueidentifier NULL,  \n            [Granted] BIT NULL  \n        );  \n      \n        DECLARE @GetAdminUnitList TABLE (  \n            [Id] uniqueidentifier NOT NULL,  \n            [Name] nvarchar(260) NOT NULL,  \n            [ParentRoleId] uniqueidentifier NULL  \n        );  \n        DECLARE @NewRoles TABLE ([Id] uniqueidentifier NOT NULL);  \n        DECLARE @OldUserRoles TABLE ([Id] uniqueidentifier NOT NULL);  \n      \n        DECLARE @getUserAdminUnits CURSOR;  \n        DECLARE @SysAdminUnitRoles TABLE (  \n            [Id] uniqueidentifier,  \n            [Name] nvarchar(260),  \n            [ParentRoleId] uniqueidentifier  \n        );  \n        DECLARE @ManagersBeforeActualization TABLE ([Id] uniqueidentifier NOT NULL);  \n        DECLARE @ManagersAfterActualization TABLE ([Id] uniqueidentifier NOT NULL);  \n        DECLARE @StillManagers TABLE ([Id] uniqueidentifier NOT NULL);  \n        DECLARE @NoLongerManagers TABLE ([Id] uniqueidentifier NOT NULL);  \n        DECLARE @NewManagers TABLE ([Id] uniqueidentifier NOT NULL);  \n        DECLARE @SysAdminUnitId uniqueidentifier;  \n      \n        -- Old user roles  \n        INSERT INTO @OldUserRoles  \n            SELECT DISTINCT [SysAdminUnitInRole].[SysAdminUnitRoleId] [Id]  \n            FROM [SysAdminUnitInRole]  \n            WHERE [SysAdminUnitInRole].[SysAdminUnitId] = @UserId  \n      \n        -- Old user managers  \n        INSERT INTO @ManagersBeforeActualization  \n            SELECT DISTINCT [SysUserInRole].[SysUserId] [Id]  \n            FROM [SysAdminUnitInRole]  \n            INNER JOIN [SysAdminUnit] [Roles]  \n                ON [SysAdminUnitInRole].[SysAdminUnitRoleId] = [Roles].[Id]  \n            INNER JOIN @OldUserRoles  \n                ON [Roles].[ParentRoleId] = [@OldUserRoles].[Id]  \n            INNER JOIN [SysUserInRole]  \n                ON [SysUserInRole].[SysRoleId] = [Roles].[Id]  \n            WHERE [Roles].[SysAdminUnitTypeValue] = 2  \n      \n        -- Get and insert new user roles  \n        INSERT INTO @GetAdminUnitList EXEC [tsp_GetAdminUnitList] @UserId=@UserId;  \n        INSERT INTO @NewRoles SELECT [Id] FROM @GetAdminUnitList;  \n        DELETE FROM [SysAdminUnitInRole] WHERE [SysAdminUnitId] = @UserId;  \n        INSERT INTO [SysAdminUnitInRole] ([SysAdminUnitId], [SysAdminUnitRoleId])  \n            SELECT DISTINCT @UserId, [Id] FROM @NewRoles;  \n      \n        -- User managers after actualization  \n        INSERT INTO @ManagersAfterActualization  \n            SELECT DISTINCT  \n                [SysUserInRole].[SysUserId] [Id]  \n            FROM [SysAdminUnitInRole]  \n            INNER JOIN [SysAdminUnit] [Roles]  \n                ON [SysAdminUnitInRole].[SysAdminUnitRoleId] = [Roles].[Id]  \n            INNER JOIN @NewRoles NewRoles  \n                ON [Roles].[ParentRoleId] = NewRoles.[Id]  \n            INNER JOIN [SysUserInRole]  \n                ON [SysUserInRole].[SysRoleId] = [Roles].[Id]  \n            WHERE [Roles].[SysAdminUnitTypeValue] = 2;  \n      \n        -- New (who were not but become) user managers  \n        INSERT INTO @NewManagers  \n            SELECT [Id] FROM @ManagersAfterActualization AS managersAfterActualization  \n                WHERE NOT EXISTS (  \n                    SELECT NULL  \n                    FROM @ManagersBeforeActualization AS managersBeforeActualization  \n                    WHERE managersBeforeActualization.[Id] = managersAfterActualization.[Id]  \n                );  \n      \n        -- Add all user roles to new managers and their grantee-users, if they arent already have  \n        SET @getUserAdminUnits = CURSOR FOR  \n            SELECT DISTINCT [Id] FROM (  \n                SELECT [Id] FROM @NewManagers  \n                UNION  \n                SELECT [GranteeSysAdminUnitId]  \n                FROM [SysAdminUnitGrantedRight]  \n                WHERE EXISTS (  \n                    SELECT NULL FROM @NewManagers as newManagers  \n                    WHERE [SysAdminUnitGrantedRight].[GrantorSysAdminUnitId] = newManagers.[Id]  \n                )  \n            ) Roles;  \n      \n        OPEN @getUserAdminUnits;  \n        FETCH NEXT  \n        FROM @getUserAdminUnits INTO @SysAdminUnitId;  \n        WHILE @@FETCH_STATUS = 0  \n        BEGIN  \n            INSERT INTO [SysAdminUnitInRole] ([SysAdminUnitId], [SysAdminUnitRoleId])  \n                SELECT DISTINCT @SysAdminUnitId, [Id]  \n                FROM @NewRoles AS newRoles  \n                WHERE NOT EXISTS (  \n                    SELECT 1  \n                    FROM [SysAdminUnitInRole]  \n                    WHERE [SysAdminUnitInRole].[SysAdminUnitId] = @SysAdminUnitId  \n                    AND [SysAdminUnitInRole].[SysAdminUnitRoleId] = newRoles.[Id]  \n                );  \n            FETCH NEXT FROM @getUserAdminUnits INTO @SysAdminUnitId;  \n        END;  \n        CLOSE @getUserAdminUnits;  \n        DEALLOCATE @getUserAdminUnits;  \n      \n        DECLARE @isUserLostAtLeastOneRole INT = (  \n            SELECT COUNT(*)  \n            FROM @OldUserRoles AS oldUserRoles  \n            WHERE NOT EXISTS (  \n                SELECT 1  \n                FROM @NewRoles AS newUserRoles  \n                WHERE newUserRoles.[Id] = oldUserRoles.[Id]  \n            )  \n        );  \n      \n        -- Still (who were and remained) user managers  \n        INSERT INTO @StillManagers  \n            SELECT  DISTINCT managersAfterActualization.[Id] AS [Id]  \n            FROM @ManagersAfterActualization AS managersAfterActualization  \n                JOIN @ManagersBeforeActualization AS managersBeforeActualization  \n                    ON managersAfterActualization.[Id] = managersBeforeActualization.[Id];  \n      \n        -- If user lost at least one role, we need to actualize all his still-managers.  \n        -- If not (user only gained new roles) - we just add to still-managers and their grantee-users new user roles.  \n        IF (@isUserLostAtLeastOneRole = 0)  \n        BEGIN  \n            -- Add all new user roles to his still-managers and to their grantee-users  \n            SET @getUserAdminUnits = CURSOR FOR  \n                SELECT DISTINCT [Id] FROM (  \n                    SELECT stillManagers.[Id] AS [Id]  \n                    FROM @StillManagers AS stillManagers  \n                    UNION  \n                    SELECT [GranteeSysAdminUnitId]  \n                    FROM [SysAdminUnitGrantedRight]  \n                    WHERE EXISTS (  \n                        SELECT NULL  \n                        FROM @StillManagers AS stillManagers  \n                        WHERE stillManagers.[Id] = [GrantorSysAdminUnitId]  \n                    )  \n                ) Roles;  \n      \n            OPEN @getUserAdminUnits;  \n            FETCH NEXT  \n            FROM @getUserAdminUnits INTO @SysAdminUnitId;  \n            WHILE @@FETCH_STATUS = 0  \n            BEGIN  \n                INSERT INTO [SysAdminUnitInRole] ([SysAdminUnitId], [SysAdminUnitRoleId])  \n                    SELECT DISTINCT @SysAdminUnitId, [Id]  \n                    FROM @NewRoles AS newRoles  \n                    WHERE NOT EXISTS (  \n                        SELECT 1  \n                        FROM [SysAdminUnitInRole]  \n                        WHERE [SysAdminUnitInRole].[SysAdminUnitId] = @SysAdminUnitId  \n                            AND [SysAdminUnitInRole].[SysAdminUnitRoleId] = newRoles.[Id]  \n                    );  \n                FETCH NEXT FROM @getUserAdminUnits INTO @SysAdminUnitId;  \n            END;  \n            CLOSE @getUserAdminUnits;  \n            DEALLOCATE @getUserAdminUnits;  \n        END ELSE  \n        BEGIN  \n            --Actualize all roles for still-managers  \n            SET @getUserAdminUnits = CURSOR FOR  \n                SELECT DISTINCT [Id]  \n                FROM @StillManagers  \n                UNION  \n                    SELECT [GranteeSysAdminUnitId]  \n                    FROM [SysAdminUnitGrantedRight]  \n                    WHERE EXISTS (  \n                    SELECT NULL  \n                    FROM @StillManagers AS stillManagers  \n                    WHERE stillManagers.[Id] = [GrantorSysAdminUnitId]  \n                    );  \n      \n            OPEN @getUserAdminUnits;  \n            FETCH NEXT  \n            FROM @getUserAdminUnits INTO @SysAdminUnitId;  \n            WHILE @@FETCH_STATUS = 0  \n            BEGIN  \n                DELETE FROM @SysAdminUnitRoles;  \n                INSERT INTO @SysAdminUnitRoles  \n                    EXEC [tsp_GetAdminUnitList] @UserId=@SysAdminUnitId;  \n                BEGIN TRAN;  \n                    DELETE FROM [dbo].[SysAdminUnitInRole] WHERE SysAdminUnitId = @SysAdminUnitId;  \n                    INSERT INTO [dbo].[SysAdminUnitInRole] (SysAdminUnitId, SysAdminUnitRoleId)  \n                        SELECT @SysAdminUnitId, [Id] FROM @SysAdminUnitRoles;  \n                COMMIT;  \n                FETCH NEXT  \n                    FROM @getUserAdminUnits INTO @SysAdminUnitId;  \n            END;  \n            CLOSE @getUserAdminUnits;  \n            DEALLOCATE @getUserAdminUnits;  \n        END;  \n      \n        -- No longer (who were but not remained) user managers  \n        INSERT INTO @NoLongerManagers  \n            SELECT [Id] FROM @ManagersBeforeActualization as managersBeforeActualization  \n                WHERE NOT EXISTS (  \n                    SELECT NULL  \n                    FROM @ManagersAfterActualization AS managersAfterActualization  \n                    WHERE managersAfterActualization.[Id] = managersBeforeActualization.[Id]  \n                );  \n      \n        -- Actualize roles for all noLonger-managers, his grantee-users and all grantee-users of user  \n        SET @getUserAdminUnits = CURSOR FOR  \n            SELECT DISTINCT [Id] FROM (  \n                SELECT [Id] FROM @NoLongerManagers  \n                UNION  \n                SELECT [GranteeSysAdminUnitId]  \n                FROM [SysAdminUnitGrantedRight]  \n                WHERE EXISTS (  \n                    SELECT NULL  \n                    FROM @NoLongerManagers AS noLongerManagers  \n                    WHERE noLongerManagers.[Id] = [GrantorSysAdminUnitId]  \n                )  \n                UNION ALL  \n                SELECT GranteeSysAdminUnitId  \n                FROM SysAdminUnitGrantedRight  \n                WHERE GrantorSysAdminUnitId = @UserId  \n            ) Roles;  \n      \n        OPEN @getUserAdminUnits;  \n        FETCH NEXT  \n            FROM @getUserAdminUnits INTO @SysAdminUnitId;  \n        WHILE @@FETCH_STATUS = 0  \n        BEGIN  \n            DELETE FROM @SysAdminUnitRoles;  \n            INSERT INTO @SysAdminUnitRoles  \n                EXEC [tsp_GetAdminUnitList] @UserId=@SysAdminUnitId;  \n            BEGIN TRAN;  \n                DELETE FROM [dbo].[SysAdminUnitInRole] WHERE SysAdminUnitId = @SysAdminUnitId;  \n                INSERT INTO [dbo].[SysAdminUnitInRole] (SysAdminUnitId, SysAdminUnitRoleId)  \n                    SELECT @SysAdminUnitId, [Id] FROM @SysAdminUnitRoles;  \n            COMMIT;  \n            FETCH NEXT  \n                FROM @getUserAdminUnits INTO @SysAdminUnitId;  \n        END;  \n        CLOSE @getUserAdminUnits;  \n        DEALLOCATE @getUserAdminUnits;  \n      \n        IF OBJECT_ID('tempdb..#AdminUnitListTemp') IS NOT NULL  \n        BEGIN  \n            DROP TABLE [#AdminUnitListTemp];  \n        END;  \n    END;  \n    GO  \n    \n    \n    \n    -- Stored procedure that uses loops, cursors, and temporary tables  \n    -- PostgreSQL  \n    DROP FUNCTION IF EXISTS \"tsp_ActualizeUserRoles\";  \n    CREATE FUNCTION \"tsp_ActualizeUserRoles\"(  \n        UserId UUID  \n    )  \n    RETURNS VOID  \n    AS $$  \n    DECLARE  \n        getUserNewManagers CURSOR FOR  \n            SELECT DISTINCT \"Id\" FROM (  \n                SELECT \"Id\" FROM \"NewManagers\"  \n                UNION  \n                SELECT \"GranteeSysAdminUnitId\"  \n                FROM \"SysAdminUnitGrantedRight\"  \n                WHERE EXISTS (  \n                    SELECT NULL FROM \"NewManagers\" as \"newManagers\"  \n                    WHERE \"SysAdminUnitGrantedRight\".\"GrantorSysAdminUnitId\" = \"newManagers\".\"Id\"  \n                )  \n            ) \"Roles\";  \n        lostUserRolesCount INT;  \n        getUserStillManagers CURSOR FOR  \n            SELECT DISTINCT \"stillManagers\".\"Id\" AS \"Id\"  \n            FROM \"StillManagers\" AS \"stillManagers\"  \n            UNION  \n            SELECT \"GranteeSysAdminUnitId\"  \n            FROM \"SysAdminUnitGrantedRight\"  \n            WHERE EXISTS (  \n                SELECT NULL  \n                FROM \"StillManagers\" AS \"stillManagers\"  \n                WHERE \"stillManagers\".\"Id\" = \"GrantorSysAdminUnitId\"  \n            );  \n        getUserNoLongerManagers CURSOR FOR  \n            SELECT DISTINCT \"Id\" FROM (  \n                SELECT \"Id\"  \n                FROM \"NoLongerManagers\"  \n                UNION  \n                SELECT \"GranteeSysAdminUnitId\"  \n                FROM \"SysAdminUnitGrantedRight\"  \n                WHERE EXISTS (  \n                    SELECT NULL  \n                    FROM \"NoLongerManagers\" AS \"noLongerManagers\"  \n                    WHERE \"noLongerManagers\".\"Id\" = \"GrantorSysAdminUnitId\"  \n                )  \n                UNION ALL  \n                SELECT \"GranteeSysAdminUnitId\"  \n                FROM \"SysAdminUnitGrantedRight\"  \n                WHERE \"GrantorSysAdminUnitId\" = UserId  \n            ) \"Roles\";  \n    BEGIN  \n        DROP TABLE IF EXISTS \"GetAdminUnitListTmp\";  \n        CREATE TEMP TABLE \"GetAdminUnitListTmp\" (  \n            \"Id\" UUID,  \n            \"Name\" VARCHAR(250),  \n            \"ParentRoleId\" UUID  \n        );  \n      \n        DROP TABLE IF EXISTS \"SysAdminUnitRoles\";  \n        CREATE TEMP TABLE \"SysAdminUnitRoles\" (  \n            \"Id\" UUID,  \n            \"Name\" VARCHAR(250),  \n            \"ParentRoleId\" UUID  \n        );  \n      \n        -- Old user roles  \n        DROP TABLE IF EXISTS \"OldUserRoles\";  \n        CREATE TEMP TABLE \"OldUserRoles\" (  \n            \"Id\" UUID  \n        );  \n        INSERT INTO \"OldUserRoles\"  \n            SELECT DISTINCT \"SysAdminUnitInRole\".\"SysAdminUnitRoleId\" \"Id\"  \n            FROM \"SysAdminUnitInRole\"  \n            WHERE \"SysAdminUnitInRole\".\"SysAdminUnitId\" = UserId;  \n      \n        -- Old user managers  \n        DROP TABLE IF EXISTS \"ManagersBeforeActualization\";  \n        CREATE TEMP TABLE \"ManagersBeforeActualization\" (  \n            \"Id\" UUID  \n        );  \n        INSERT INTO \"ManagersBeforeActualization\"  \n            SELECT DISTINCT \"SysUserInRole\".\"SysUserId\" \"Id\"  \n            FROM \"SysAdminUnitInRole\"  \n            INNER JOIN \"SysAdminUnit\" \"Roles\"  \n                ON \"SysAdminUnitInRole\".\"SysAdminUnitRoleId\" = \"Roles\".\"Id\"  \n            INNER JOIN \"OldUserRoles\"  \n                ON \"Roles\".\"ParentRoleId\" = \"OldUserRoles\".\"Id\"  \n            INNER JOIN \"SysUserInRole\"  \n                ON \"SysUserInRole\".\"SysRoleId\" = \"Roles\".\"Id\"  \n            WHERE \"Roles\".\"SysAdminUnitTypeValue\" = 2;  \n      \n        -- Get and insert new user roles  \n        DROP TABLE IF EXISTS \"GetAdminUnitList\";  \n        CREATE TEMP TABLE \"GetAdminUnitList\" (  \n            \"Id\" UUID,  \n            \"Name\" VARCHAR(250),  \n            \"ParentRoleId\" UUID  \n        );  \n        DROP TABLE IF EXISTS \"NewRoles\";  \n        CREATE TEMP TABLE \"NewRoles\" (  \n            \"Id\" UUID  \n        );  \n        INSERT INTO \"GetAdminUnitList\" SELECT * FROM \"tsp_GetAdminUnitList\"(UserId);  \n        INSERT INTO \"NewRoles\" SELECT \"Id\" FROM \"GetAdminUnitList\";  \n        DELETE FROM \"SysAdminUnitInRole\" WHERE \"SysAdminUnitId\" = UserId;  \n        INSERT INTO \"SysAdminUnitInRole\" (\"SysAdminUnitId\", \"SysAdminUnitRoleId\")  \n            SELECT DISTINCT UserId, \"Id\" FROM \"NewRoles\";  \n      \n        -- User managers after actualization  \n        DROP TABLE IF EXISTS \"ManagersAfterActualization\";  \n        CREATE TEMP TABLE \"ManagersAfterActualization\" (  \n            \"Id\" UUID  \n        );  \n        INSERT INTO \"ManagersAfterActualization\"  \n            SELECT DISTINCT  \n                \"SysUserInRole\".\"SysUserId\" \"Id\"  \n            FROM \"SysAdminUnitInRole\"  \n            INNER JOIN \"SysAdminUnit\" \"Roles\"  \n                ON \"SysAdminUnitInRole\".\"SysAdminUnitRoleId\" = \"Roles\".\"Id\"  \n            INNER JOIN \"NewRoles\" \"NewRoles\"  \n                ON \"Roles\".\"ParentRoleId\" = \"NewRoles\".\"Id\"  \n            INNER JOIN \"SysUserInRole\"  \n                ON \"SysUserInRole\".\"SysRoleId\" = \"Roles\".\"Id\"  \n            WHERE \"Roles\".\"SysAdminUnitTypeValue\" = 2;  \n      \n        -- New (who were not but become) user managers  \n        DROP TABLE IF EXISTS \"NewManagers\";  \n        CREATE TEMP TABLE \"NewManagers\" (  \n            \"Id\" UUID  \n        );  \n        INSERT INTO \"NewManagers\"  \n            SELECT \"Id\" FROM \"ManagersAfterActualization\" AS \"managersAfterActualization\"  \n                WHERE NOT EXISTS (  \n                    SELECT NULL  \n                    FROM \"ManagersBeforeActualization\" AS \"managersBeforeActualization\"  \n                    WHERE \"managersBeforeActualization\".\"Id\" = \"managersAfterActualization\".\"Id\"  \n                );  \n      \n        -- Add all user roles to new managers and their grantee-users, if they arent already have  \n        FOR UserNewManager IN getUserNewManagers LOOP  \n            EXIT WHEN UserNewManager = NULL;  \n            INSERT INTO \"SysAdminUnitInRole\" (\"SysAdminUnitId\", \"SysAdminUnitRoleId\")  \n                SELECT DISTINCT UserNewManager.\"Id\", \"Id\"  \n                FROM \"NewRoles\" AS \"newRoles\"  \n                WHERE NOT EXISTS (  \n                    SELECT 1  \n                    FROM \"SysAdminUnitInRole\"  \n                    WHERE \"SysAdminUnitInRole\".\"SysAdminUnitId\" = UserNewManager.\"Id\"  \n                    AND \"SysAdminUnitInRole\".\"SysAdminUnitRoleId\" = \"newRoles\".\"Id\"  \n                );  \n        END LOOP;  \n      \n        SELECT COUNT(*) INTO lostUserRolesCount  \n        FROM \"OldUserRoles\" AS \"oldUserRoles\"  \n        WHERE NOT EXISTS (  \n            SELECT 1  \n            FROM \"NewRoles\" AS \"newUserRoles\"  \n            WHERE \"newUserRoles\".\"Id\" = \"oldUserRoles\".\"Id\"  \n        );  \n      \n        -- Still (who were and remained) user managers  \n        DROP TABLE IF EXISTS \"StillManagers\";  \n        CREATE TEMP TABLE \"StillManagers\" (  \n            \"Id\" UUID  \n        );  \n        INSERT INTO \"StillManagers\"  \n            SELECT DISTINCT \"managersAfterActualization\".\"Id\" AS \"Id\"  \n            FROM \"ManagersAfterActualization\" AS \"managersAfterActualization\"  \n                JOIN \"ManagersBeforeActualization\" AS \"managersBeforeActualization\"  \n                    ON \"managersAfterActualization\".\"Id\" = \"managersBeforeActualization\".\"Id\";  \n      \n        -- If user lost at least one role, we need to actualize all his still-managers.  \n        -- If not (user only gained new roles) - we just add to still-managers and their grantee-users new user roles.  \n        IF lostUserRolesCount = 0 THEN  \n      \n            -- Add all new user roles to his still-managers and to their grantee-users  \n            FOR UserStillManager IN getUserStillManagers LOOP  \n                EXIT WHEN UserStillManager = NULL;  \n                INSERT INTO \"SysAdminUnitInRole\" (\"SysAdminUnitId\", \"SysAdminUnitRoleId\")  \n                    SELECT DISTINCT UserStillManager.\"Id\", \"Id\"  \n                    FROM \"NewRoles\" AS \"newRoles\"  \n                    WHERE NOT EXISTS (  \n                        SELECT 1  \n                        FROM \"SysAdminUnitInRole\"  \n                        WHERE \"SysAdminUnitInRole\".\"SysAdminUnitId\" = UserStillManager.\"Id\"  \n                            AND \"SysAdminUnitInRole\".\"SysAdminUnitRoleId\" = \"newRoles\".\"Id\"  \n                    );  \n            END LOOP;  \n        ELSE  \n      \n            --Actualize all roles for still-managers  \n            FOR UserStillManager IN getUserStillManagers LOOP  \n                EXIT WHEN UserStillManager = NULL;  \n                DELETE FROM \"SysAdminUnitRoles\";  \n                INSERT INTO \"SysAdminUnitRoles\"  \n                    SELECT * FROM \"tsp_GetAdminUnitList\"(UserStillManager.\"Id\");  \n                    DELETE FROM \"SysAdminUnitInRole\" WHERE \"SysAdminUnitId\" = UserStillManager.\"Id\";  \n                    INSERT INTO \"SysAdminUnitInRole\" (\"SysAdminUnitId\", \"SysAdminUnitRoleId\")  \n                        SELECT UserStillManager.\"Id\", \"Id\" FROM \"SysAdminUnitRoles\";  \n            END LOOP;  \n        END IF;  \n      \n        -- No longer (who were but not remained) user managers  \n        DROP TABLE IF EXISTS \"NoLongerManagers\";  \n        CREATE TEMP TABLE \"NoLongerManagers\" (  \n            \"Id\" UUID  \n        );  \n        INSERT INTO \"NoLongerManagers\"  \n            SELECT \"Id\" FROM \"ManagersBeforeActualization\" AS \"managersBeforeActualization\"  \n                WHERE NOT EXISTS (  \n                    SELECT NULL  \n                    FROM \"ManagersAfterActualization\" AS \"managersAfterActualization\"  \n                    WHERE \"managersAfterActualization\".\"Id\" = \"managersBeforeActualization\".\"Id\"  \n                );  \n      \n      \n        -- Actualize roles for all noLonger-managers, his grantee-users and all grantee-users of user  \n        FOR UserNoLongerManager IN getUserNoLongerManagers LOOP  \n            EXIT WHEN UserNoLongerManager = NULL;  \n            DELETE FROM \"SysAdminUnitRoles\";  \n            INSERT INTO \"SysAdminUnitRoles\"  \n                SELECT * FROM \"tsp_GetAdminUnitList\"(UserNoLongerManager.\"Id\");  \n                DELETE FROM \"SysAdminUnitInRole\"  \n                    WHERE \"SysAdminUnitId\" = UserNoLongerManager.\"Id\";  \n                INSERT INTO \"SysAdminUnitInRole\" (\"SysAdminUnitId\", \"SysAdminUnitRoleId\")  \n                    SELECT UserNoLongerManager.\"Id\", \"Id\" FROM \"SysAdminUnitRoles\";  \n        END LOOP;  \n      \n        DROP TABLE IF EXISTS \"GetAdminUnitListTmp\";  \n    END;  \n    $$ LANGUAGE plpgsql;  \n    \n\n## Example 4 (stored procedures)​\n\nExample\n\nExample of a recursive stored procedure that returns a table and uses `PERFORM`.\n\n  * MSSQL\n  * PostgreSQL\n\n\n    \n    \n    -- Recursive stored procedure that returns a table and uses PERFORM:  \n    -- MSSQL  \n    IF NOT OBJECT_ID('[dbo].[tsp_GetAdminUnitList]') IS NULL  \n    BEGIN  \n        DROP PROCEDURE [dbo].[tsp_GetAdminUnitList];  \n    END;  \n    GO  \n      \n    CREATE PROCEDURE dbo.tsp_GetAdminUnitList (  \n        @UserId uniqueidentifier, @Granted BIT = 0  \n    )  \n    AS  \n    BEGIN  \n        SET NOCOUNT ON;  \n      \n        DECLARE @StartNestedLevel INT;  \n      \n        IF object_id('tempdb..#AdminUnitList') IS NULL  \n        BEGIN  \n            CREATE TABLE [#AdminUnitList]  \n            (  \n                [Id] uniqueidentifier NOT NULL,  \n                [Name] NVARCHAR(250) NULL,  \n                [ParentRoleId] uniqueidentifier NULL,  \n                [Granted] BIT NULL,  \n                Level INT NOT NULL  \n            );  \n            SET @StartNestedLevel = @@NESTLEVEL;  \n        END;  \n      \n        DECLARE @ConnectionType INT = (SELECT [ConnectionType] FROM SysAdminUnit WHERE [Id] = @UserId);  \n      \n        -- #AdminUnitListTemp should be created in tsp_ActualizeUserRoles or in tsp_ActualizeAdminUnitInRole  \n        DECLARE @IsAdminUnitListTempExists BIT = OBJECT_ID('tempdb..#AdminUnitListTemp');  \n      \n        IF (@IsAdminUnitListTempExists IS NULL)  \n        BEGIN  \n            WITH  \n            [MainSelect] AS (  \n                SELECT  \n                    [Id] [Id],  \n                    [Name] [Name],  \n                    [ParentRoleId] [ParentRoleId]  \n                FROM  \n                    [dbo].[SysAdminUnit]  \n                WHERE  \n                    ([SysAdminUnitTypeValue] <= 4 OR [SysAdminUnitTypeValue] = 6)  \n                AND [ConnectionType] = @ConnectionType  \n                UNION ALL  \n                SELECT  \n                    [Id] [Id],  \n                    [Name] [Name],  \n                    [ParentRoleId] [ParentRoleId]  \n                FROM  \n                    [dbo].[SysAdminUnit]  \n                WHERE  \n                    [Id] = @UserId),  \n            [ChiefUnitsSelect] AS (  \n                (  \n                    SELECT  \n                        [Chief].[ParentRoleId] [Id]  \n                    FROM  \n                        [dbo].[SysUserInRole] userInRole  \n                        INNER JOIN [dbo].[SysAdminUnit] sau ON (sau.[Id] = userInRole.[SysUserId])  \n                        INNER JOIN [dbo].[SysAdminUnit] [Chief] ON ([Chief].[Id] = userInRole.[SysRoleId])  \n                    WHERE  \n                        sau.[Id] = @UserId AND NOT (userInRole.[SysRoleId] IS NULL) AND [Chief].[SysAdminUnitTypeValue] = 2  \n                    UNION ALL  \n                    SELECT  \n                        [Chief].[ParentRoleId] [Id]  \n                    FROM  \n                        [dbo].[SysAdminUnit] [Chief]  \n                    WHERE  \n                        [Chief].[Id] = @UserId AND [Chief].[SysAdminUnitTypeValue] = 2  \n                )  \n                UNION ALL  \n                SELECT  \n                    sau.[Id]  \n                FROM  \n                    [ChiefUnitsSelect]  \n                    INNER JOIN [dbo].[SysAdminUnit] sau ON (sau.[ParentRoleId] = [ChiefUnitsSelect].[Id])  \n                WHERE  \n                    sau.[SysAdminUnitTypeValue] < 4  \n            ),  \n            [HierarchicalSelect] AS (  \n                SELECT  \n                    [Id],  \n                    [Name],  \n                    [ParentRoleId],  \n                    0 [Level]  \n                FROM  \n                    [MainSelect] [SelectStartLevel]  \n                WHERE  \n                    [Id] IN (  \n                        SELECT  \n                            userInRole.[SysRoleId]  \n                        FROM  \n                            [dbo].[SysUserInRole] userInRole  \n                            INNER JOIN [dbo].[SysAdminUnit] sau ON (sau.[Id] = userInRole.[SysUserId])  \n                        WHERE  \n                            sau.[Id] = @UserId  \n                        UNION ALL  \n                        SELECT [Id] FROM [ChiefUnitsSelect]  \n                        UNION ALL  \n                        SELECT  \n                            [Id]  \n                        FROM  \n                            [dbo].[SysAdminUnit]  \n                        WHERE  \n                            ([ParentRoleId] IS NULL OR [Id] = @UserId)  \n                            AND [SysAdminUnitTypeValue] < 4  \n                        UNION ALL  \n                        SELECT  \n                            [FuncRoleId]  \n                        FROM  \n                            [dbo].[SysFuncRoleInOrgRole]  \n                        WHERE  \n                            [SysFuncRoleInOrgRole].[OrgRoleId] = @UserId  \n                        )  \n                UNION ALL  \n                SELECT  \n                    [SelectPriorLevel].[Id],  \n                    [SelectPriorLevel].[Name],  \n                    [SelectPriorLevel].[ParentRoleId],  \n                    [Level] + 1 level  \n                FROM  \n                    [MainSelect] [SelectPriorLevel]  \n                    INNER JOIN [HierarchicalSelect] hierSelect ON (hierSelect.[ParentRoleId] = [SelectPriorLevel].[Id])  \n            ),  \n            [FuncRoleHierarchicalSelect] AS (  \n                SELECT  \n                    [Id],  \n                    [Name],  \n                    [ParentRoleId],  \n                    0 [Level]  \n                FROM  \n                    [MainSelect] [StartLevel]  \n                WHERE EXISTS (  \n                    SELECT NULL  \n                    FROM [dbo].[SysFuncRoleInOrgRole] funcRoleInOrgRole  \n                        INNER JOIN [HierarchicalSelect] hierSelect ON funcRoleInOrgRole.[OrgRoleId] = hierSelect.[Id]  \n                    WHERE funcRoleInOrgRole.[FuncRoleId] = [StartLevel].[Id]  \n                )  \n                UNION ALL  \n                SELECT  \n                    [PriorLevel].[Id],  \n                    [PriorLevel].[Name],  \n                    [PriorLevel].[ParentRoleId],  \n                    [Level] + 1 level  \n                FROM  \n                    [MainSelect] [PriorLevel]  \n                    INNER JOIN [FuncRoleHierarchicalSelect] funcRoleHierSelect ON (funcRoleHierSelect.[ParentRoleId] = [PriorLevel].[Id])  \n            ),  \n            [DependentUserSelect] AS (  \n                SELECT  \n                    mainSelect.[Id] [Id],  \n                    mainSelect.[Name] [Name],  \n                    mainSelect.[ParentRoleId] [ParentRoleId],  \n                    0 [Level]  \n                FROM  \n                    [MainSelect] mainSelect  \n                INNER JOIN [SysUserInRole] userInRole  \n                    ON mainSelect.[Id] = userInRole.[SysUserId]  \n                INNER JOIN [ChiefUnitsSelect] [AllUnits]  \n                    ON [AllUnits].[Id] = userInRole.[SysRoleId]  \n                WHERE  \n                    NOT EXISTS (  \n                            SELECT  \n                                [UserUnits].[Id]  \n                            FROM [ChiefUnitsSelect] [UserUnits]  \n                            INNER JOIN [SysUserInRole] [UserInRole]  \n                                ON [UserUnits].[Id] = [UserInRole].[SysRoleId]  \n                            INNER JOIN [SysAdminUnit] sau  \n                                ON sau.[Id] = [UserUnits].[Id]  \n                            WHERE sau.[SysAdminUnitTypeValue] = 2  \n                                AND [UserInRole].[SysUserId] = @UserId  \n                                AND [UserUnits].[Id] = [AllUnits].[Id])  \n            )  \n            INSERT INTO [#AdminUnitList] ([Id], [Name], [ParentRoleId], [Granted], [Level])  \n            SELECT DISTINCT  \n                [Id],  \n                [Name],  \n                [ParentRoleId],  \n                @Granted,  \n                @@NESTLEVEL  \n            FROM  \n                (  \n                    SELECT  \n                        [Id],  \n                        [Name],  \n                        [ParentRoleId]  \n                    FROM  \n                        [HierarchicalSelect]  \n                    UNION ALL  \n                    SELECT  \n                        [Id],  \n                        [Name],  \n                        [ParentRoleId]  \n                    FROM  \n                        [dbo].[SysAdminUnit]  \n                    WHERE  \n                        [Id] = @UserId  \n                UNION ALL  \n                    SELECT  \n                        [Id],  \n                        [Name],  \n                        [ParentRoleId]  \n                    FROM  \n                        [FuncRoleHierarchicalSelect]  \n                UNION ALL  \n                    SELECT  \n                        [Id],  \n                        [Name],  \n                        [ParentRoleId]  \n                    FROM  \n                [DependentUserSelect]  \n            ) [AdminUnitList];  \n        END ELSE  \n        BEGIN  \n            DECLARE @alreadyGotRolesForThisUser bit = 0;  \n      \n            IF (@IsAdminUnitListTempExists = 1)  \n            BEGIN  \n                SET @alreadyGotRolesForThisUser = (SELECT CAST( CASE WHEN EXISTS(SELECT 1 FROM [#AdminUnitListTemp]  \n                        WHERE [UserId] = @UserId  \n                        )  \n                        THEN 1  \n                        ELSE 0  \n                    END  \n                AS BIT));  \n            END;  \n      \n            IF (@alreadyGotRolesForThisUser = 1)  \n            BEGIN  \n                INSERT INTO [#AdminUnitList] ([Id], [Name], [ParentRoleId], [Granted], [Level])  \n                    SELECT DISTINCT  \n                        [Id],  \n                        [Name],  \n                        [ParentRoleId],  \n                        @Granted,  \n                        @@NESTLEVEL  \n                    FROM [#AdminUnitListTemp] WHERE UserId = @UserId;  \n            END ELSE  \n            BEGIN  \n                WITH  \n                [MainSelect] AS (  \n                    SELECT  \n                        [Id] [Id],  \n                        [Name] [Name],  \n                        [ParentRoleId] [ParentRoleId]  \n                    FROM  \n                        [dbo].[SysAdminUnit]  \n                    WHERE  \n                        ([SysAdminUnitTypeValue] <= 4 OR [SysAdminUnitTypeValue] = 6)  \n                    AND [ConnectionType] = @ConnectionType  \n                    UNION ALL  \n                    SELECT  \n                        [Id] [Id],  \n                        [Name] [Name],  \n                        [ParentRoleId] [ParentRoleId]  \n                    FROM  \n                        [dbo].[SysAdminUnit]  \n                    WHERE  \n                        [Id] = @UserId),  \n                [ChiefUnitsSelect] AS (  \n                    (  \n                        SELECT  \n                            [Chief].[ParentRoleId] [Id]  \n                        FROM  \n                            [dbo].[SysUserInRole] sysUserInRole  \n                            INNER JOIN [dbo].[SysAdminUnit] sau ON (sau.[Id] = sysUserInRole.[SysUserId])  \n                            INNER JOIN [dbo].[SysAdminUnit] [Chief] ON ([Chief].[Id] = sysUserInRole.[SysRoleId])  \n                        WHERE  \n                            sau.[Id] = @UserId AND NOT (sysUserInRole.[SysRoleId] IS NULL) AND [Chief].[SysAdminUnitTypeValue] = 2  \n                        UNION ALL  \n                        SELECT  \n                            [Chief].[ParentRoleId] [Id]  \n                        FROM  \n                            [dbo].[SysAdminUnit] [Chief]  \n                        WHERE  \n                            [Chief].[Id] = @UserId AND [Chief].[SysAdminUnitTypeValue] = 2  \n                    )  \n                    UNION ALL  \n                    SELECT  \n                        sau.[Id]  \n                    FROM  \n                        [ChiefUnitsSelect] ChiefUnitsSelect  \n                        INNER JOIN [dbo].[SysAdminUnit] sau ON (sau.[ParentRoleId] = [ChiefUnitsSelect].[Id])  \n                    WHERE  \n                        sau.[SysAdminUnitTypeValue] < 4  \n                ),  \n                [HierarchicalSelect] AS (  \n                    SELECT  \n                        [Id],  \n                        [Name],  \n                        [ParentRoleId],  \n                        0 [Level]  \n                    FROM  \n                        [MainSelect] [SelectStartLevel]  \n                    WHERE EXISTS (  \n                        SELECT NULL  \n                        FROM (  \n                            SELECT [SysUserInRole].[SysRoleId] AS RoleId  \n                            FROM [dbo].[SysUserInRole]  \n                                INNER JOIN [dbo].[SysAdminUnit] ON ([SysAdminUnit].[Id] = [SysUserInRole].[SysUserId])  \n                            WHERE [SysAdminUnit].[Id] = @UserId  \n      \n                            UNION ALL  \n      \n                            SELECT [Id] AS RoleId  \n                            FROM [ChiefUnitsSelect]  \n      \n                            UNION ALL  \n      \n                            SELECT [Id] AS RoleId  \n                            FROM [dbo].[SysAdminUnit]  \n                            WHERE ([ParentRoleId] IS NULL OR [Id] = @UserId)  \n                                AND [SysAdminUnitTypeValue] < 4  \n      \n                            UNION ALL  \n      \n                            SELECT [FuncRoleId] AS RoleId  \n                            FROM [dbo].[SysFuncRoleInOrgRole]  \n                            WHERE [SysFuncRoleInOrgRole].[OrgRoleId] = @UserId  \n                        ) AS Roles  \n                        WHERE Roles.RoleId = [SelectStartLevel].[Id]  \n      \n                    )  \n                    UNION ALL  \n                    SELECT  \n                        [SelectPriorLevel].[Id],  \n                        [SelectPriorLevel].[Name],  \n                        [SelectPriorLevel].[ParentRoleId],  \n                        [Level] + 1 level  \n                    FROM  \n                        [MainSelect] [SelectPriorLevel]  \n                        INNER JOIN [HierarchicalSelect] hierSelect ON (hierSelect.[ParentRoleId] = [SelectPriorLevel].[Id])  \n                ),  \n                [FuncRoleHierarchicalSelect] AS (  \n                    SELECT  \n                        [Id],  \n                        [Name],  \n                        [ParentRoleId],  \n                        0 [Level]  \n                    FROM  \n                        [MainSelect] [StartLevel]  \n                    WHERE EXISTS (  \n                        SELECT NULL  \n                        FROM [dbo].[SysFuncRoleInOrgRole] funcRoleInOrgRole  \n                            INNER JOIN [HierarchicalSelect] hierSelect ON funcRoleInOrgRole.[OrgRoleId] = hierSelect.[Id]  \n                        WHERE funcRoleInOrgRole.[FuncRoleId] = [StartLevel].[Id]  \n                    )  \n                    UNION ALL  \n                    SELECT  \n                        [PriorLevel].[Id],  \n                        [PriorLevel].[Name],  \n                        [PriorLevel].[ParentRoleId],  \n                        [Level] + 1  \n                    FROM  \n                        [MainSelect] [PriorLevel]  \n                        INNER JOIN [FuncRoleHierarchicalSelect] funcRolesHierSelect ON (funcRolesHierSelect.[ParentRoleId] = [PriorLevel].[Id])  \n                ),  \n                [DependentUserSelect] AS (  \n                    SELECT  \n                        [MainSelect].[Id] [Id],  \n                        [MainSelect].[Name] [Name],  \n                        [MainSelect].[ParentRoleId] [ParentRoleId],  \n                        0 [Level]  \n                    FROM  \n                        [MainSelect]  \n                    INNER JOIN [SysUserInRole] sysUserInRole  \n                        ON [MainSelect].[Id] = sysUserInRole.[SysUserId]  \n                    INNER JOIN [ChiefUnitsSelect] [AllUnits]  \n                        ON [AllUnits].[Id] = sysUserInRole.[SysRoleId]  \n                    WHERE  \n                        NOT EXISTS (  \n                                SELECT  \n                                    [UserUnits].[Id]  \n                                FROM [ChiefUnitsSelect] [UserUnits]  \n                                INNER JOIN [SysUserInRole] [UserInRole]  \n                                    ON [UserUnits].[Id] = [UserInRole].[SysRoleId]  \n                                INNER JOIN [SysAdminUnit] sau  \n                                    ON sau.[Id] = [UserUnits].[Id]  \n                                WHERE sau.[SysAdminUnitTypeValue] = 2  \n                                    AND [UserInRole].[SysUserId] = @UserId  \n                                    AND [UserUnits].[Id] = [AllUnits].[Id])  \n                )  \n                INSERT INTO #AdminUnitListTemp ([UserId], [Id], [Name], [ParentRoleId], [Granted])  \n                SELECT DISTINCT  \n                    @UserId,  \n                    [Id],  \n                    [Name],  \n                    [ParentRoleId],  \n                    @Granted  \n                FROM  \n                    (  \n                        SELECT  \n                            [Id],  \n                            [Name],  \n                            [ParentRoleId]  \n                        FROM  \n                            [HierarchicalSelect]  \n                        UNION ALL  \n                        SELECT  \n                            [Id],  \n                            [Name],  \n                            [ParentRoleId]  \n                        FROM  \n                            [dbo].[SysAdminUnit]  \n                        WHERE  \n                            [Id] = @UserId  \n                    UNION ALL  \n                        SELECT  \n                            [Id],  \n                            [Name],  \n                            [ParentRoleId]  \n                        FROM  \n                            [FuncRoleHierarchicalSelect]  \n                    UNION ALL  \n                        SELECT  \n                            [Id],  \n                            [Name],  \n                            [ParentRoleId]  \n                        FROM  \n                    [DependentUserSelect]  \n                    ) [AdminUnitList];  \n      \n                INSERT INTO [#AdminUnitList] ([Id], [Name], [ParentRoleId], [Granted], [Level])  \n                SELECT DISTINCT  \n                    [Id],  \n                    [Name],  \n                    [ParentRoleId],  \n                    @Granted,  \n                    @@NESTLEVEL  \n                FROM [#AdminUnitListTemp] WHERE UserId = @UserId;  \n            END;  \n        END;  \n      \n        DECLARE @DependentUserId uniqueidentifier;  \n        DECLARE @DependentUsersList CURSOR;  \n        SET @DependentUsersList = CURSOR FOR  \n            SELECT  \n                [#AdminUnitList].[Id]  \n            FROM  \n                [#AdminUnitList]  \n            INNER JOIN [SysAdminUnit] ON [#AdminUnitList].[Id] = [SysAdminUnit].[Id]  \n            WHERE  \n                [SysAdminUnit].[SysAdminUnitTypeValue] = 4 AND [#AdminUnitList].[Id] <> @UserId  \n                AND [#AdminUnitList].[Granted] <> 1 AND [#AdminUnitList].[Level] >= @@NESTLEVEL;  \n        OPEN @DependentUsersList;  \n        FETCH NEXT  \n        FROM @DependentUsersList INTO @DependentUserId;  \n        WHILE @@FETCH_STATUS = 0  \n        BEGIN  \n            EXEC [tsp_GetAdminUnitList] @UserId=@DependentUserId, @Granted=1;  \n        FETCH NEXT  \n        FROM @DependentUsersList INTO @DependentUserId;  \n        END;  \n        CLOSE @DependentUsersList;  \n        DEALLOCATE @DependentUsersList;  \n      \n        DECLARE @GrantorSysAdminUnitId uniqueidentifier;  \n        DECLARE @getGrantorSysAdminUnitList CURSOR;  \n        SET @getGrantorSysAdminUnitList = CURSOR FOR  \n            SELECT  \n                [GrantorSysAdminUnitId]  \n            FROM  \n                [dbo].[SysAdminUnitGrantedRight]  \n            WHERE  \n                [GranteeSysAdminUnitId] = @UserId  \n                AND NOT EXISTS(SELECT * FROM [#AdminUnitList] WHERE [Id] = @UserId AND [Granted] = 1 AND [Level] < @@NESTLEVEL);  \n        OPEN @getGrantorSysAdminUnitList;  \n        FETCH NEXT  \n        FROM @getGrantorSysAdminUnitList INTO @GrantorSysAdminUnitId;  \n        WHILE @@FETCH_STATUS = 0  \n        BEGIN  \n            EXEC [tsp_GetAdminUnitList] @UserId=@GrantorSysAdminUnitId, @Granted=1;  \n        FETCH NEXT  \n        FROM @getGrantorSysAdminUnitList INTO @GrantorSysAdminUnitId;  \n        END;  \n        CLOSE @getGrantorSysAdminUnitList;  \n        DEALLOCATE @getGrantorSysAdminUnitList;  \n      \n        IF @@NESTLEVEL = @StartNestedLevel  \n        BEGIN  \n            WITH QQ ([Id], [Name], [ParentRoleId], SysAdminUnitTypeValue) as (  \n                SELECT DISTINCT adminUnitList.[Id],  \n                    adminUnitList.[Name],  \n                    adminUnitList.[ParentRoleId],  \n                    sau.SysAdminUnitTypeValue  \n                FROM [#AdminUnitList] adminUnitList  \n                INNER JOIN SysAdminUnit sau on sau.Id = adminUnitList.[Id]  \n            )  \n            SELECT [Id], [Name], [ParentRoleId] FROM QQ  \n            ORDER BY SysAdminUnitTypeValue DESC;  \n        END;  \n    END;  \n    GO  \n    \n    \n    \n    -- Recursive stored procedure that returns a table and uses PERFORM:  \n    -- PostgreSQL  \n    DROP FUNCTION IF EXISTS \"tsp_GetAdminUnitList\";  \n    CREATE FUNCTION \"tsp_GetAdminUnitList\"(  \n        UserId UUID,  \n        IsGranted BOOLEAN = FALSE,  \n        NestLevel INT = 0  \n    )  \n    RETURNS TABLE (  \n        \"Id\" UUID,  \n        \"Name\" VARCHAR(250),  \n        \"ParentRoleId\" UUID  \n    )  \n    AS $$  \n    DECLARE  \n        ConnectionType INT;  \n        IsAdminUnitListTempExists BOOLEAN = FALSE;  \n        DependentUserId UUID;  \n        DependentUsersList CURSOR FOR  \n            SELECT  \n                \"AdminUnitList\".\"Id\"  \n            FROM  \n                \"AdminUnitList\"  \n            INNER JOIN \"SysAdminUnit\" ON \"AdminUnitList\".\"Id\" = \"SysAdminUnit\".\"Id\"  \n            WHERE  \n                \"SysAdminUnit\".\"SysAdminUnitTypeValue\" = 4  \n                AND \"AdminUnitList\".\"Id\" <> UserId  \n                AND \"AdminUnitList\".\"Granted\" = FALSE  \n                AND \"AdminUnitList\".\"Level\" >= NestLevel;  \n        GrantorSysAdminUnitId UUID;  \n        GetGrantorSysAdminUnitList CURSOR FOR  \n            SELECT  \n                \"GrantorSysAdminUnitId\" AS \"Id\"  \n            FROM  \n                \"SysAdminUnitGrantedRight\"  \n            WHERE  \n                \"GranteeSysAdminUnitId\" = UserId  \n                AND NOT EXISTS (  \n                    SELECT *  \n                    FROM \"AdminUnitList\"  \n                    WHERE \"AdminUnitList\".\"Id\" = UserId  \n                        AND \"AdminUnitList\".\"Granted\" = TRUE  \n                        AND \"AdminUnitList\".\"Level\" < NestLevel  \n                );  \n        ParentRoleId UUID = NULL;  \n    BEGIN  \n      \n        IF NestLevel = 0 THEN  \n            CREATE TEMPORARY TABLE IF NOT EXISTS \"AdminUnitList\" (  \n                \"Id\" UUID,  \n                \"Name\" VARCHAR(250),  \n                \"ParentRoleId\" UUID,  \n                \"Granted\" BOOLEAN,  \n                \"Level\" INT  \n            );  \n            TRUNCATE TABLE \"AdminUnitList\";  \n        END IF;  \n      \n        SELECT \"ConnectionType\" INTO ConnectionType FROM \"SysAdminUnit\" WHERE \"SysAdminUnit\".\"Id\" = UserId;  \n      \n        WITH RECURSIVE \"MainSelect\" AS (  \n            SELECT  \n                \"SysAdminUnit\".\"Id\" \"Id\",  \n                \"SysAdminUnit\".\"Name\" \"Name\",  \n                \"SysAdminUnit\".\"ParentRoleId\" \"ParentRoleId\"  \n            FROM  \n                \"SysAdminUnit\"  \n            WHERE  \n                (\"SysAdminUnitTypeValue\" <= 4 OR \"SysAdminUnitTypeValue\" = 6)  \n            AND \"ConnectionType\" = ConnectionType  \n            UNION ALL  \n            SELECT  \n                \"SysAdminUnit\".\"Id\" \"Id\",  \n                \"SysAdminUnit\".\"Name\" \"Name\",  \n                \"SysAdminUnit\".\"ParentRoleId\" \"ParentRoleId\"  \n            FROM  \n                \"SysAdminUnit\"  \n            WHERE  \n                \"SysAdminUnit\".\"Id\" = UserId),  \n            \"ChiefUnitsSelect\" AS (  \n                SELECT  \n                    \"chief\".\"ParentRoleId\" \"Id\"  \n                FROM  \n                    \"SysUserInRole\" AS \"userInRole\"  \n                    INNER JOIN \"SysAdminUnit\" AS \"sau\" ON (\"sau\".\"Id\" = \"userInRole\".\"SysUserId\")  \n                    INNER JOIN \"SysAdminUnit\" AS \"chief\" ON (\"chief\".\"Id\" = \"userInRole\".\"SysRoleId\")  \n                WHERE  \n                    \"sau\".\"Id\" = UserId  \n                    AND \"userInRole\".\"SysRoleId\" IS NOT NULL  \n                    AND \"chief\".\"SysAdminUnitTypeValue\" = 2  \n                UNION ALL  \n                SELECT  \n                    \"chief\".\"ParentRoleId\" \"Id\"  \n                FROM  \n                    \"SysAdminUnit\" \"chief\"  \n                WHERE  \n                    \"chief\".\"Id\" = UserId AND \"chief\".\"SysAdminUnitTypeValue\" = 2  \n                UNION ALL  \n                SELECT  \n                    \"sau\".\"Id\"  \n                FROM  \n                    \"ChiefUnitsSelect\"  \n                    INNER JOIN \"SysAdminUnit\" \"sau\" ON (\"sau\".\"ParentRoleId\" = \"ChiefUnitsSelect\".\"Id\")  \n                WHERE  \n                    \"sau\".\"SysAdminUnitTypeValue\" < 4  \n            ),  \n            \"HierarchicalSelect\" AS (  \n                SELECT  \n                    \"SelectStartLevel\".\"Id\",  \n                    \"SelectStartLevel\".\"Name\",  \n                    \"SelectStartLevel\".\"ParentRoleId\",  \n                    0 \"Level\"  \n                FROM  \n                    \"MainSelect\" \"SelectStartLevel\"  \n                WHERE  \n                    \"SelectStartLevel\".\"Id\" IN (  \n                        SELECT  \n                            \"userInRole\".\"SysRoleId\"  \n                        FROM  \n                            \"SysUserInRole\" AS \"userInRole\"  \n                            INNER JOIN \"SysAdminUnit\" AS \"sau\" ON (\"sau\".\"Id\" = \"userInRole\".\"SysUserId\")  \n                        WHERE  \n                            \"sau\".\"Id\" = UserId  \n                        UNION ALL  \n                        SELECT \"ChiefUnitsSelect\".\"Id\"  \n                        FROM \"ChiefUnitsSelect\"  \n                        UNION ALL  \n                        SELECT  \n                            \"SysAdminUnit\".\"Id\"  \n                        FROM  \n                            \"SysAdminUnit\"  \n                        WHERE  \n                            (\"SysAdminUnit\".\"ParentRoleId\" IS NULL OR \"SysAdminUnit\".\"Id\" = UserId)  \n                            AND \"SysAdminUnitTypeValue\" < 4  \n                        UNION ALL  \n                        SELECT  \n                            \"FuncRoleId\"  \n                        FROM  \n                            \"SysFuncRoleInOrgRole\"  \n                        WHERE  \n                            \"SysFuncRoleInOrgRole\".\"OrgRoleId\" = UserId  \n                        )  \n                UNION ALL  \n                SELECT  \n                    \"SelectPriorLevel\".\"Id\",  \n                    \"SelectPriorLevel\".\"Name\",  \n                    \"SelectPriorLevel\".\"ParentRoleId\",  \n                    \"Level\" + 1 \"level\"  \n                FROM  \n                    \"MainSelect\" \"SelectPriorLevel\"  \n                    INNER JOIN \"HierarchicalSelect\" AS \"hierSelect\" ON (\"hierSelect\".\"ParentRoleId\" = \"SelectPriorLevel\".\"Id\")  \n            ),  \n            \"FuncRoleHierarchicalSelect\" AS (  \n                SELECT  \n                    \"StartLevel\".\"Id\",  \n                    \"StartLevel\".\"Name\",  \n                    \"StartLevel\".\"ParentRoleId\",  \n                    0 \"Level\"  \n                FROM  \n                    \"MainSelect\" \"StartLevel\"  \n                WHERE EXISTS (  \n                    SELECT NULL  \n                    FROM \"SysFuncRoleInOrgRole\" AS \"funcRoleInOrgRole\"  \n                        INNER JOIN \"HierarchicalSelect\" AS \"hierSelect\" ON \"funcRoleInOrgRole\".\"OrgRoleId\" = \"hierSelect\".\"Id\"  \n                    WHERE \"funcRoleInOrgRole\".\"FuncRoleId\" = \"StartLevel\".\"Id\"  \n                )  \n                UNION ALL  \n                SELECT  \n                    \"PriorLevel\".\"Id\",  \n                    \"PriorLevel\".\"Name\",  \n                    \"PriorLevel\".\"ParentRoleId\",  \n                    \"Level\" + 1 \"level\"  \n                FROM  \n                    \"MainSelect\" \"PriorLevel\"  \n                    INNER JOIN \"FuncRoleHierarchicalSelect\" AS \"funcRoleHierSelect\" ON (\"funcRoleHierSelect\".\"ParentRoleId\" = \"PriorLevel\".\"Id\")  \n            ),  \n            \"DependentUserSelect\" AS (  \n                SELECT  \n                    \"mainSelect\".\"Id\" \"Id\",  \n                    \"mainSelect\".\"Name\" \"Name\",  \n                    \"mainSelect\".\"ParentRoleId\" \"ParentRoleId\",  \n                    0 \"Level\"  \n                FROM  \n                    \"MainSelect\" AS \"mainSelect\"  \n                INNER JOIN \"SysUserInRole\" AS \"userInRole\"  \n                    ON \"mainSelect\".\"Id\" = \"userInRole\".\"SysUserId\"  \n                INNER JOIN \"ChiefUnitsSelect\" AS \"AllUnits\"  \n                    ON \"AllUnits\".\"Id\" = \"userInRole\".\"SysRoleId\"  \n                WHERE  \n                    NOT EXISTS (  \n                            SELECT  \n                                \"UserUnits\".\"Id\"  \n                            FROM \"ChiefUnitsSelect\" AS \"UserUnits\"  \n                            INNER JOIN \"SysUserInRole\" AS \"UserInRole\"  \n                                ON \"UserUnits\".\"Id\" = \"UserInRole\".\"SysRoleId\"  \n                            INNER JOIN \"SysAdminUnit\" AS \"sau\"  \n                                ON \"sau\".\"Id\" = \"UserUnits\".\"Id\"  \n                            WHERE \"sau\".\"SysAdminUnitTypeValue\" = 2  \n                                AND \"UserInRole\".\"SysUserId\" = UserId  \n                                AND \"UserUnits\".\"Id\" = \"AllUnits\".\"Id\")  \n            )  \n            INSERT INTO \"AdminUnitList\" (\"Id\", \"Name\", \"ParentRoleId\", \"Granted\", \"Level\")  \n            SELECT DISTINCT  \n                \"AdminUnitList\".\"Id\",  \n                \"AdminUnitList\".\"Name\",  \n                \"AdminUnitList\".\"ParentRoleId\",  \n                IsGranted,  \n                NestLevel  \n            FROM (  \n                SELECT  \n                    \"HierarchicalSelect\".\"Id\",  \n                    \"HierarchicalSelect\".\"Name\",  \n                    \"HierarchicalSelect\".\"ParentRoleId\"  \n                FROM \"HierarchicalSelect\"  \n                UNION ALL  \n                SELECT  \n                    \"SysAdminUnit\".\"Id\",  \n                    \"SysAdminUnit\".\"Name\",  \n                    \"SysAdminUnit\".\"ParentRoleId\"  \n                FROM \"SysAdminUnit\"  \n                WHERE  \n                    \"SysAdminUnit\".\"Id\" = UserId  \n                UNION ALL  \n                SELECT  \n                    \"FuncRoleHierarchicalSelect\".\"Id\",  \n                    \"FuncRoleHierarchicalSelect\".\"Name\",  \n                    \"FuncRoleHierarchicalSelect\".\"ParentRoleId\"  \n                FROM \"FuncRoleHierarchicalSelect\"  \n                UNION ALL  \n                SELECT  \n                    \"DependentUserSelect\".\"Id\",  \n                    \"DependentUserSelect\".\"Name\",  \n                    \"DependentUserSelect\".\"ParentRoleId\"  \n                FROM \"DependentUserSelect\"  \n            ) AS \"AdminUnitList\";  \n      \n        DependentUsersList := 'DependentUsersList' || NestLevel ;  \n        FOR DependentUser IN DependentUsersList LOOP  \n            EXIT WHEN DependentUser = NULL;  \n            DependentUserId = DependentUser.\"Id\";  \n            PERFORM \"tsp_GetAdminUnitList\"(DependentUserId, 1, NestLevel + 1);  \n        END LOOP;  \n      \n        GetGrantorSysAdminUnitList := 'GetGrantorSysAdminUnitList' || NestLevel ;  \n        FOR GrantorSysAdminUnit IN GetGrantorSysAdminUnitList LOOP  \n            EXIT WHEN GrantorSysAdminUnit = NULL;  \n            GrantorSysAdminUnitId = GrantorSysAdminUnit.\"Id\";  \n            PERFORM \"tsp_GetAdminUnitList\"(GrantorSysAdminUnitId, 1, NestLevel + 1);  \n        END LOOP;  \n      \n        IF NestLevel = 0 THEN  \n            RETURN QUERY  \n            SELECT \"QQ\".\"Id\",  \n                    \"QQ\".\"Name\",  \n                    \"QQ\".\"ParentRoleId\"  \n            FROM (  \n                SELECT DISTINCT  \n                    \"AdminUnitList\".\"Id\",  \n                    \"AdminUnitList\".\"Name\",  \n                    \"AdminUnitList\".\"ParentRoleId\",  \n                    \"sau\".\"SysAdminUnitTypeValue\"  \n                FROM \"AdminUnitList\"  \n                INNER JOIN \"SysAdminUnit\" AS \"sau\" ON \"sau\".\"Id\" = \"AdminUnitList\".\"Id\") AS \"QQ\"  \n            ORDER BY \"QQ\".\"SysAdminUnitTypeValue\" DESC;  \n        END IF;  \n      \n    END;  \n    $$ LANGUAGE plpgsql;  \n    \n\n## Example 5 (stored procedures)​\n\nExample\n\nExample of a stored procedure that uses exception handling and executes a custom script.\n\n  * MSSQL\n  * PostgreSQL\n\n\n    \n    \n    -- Stored procedure that uses exception handling and executes a custom script  \n    -- MSSQL  \n    IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[tsp_CanConvertData]') AND type IN (N'P', N'PC'))  \n    DROP PROCEDURE [dbo].[tsp_CanConvertData]  \n    GO  \n    CREATE PROCEDURE [dbo].[tsp_CanConvertData]  \n        @EntitySchemaName SYSNAME,  \n        @SourceColumnName SYSNAME,  \n        @NewColumnDataType SYSNAME,  \n        @Result BIT OUT  \n    AS  \n    BEGIN  \n        SET NOCOUNT ON  \n      \n        SET @Result = 0  \n      \n        DECLARE @sql NVARCHAR(MAX)  \n        DECLARE @unicodeCharLength INT = 2  \n        DECLARE @dataTypeName SYSNAME  \n        DECLARE @dataTypeSize INT  \n        DECLARE @dataTypePrecision INT  \n      \n        SELECT  \n            @dataTypeName = UPPER(DATA_TYPE),  \n            @dataTypeSize =  \n            CASE  \n                WHEN CHARACTER_MAXIMUM_LENGTH IS NULL THEN NUMERIC_PRECISION  \n                ELSE CHARACTER_MAXIMUM_LENGTH  \n            END,  \n            @dataTypePrecision = ISNULL(NUMERIC_SCALE, 0)  \n        FROM INFORMATION_SCHEMA.COLUMNS  \n        WHERE TABLE_NAME = @EntitySchemaName  \n        AND COLUMN_NAME = @SourceColumnName  \n      \n        IF (@dataTypeName IS NULL)  \n        BEGIN  \n            RETURN  \n        END  \n      \n        DECLARE @newDataTypeName SYSNAME  \n        DECLARE @newDataTypeSize INT  \n        DECLARE @newDataTypePrecision INT  \n        DEClARE @i INT  \n        DECLARE @newDataTypeSizeDefinition NVARCHAR(MAX)  \n      \n        SET @i = CHARINDEX('(', @NewColumnDataType)  \n        IF (@i = 0)  \n        BEGIN  \n            SET @newDataTypeName = @NewColumnDataType  \n            SET @newDataTypeSize = 0  \n            SET @newDataTypePrecision = 0  \n        END ELSE  \n        BEGIN  \n            SET @newDataTypeName = UPPER(LTRIM(RTRIM(SUBSTRING(@NewColumnDataType, 1, @i - 1))))  \n            SET @newDataTypeSizeDefinition = LTRIM(RTRIM(SUBSTRING(@NewColumnDataType, @i + 1,  \n                LEN(@NewColumnDataType))))  \n            SET @i = CHARINDEX(')', @newDataTypeSizeDefinition)  \n            IF (@i > 0)  \n            BEGIN  \n                SET @newDataTypeSizeDefinition = LTRIM(RTRIM(SUBSTRING(@newDataTypeSizeDefinition, 1, @i - 1)))  \n            END  \n            SET @i = CHARINDEX(',', @newDataTypeSizeDefinition)  \n            IF (@i > 0)  \n            BEGIN  \n                SET @newDataTypeSize = CAST(LTRIM(RTRIM(SUBSTRING(@newDataTypeSizeDefinition, 1, @i - 1))) AS INT)  \n                SET @newDataTypePrecision = CAST(LTRIM(RTRIM(SUBSTRING(@newDataTypeSizeDefinition, @i + 1,  \n                    LEN(@newDataTypeSizeDefinition)))) AS INT)  \n            END ELSE  \n            BEGIN  \n                SET @newDataTypePrecision = 0  \n                IF (UPPER(@newDataTypeSizeDefinition) = 'MAX')  \n                BEGIN  \n                    SET @newDataTypeSize = -1  \n                END ELSE  \n                BEGIN  \n                    SET @newDataTypeSize = CAST(@newDataTypeSizeDefinition AS INT)  \n                END  \n            END  \n        END  \n      \n        DECLARE @ImplicitDataConvertTable TABLE (  \n            SourceDataType SYSNAME,  \n            DestinationDataType SYSNAME  \n        )  \n        INSERT INTO @ImplicitDataConvertTable  \n        SELECT 'INT', 'INT'  \n        UNION ALL  \n        SELECT 'INT', 'BIT'  \n        UNION ALL  \n        SELECT 'INT', 'DECIMAL'  \n        UNION ALL  \n        SELECT 'INT', 'VARCHAR'  \n        UNION ALL  \n        SELECT 'INT', 'NVARCHAR'  \n        UNION ALL  \n        SELECT 'INT', 'VARBINARY'  \n        UNION ALL  \n        SELECT 'BIT', 'BIT'  \n        UNION ALL  \n        SELECT 'BIT', 'INT'  \n        UNION ALL  \n        SELECT 'BIT', 'DECIMAL'  \n        UNION ALL  \n        SELECT 'BIT', 'VARCHAR'  \n        UNION ALL  \n        SELECT 'BIT', 'NVARCHAR'  \n        UNION ALL  \n        SELECT 'BIT', 'VARBINARY'  \n        UNION ALL  \n        SELECT 'DECIMAL', 'BIT'  \n        UNION ALL  \n        SELECT 'UNIQUEIDENTIFIER', 'UNIQUEIDENTIFIER'  \n        UNION ALL  \n        SELECT 'UNIQUEIDENTIFIER', 'VARBINARY'  \n        UNION ALL  \n        SELECT 'VARCHAR', 'INT'  \n        UNION ALL  \n        SELECT 'VARCHAR', 'BIT'  \n        UNION ALL  \n        SELECT 'VARCHAR', 'UNIQUEIDENTIFIER'  \n        UNION ALL  \n        SELECT 'DATETIME2', 'DATETIME2'  \n        UNION ALL  \n        SELECT 'DATETIME2', 'DATE'  \n        UNION ALL  \n        SELECT 'DATETIME2', 'TIME'  \n        UNION ALL  \n        SELECT 'DATETIME2', 'VARCHAR'  \n        UNION ALL  \n        SELECT 'DATE', 'DATE'  \n        UNION ALL  \n        SELECT 'DATE', 'DATETIME2'  \n        UNION ALL  \n        SELECT 'DATE', 'VARCHAR'  \n        UNION ALL  \n        SELECT 'DATE', 'NVARCHAR'  \n        UNION ALL  \n        SELECT 'TIME', 'TIME'  \n        UNION ALL  \n        SELECT 'TIME', 'DATETIME2'  \n        UNION ALL  \n        SELECT 'TIME', 'VARCHAR'  \n        UNION ALL  \n        SELECT 'TIME', 'NVARCHAR'  \n        UNION ALL  \n        SELECT 'VARBINARY', 'INT'  \n        UNION ALL  \n        SELECT 'VARBINARY', 'BIT'  \n        UNION ALL  \n        SELECT 'VARBINARY', 'UNIQUEIDENTIFIER'  \n      \n        IF EXISTS(SELECT * FROM @ImplicitDataConvertTable  \n            WHERE SourceDataType = @dataTypeName AND DestinationDataType = @newDataTypeName)  \n        BEGIN  \n            SET @Result = 1  \n            RETURN  \n        END  \n      \n        DECLARE @ImplicitDataOverflowConvertTable TABLE (  \n            SourceDataType SYSNAME,  \n            DestinationDataType SYSNAME  \n        )  \n        INSERT INTO @ImplicitDataOverflowConvertTable  \n        SELECT 'DECIMAL', 'INT'  \n        UNION ALL  \n        SELECT 'DECIMAL', 'DECIMAL'  \n        UNION ALL  \n        SELECT 'DECIMAL', 'VARCHAR'  \n        UNION ALL  \n        SELECT 'DECIMAL', 'NVARCHAR'  \n        UNION ALL  \n        SELECT 'DECIMAL', 'VARBINARY'  \n        UNION ALL  \n        SELECT 'UNIQUEIDENTIFIER', 'VARCHAR'  \n        UNION ALL  \n        SELECT 'UNIQUEIDENTIFIER', 'NVARCHAR'  \n        UNION ALL  \n        SELECT 'VARCHAR', 'INT'  \n        UNION ALL  \n        SELECT 'VARCHAR', 'BIT'  \n        UNION ALL  \n        SELECT 'VARCHAR', 'DECIMAL'  \n        UNION ALL  \n        SELECT 'VARCHAR', 'VARCHAR'  \n        UNION ALL  \n        SELECT 'VARCHAR', 'NVARCHAR'  \n        UNION ALL  \n        SELECT 'NVARCHAR', 'INT'  \n        UNION ALL  \n        SELECT 'NVARCHAR', 'BIT'  \n        UNION ALL  \n        SELECT 'NVARCHAR', 'DECIMAL'  \n        UNION ALL  \n        SELECT 'NVARCHAR', 'VARCHAR'  \n        UNION ALL  \n        SELECT 'NVARCHAR', 'NVARCHAR'  \n        UNION ALL  \n        SELECT 'VARBINARY', 'VARCHAR'  \n        UNION ALL  \n        SELECT 'VARBINARY', 'NVARCHAR'  \n        UNION ALL  \n        SELECT 'VARBINARY', 'VARBINARY'  \n      \n        IF EXISTS(SELECT * FROM @ImplicitDataOverflowConvertTable  \n            WHERE SourceDataType = @dataTypeName AND DestinationDataType = @newDataTypeName)  \n        BEGIN  \n            SET @sql = N'IF EXISTS(SELECT * FROM [' + @EntitySchemaName + ']) SET @Result = 0 ELSE SET @Result = 1'  \n            EXEC sp_executesql @sql, N'@Result BIT OUT', @Result = @Result OUT  \n      \n            IF (@Result = 1)  \n            BEGIN  \n                RETURN  \n            END  \n            BEGIN TRY  \n                IF (@dataTypeName = 'DECIMAL' AND @newDataTypeName = 'INT') OR  \n                    (@dataTypeName = 'DECIMAL' AND @newDataTypeName = 'VARCHAR') OR  \n                    (@dataTypeName = 'DECIMAL' AND @newDataTypeName = 'NVARCHAR') OR  \n                    (@dataTypeName = 'DECIMAL' AND @newDataTypeName = 'VARBINARY') OR  \n                    (@dataTypeName = 'DECIMAL' AND @newDataTypeName = 'DECIMAL')  \n                BEGIN  \n                    DECLARE @cnt INT  \n                    DECLARE @ConvertDescription NVARCHAR(MAX)  \n                    SET @ConvertDescription = 'CONVERT(' + @NewColumnDataType +', [' + @SourceColumnName+ '])'  \n                    SET @sql = N'IF EXISTS(SELECT * FROM [' + @EntitySchemaName +\\*'] WHERE ' +  \n                    @ConvertDescription + ' = ' + @ConvertDescription + ') SET @cnt = 1 ELSE SET @cnt = 0'  \n                    EXEC sp_executesql @sql, N'@cnt INT OUT', @cnt = @cnt OUT  \n                    SET @Result = 1  \n                END ELSE  \n                BEGIN  \n                    DECLARE @dl INT  \n                    SET @sql = N'SELECT @dl = MAX(DATALENGTH([' + @SourceColumnName + '])) ' +  \n                    'FROM [' + @EntitySchemaName + ']'  \n                    EXEC sp_executesql @sql, N'@dl INT OUT', @dl = @dl OUT  \n                    IF (@newDataTypeName IN ('VARCHAR', 'NVARCHAR', 'VARBINARY') AND @newDataTypeSize = -1)  \n                    BEGIN  \n                        SET @Result = 1  \n                    END ELSE  \n                    IF (@dl <= @newDataTypeSize OR (  \n                        @newDataTypeName IN ('NVARCHAR', 'NCHAR') AND (@dl / @unicodeCharLength) <= @newDataTypeSize))  \n                    BEGIN  \n                        SET @Result = 1  \n                    END ELSE  \n                    BEGIN  \n                        SET @Result = 0  \n                    END  \n                END  \n            END TRY  \n            BEGIN CATCH  \n                SET @Result = 0  \n            END CATCH  \n        END ELSE  \n        BEGIN  \n            SET @Result = 0  \n        END  \n    END  \n    GO  \n    \n    \n    \n    -- Stored procedure that uses exception handling and executes a custom scrip  \n    -- PostgreSQL  \n    DROP FUNCTION IF EXISTS public.\"tsp_CanConvertData\" CASCADE;  \n    CREATE FUNCTION public.\"tsp_CanConvertData\"(  \n        EntitySchemaName NAME,  \n        SourceColumnName NAME,  \n        NewColumnDataType NAME,  \n        CanConvert OUT BOOLEAN)  \n    AS $BODY$  \n    DECLARE  \n        dataTypeName NAME;  \n        newDataTypeName NAME;  \n        newDataTypeSize INTEGER;  \n        countRow INTEGER;  \n        dataLength INTEGER;  \n        convertDescription TEXT;  \n        unicodeCharLength INTEGER = 2;  \n        sqlQuery TEXT;  \n        castQuery TEXT;  \n    BEGIN  \n        CanConvert = FALSE;  \n        dataTypeName = (  \n            SELECT UPPER(data_type) FROM information_schema.columns  \n            WHERE table_name = EntitySchemaName AND column_name = SourceColumnName);  \n        IF dataTypeName IS NULL THEN  \n            RETURN;  \n        END IF;  \n      \n        SELECT \"fn_ParseDataType\".DataTypeName, \"fn_ParseDataType\".DataTypeSize  \n        FROM public.\"fn_ParseDataType\"(NewColumnDataType)  \n        INTO newDataTypeName, newDataTypeSize;  \n      \n        DROP TABLE IF EXISTS \"NotConvertTable\";  \n        CREATE TEMP TABLE \"NotConvertTable\" (  \n            SourceDataType NAME,  \n            DestinationDataType NAME  \n        );  \n        INSERT INTO \"NotConvertTable\" VALUES  \n            ('INTEGER', 'UUID'),  \n            ('INTEGER', 'TIMESTAMP WITHOUT TIME ZONE'),  \n            ('INTEGER', 'DATE'),  \n            ('INTEGER', 'TIME WITHOUT TIME ZONE'),  \n            ('NUMERIC', 'UUID'),  \n            ('NUMERIC', 'TIMESTAMP WITHOUT TIME ZONE'),  \n            ('NUMERIC', 'DATE'),  \n            ('NUMERIC', 'TIME WITHOUT TIME ZONE'),  \n            ('BOOLEAN', 'UUID'),  \n            ('BOOLEAN', 'TIMESTAMP WITHOUT TIME ZONE'),  \n            ('BOOLEAN', 'DATE'),  \n            ('BOOLEAN', 'TIME WITHOUT TIME ZONE'),  \n            ('UUID', 'INTEGER'),  \n            ('UUID', 'NUMERIC'),  \n            ('UUID', 'BOOLEAN'),  \n            ('UUID', 'TIMESTAMP WITHOUT TIME ZONE'),  \n            ('UUID', 'DATE'),  \n            ('UUID', 'TIME WITHOUT TIME ZONE'),  \n            ('TIMESTAMP WITHOUT TIME ZONE', 'INTEGER'),  \n            ('TIMESTAMP WITHOUT TIME ZONE', 'NUMERIC'),  \n            ('TIMESTAMP WITHOUT TIME ZONE', 'BOOLEAN'),  \n            ('TIMESTAMP WITHOUT TIME ZONE', 'UUID'),  \n            ('DATE', 'INTEGER'),  \n            ('DATE', 'NUMERIC'),  \n            ('DATE', 'BOOLEAN'),  \n            ('DATE', 'UUID'),  \n            ('DATE', 'TIME WITHOUT TIME ZONE'),  \n            ('TIME WITHOUT TIME ZONE', 'INTEGER'),  \n            ('TIME WITHOUT TIME ZONE', 'NUMERIC'),  \n            ('TIME WITHOUT TIME ZONE', 'BOOLEAN'),  \n            ('TIME WITHOUT TIME ZONE', 'UUID'),  \n            ('TIME WITHOUT TIME ZONE', 'DATE');  \n        IF EXISTS(SELECT SourceDataType, DestinationDataType FROM \"NotConvertTable\"  \n            WHERE SourceDataType = dataTypeName AND DestinationDataType = newDataTypeName) THEN  \n            RETURN;  \n        END IF;  \n      \n        DROP TABLE IF EXISTS ImplicitDataConvertTable;  \n        CREATE TEMP TABLE ImplicitDataConvertTable (  \n            SourceDataType NAME,  \n            DestinationDataType NAME  \n        );  \n        INSERT INTO ImplicitDataConvertTable VALUES  \n            ('INTEGER', 'INTEGER'),  \n            ('INTEGER', 'NUMERIC'),  \n            ('INTEGER', 'BOOLEAN'),  \n            ('INTEGER', 'CHARACTER VARYING'),  \n            ('INTEGER', 'TEXT'),  \n            ('NUMERIC', 'CHARACTER VARYING'),  \n            ('NUMERIC', 'TEXT'),  \n            ('BOOLEAN', 'INTEGER'),  \n            ('BOOLEAN', 'BOOLEAN'),  \n            ('BOOLEAN', 'CHARACTER VARYING'),  \n            ('BOOLEAN', 'TEXT'),  \n            ('CHARACTER VARYING', 'TEXT'),  \n            ('CHARACTER VARYING', 'BYTEA'),  \n            ('TEXT', 'TEXT'),  \n            ('TEXT', 'BYTEA'),  \n            ('BYTEA', 'BYTEA'),  \n            ('UUID', 'CHARACTER VARYING'),  \n            ('UUID', 'TEXT'),  \n            ('UUID', 'UUID'),  \n            ('TIMESTAMP WITHOUT TIME ZONE', 'CHARACTER VARYING'),  \n            ('TIMESTAMP WITHOUT TIME ZONE', 'TEXT'),  \n            ('TIMESTAMP WITHOUT TIME ZONE', 'TIMESTAMP WITHOUT TIME ZONE'),  \n            ('DATE', 'CHARACTER VARYING'),  \n            ('DATE', 'TEXT'),  \n            ('DATE', 'TIMESTAMP WITHOUT TIME ZONE'),  \n            ('DATE', 'DATE'),  \n            ('TIME WITHOUT TIME ZONE', 'CHARACTER VARYING'),  \n            ('TIME WITHOUT TIME ZONE', 'TEXT'),  \n            ('TIME WITHOUT TIME ZONE', 'TIMESTAMP WITHOUT TIME ZONE'),  \n            ('TIME WITHOUT TIME ZONE', 'TIME WITHOUT TIME ZONE'),  \n            ('TIMESTAMP WITHOUT TIME ZONE', 'DATE'),  \n            ('TIMESTAMP WITHOUT TIME ZONE', 'TIME WITHOUT TIME ZONE'),  \n            ('INTEGER', 'BYTEA'),  \n            ('NUMERIC', 'BOOLEAN'),  \n            ('NUMERIC', 'BYTEA'),  \n            ('BOOLEAN', 'NUMERIC'),  \n            ('BOOLEAN', 'BYTEA'),  \n            ('UUID', 'BYTEA'),  \n            ('TIMESTAMP WITHOUT TIME ZONE', 'BYTEA'),  \n            ('DATE', 'BYTEA'),  \n            ('TIME WITHOUT TIME ZONE', 'BYTEA'),  \n            ('NUMERIC', 'INTEGER'),  \n            ('NUMERIC', 'NUMERIC');  \n        IF EXISTS(SELECT SourceDataType, DestinationDataType FROM ImplicitDataConvertTable  \n            WHERE SourceDataType = dataTypeName AND DestinationDataType = newDataTypeName) THEN  \n            CanConvert = TRUE;  \n            RETURN;  \n        END IF;  \n      \n        EXECUTE FORMAT('SELECT count(*) FROM %1$I', EntitySchemaName) INTO countRow;  \n        CanConvert = (countRow = 0);  \n        IF CanConvert THEN  \n            RETURN;  \n        END IF;  \n      \n        DROP TABLE IF EXISTS \"ExplicitDataConvertTable\";  \n        CREATE TEMP TABLE \"ExplicitDataConvertTable\" (  \n            SourceDataType NAME,  \n            DestinationDataType NAME  \n        );  \n        INSERT INTO \"ExplicitDataConvertTable\" VALUES  \n            ('CHARACTER VARYING', 'INTEGER'),  \n            ('CHARACTER VARYING', 'NUMERIC'),  \n            ('CHARACTER VARYING', 'BOOLEAN'),  \n            ('CHARACTER VARYING', 'UUID'),  \n            ('CHARACTER VARYING', 'TIMESTAMP WITHOUT TIME ZONE'),  \n            ('CHARACTER VARYING', 'DATE'),  \n            ('CHARACTER VARYING', 'TIME WITHOUT TIME ZONE'),  \n            ('TEXT', 'INTEGER'),  \n            ('TEXT', 'NUMERIC'),  \n            ('TEXT', 'BOOLEAN'),  \n            ('TEXT', 'UUID'),  \n            ('TEXT', 'TIMESTAMP WITHOUT TIME ZONE'),  \n            ('TEXT', 'DATE'),  \n            ('TEXT', 'TIME WITHOUT TIME ZONE'),  \n            ('BYTEA', 'INTEGER'),  \n            ('BYTEA', 'NUMERIC'),  \n            ('BYTEA', 'BOOLEAN'),  \n            ('BYTEA', 'UUID'),  \n            ('BYTEA', 'TIMESTAMP WITHOUT TIME ZONE'),  \n            ('BYTEA', 'DATE'),  \n            ('BYTEA', 'TEXT'),  \n            ('BYTEA', 'TIME WITHOUT TIME ZONE'),  \n            ('NUMERIC', 'BOOLEAN');  \n        IF EXISTS(SELECT SourceDataType, DestinationDataType FROM \"ExplicitDataConvertTable\"  \n            WHERE SourceDataType = dataTypeName AND DestinationDataType = newDataTypeName) THEN  \n            castQuery = FORMAT('CAST(%1$I%3$s AS %2$s)', SourceColumnName, NewColumnDataType,  \n                CASE  \n                    WHEN dataTypeName = 'BYTEA' THEN '::TEXT'  \n                    WHEN dataTypeName = 'NUMERIC' THEN '::INTEGER'  \n                    ELSE ''  \n                END);  \n            sqlQuery = FORMAT('SELECT COUNT(*) FROM %1$I WHERE %2$s = %2$s',  \n                EntitySchemaName, castQuery);  \n            BEGIN  \n                EXECUTE sqlQuery;  \n                CanConvert = TRUE;  \n            EXCEPTION WHEN OTHERS THEN  \n                CanConvert = FALSE;  \n            END;  \n            RETURN;  \n        END IF;  \n      \n        DROP TABLE IF EXISTS \"ImplicitDataOverflowConvertTable\";  \n        CREATE TEMP TABLE \"ImplicitDataOverflowConvertTable\" (  \n            SourceDataType NAME,  \n            DestinationDataType NAME  \n        );  \n        INSERT INTO \"ImplicitDataOverflowConvertTable\" VALUES  \n            ('CHARACTER VARYING', 'CHARACTER VARYING'),  \n            ('TEXT', 'CHARACTER VARYING'),  \n            ('BYTEA', 'CHARACTER VARYING');  \n        IF EXISTS(SELECT SourceDataType, DestinationDataType FROM \"ImplicitDataOverflowConvertTable\"  \n            WHERE SourceDataType = dataTypeName AND DestinationDataType = newDataTypeName) THEN  \n            EXECUTE FORMAT('SELECT count(*) FROM %1$I', EntitySchemaName) INTO countRow;  \n            CanConvert = (countRow = 0);  \n            IF CanConvert THEN  \n                RETURN;  \n            END IF;  \n            BEGIN  \n                EXECUTE FORMAT('SELECT MAX(PG_COLUMN_SIZE(%1$I)) FROM %2$I', SourceColumnName, EntitySchemaName)  \n                INTO dataLength;  \n                IF (dataLength <= newDataTypeSize) THEN  \n                    CanConvert = TRUE;  \n                ELSE  \n                    CanConvert = FALSE;  \n                END IF;  \n            EXCEPTION WHEN OTHERS THEN  \n                CanConvert = FALSE;  \n            END;  \n        END IF;  \n    END;  \n    $BODY$  \n    LANGUAGE 'plpgsql';  \n    \n\n## Example 6 (functions)​\n\nExample\n\nExample of a function.\n\n  * MSSQL\n  * PostgreSQL\n\n\n    \n    \n    -- Function  \n    -- MSSQL  \n    IF  EXISTS (SELECT * FROM sys.objects  \n            WHERE object_id = OBJECT_ID(N'[dbo].[fn_IsGuid]') AND type = N'FN')  \n    DROP FUNCTION [dbo].[fn_IsGuid]  \n    GO  \n      \n    CREATE FUNCTION [dbo].[fn_IsGuid] (  \n        @ValidateValue NVARCHAR(MAX))  \n    RETURNS BIT  \n    AS  \n    BEGIN  \n        DECLARE @hasLeftBraces BIT  \n        IF @ValidateValue LIKE '{%'  \n        BEGIN  \n            SET @ValidateValue = SUBSTRING(@ValidateValue, 2, LEN(@ValidateValue) - 1)  \n            SET @hasLeftBraces = 1  \n        END ELSE  \n        BEGIN  \n            SET @hasLeftBraces = 0  \n        END  \n        DECLARE @hasRightBraces BIT  \n        IF @ValidateValue LIKE '%}'  \n        BEGIN  \n            SET @ValidateValue = SUBSTRING(@ValidateValue, 1, LEN(@ValidateValue) - 1)  \n            SET @hasRightBraces = 1  \n        END ELSE  \n        BEGIN  \n            SET @hasRightBraces = 0  \n        END  \n        DECLARE @Result BIT  \n        IF @ValidateValue LIKE '[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F]-[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F]-[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F]-[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F]-[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F]'  \n        BEGIN  \n            SET @Result = 1  \n        END ELSE  \n        BEGIN  \n            SET @Result = 0  \n        END  \n        IF @hasLeftBraces = @hasRightBraces  \n        BEGIN  \n            RETURN @Result  \n        END ELSE  \n        BEGIN  \n            SET @Result = 0  \n        END  \n        RETURN @Result  \n    END  \n    GO  \n    \n    \n    \n    -- Function  \n    -- PostgreSQL  \n    DROP FUNCTION IF EXISTS \"public\".\"fn_IsGuid\";  \n    CREATE OR REPLACE FUNCTION public.\"fn_IsGuid\"(ValidateValue IN VARCHAR) RETURNS BOOLEAN AS $$  \n        BEGIN  \n            IF (regexp_matches(ValidateValue, '^\\{?[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\\}?$'))[1] IS NOT NULL THEN  \n                RETURN TRUE;  \n            ELSE  \n                RETURN FALSE;  \n            END IF;  \n        END;  \n    $$ LANGUAGE plpgsql;  \n    \n\n* * *\n\n## Resources​\n\n[Official PostgreSQL documentation](https://www.postgresql.org/docs/current/)\n\n  * Example 1 (views)\n  * Example 2 (views)\n  * Example 3 (stored procedures)\n  * Example 4 (stored procedures)\n  * Example 5 (stored procedures)\n  * Example 6 (functions)\n  * Resources\n\n\n",
  "analysis": {
    "word_count": 11904,
    "key_concepts": ["lookup", "sql", "role", "operation", "package", "contact", "account", "case"],
    "use_cases": [
      "building applications",
      "custom development",
      "API integration",
      "system administration",
      "user management"
    ],
    "related_topics": [],
    "difficulty": "beginner",
    "ai_tags": ["beginner", "creatio", "package", "operation", "sql", "documentation", "role", "lookup"]
  },
  "ai_optimized": true,
  "processed_at": "2025-07-28T13:24:41.373875"
}
