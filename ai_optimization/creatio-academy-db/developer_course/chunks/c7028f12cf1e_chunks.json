[
  {
    "chunk_id": "74d747451756d564811fbad7566d279a",
    "document_id": "c7028f12cf1e",
    "content": "you you Today is session 2 and we will continue to do our first steps on CREATION platform as developers. We worked with our environment. We made our recently and today we will continue with Git, with doing other preparations, I will explain how to create with packages, how to integrate with Git and we will work with objects and data. I will show you how to build data items, why we need them, how to transport solutions, so you will see how it works in general. I hope it will be clear for you. In case of any questions, feel free to ask. I will be really happy to answer your questions. As usual, video recording has been performed. I hope that you downloaded video files from our yesterday session. I hope you made your homework and prepared your environment, so now you are fully ready to continue. If you have any questions, feel free to ask. To share? Any questions? If we have issues, we will use the solution of the local environment, we are getting some ideas, we will start in the chat. It is related to some ideas, so you post the text. It was failed to connect to the radius, something like it was not possible to connect to the radius server right now, and it was multiplexer, retrain, board connection. First of all, thank you for seeing this. First of all, you need to look at your connection strings config to make sure that you have a correct host setting and DB number. Also, you must make sure that your radius is running. You can check it by running your Windows services. I already checked it. My food number is like in your service. You should find your radius service running. If it is running, it means it should be okay. You can also look at the radius logs. Maybe it will be more clear for you. Which version of radius are you running? You can get this information if you go to see program files, you can run the special app called radius CLI. Then you will see something like this. You can type in for command. You will see a lot of technical information, like version number, amount of RAM used a lot of system parameters. Also, you will see a set of used key spaces. So it's a database numbers used by your radius. See program files, radius. Usually, if you install it, radius for Windows, you will find it here. And then you can just run radius CLI exact file. It will be a command line utility for radius. So you can run different commands. Select number of database, DB size. You can see the size of the database that you selected. You can also use some dangerous commands like flash DB for clearing of your current database or even flash all for clearing of your old radius server storage. Sometimes it's necessary in rare cases where your radius already has some previous old data. And you would like to start from scratch. So removing of all previously saved values. Normally, creation manages radius by its own. So you do not need any kind of assistance. And usually, creation is caring about radius itself. Only in some rare cases, you will need something like this, like flash all in order to reset your radius to clear everything. And that's all. But it looks like you have a connectivity issue. So a question about network name or question about port number or something like this. So is it possible to run your radius CLI and make connection to your radius? I'm doing that. So when I started radius CLI, you can just type the command flash all, which will clear full radius. And it will clear all the previously saved settings. And if you have different attempts to install creation, there is some slight chance that existing radius data may prevent you from normal start. So you can try to run flash all command. I would also type it in in our chat. So this may help you to normalize your radius operations. But the most common reason I think is about connection strength. So you should take care about the post and database number. You can try to choose another database number. Maybe you have some other apps using the same number. And you may try to run another one. I remember logging. Did it help to fix? Okay, great. Thank you to Sharfa here question. I hope it was not so boring for others to hear it, especially if others will also experience same difficulties, it will be really helpful. So let's move on with today topics. If any other questions appears, feel free to ask it any moment of time. So it will give me a bit more entertainment because soon. So once you have a question, I'll be happy to answer today. We'll continue with git, with package management, and also with working with objects in general and using data items and possibly I will show you some advanced example with connecting database views and objects. So today we will mainly focus on general stuff like git and object and data management. First of all, let's remember where of the finished last time. Last time we manually created new package. As I told you, the scenario for manual package creation will be necessary in examples where you do some classic UI customization. In general, you can create packages and then you can use it for freedom UI apps, but it's not so common because when you create freedom UI app, system automatically creates a package for you. So creating package manually usually means that you are planning to do some classic UI stuff. Just to remind you, classic UI is a special old type of user interface, which you can still find in many system sections like system users, like system settings, like web services, you will see some specifics and no possibility to shrink columns easily. And a bit later I will show you examples of freedom UI and you will see how you can use such tools, how to look like. So we have two different types of user interface. They have a totally different undercover frameworks inside and that's why it's so different and we make such difference between different types of creation pages. Okay, so death classic will be intended to use for some classic UI stuff. I need some dummy example to be put into my package. Currently, you can see that we can select all packages. As you remember, we have 141. Now, let me check number of packages at our D1 database. Now, we have 141. So one package was added because we added it manually. And if you select all packages, you see contents of all your all system. You can use some search. You can use by search, by title or by code. You can use different search condition. And you can also make filtering by configurable item type that you can add to your package. In my case, if you select any package, you will see its current contents, especially if you clear search bar. So you will see current contents. And when I select my package, by default, it's empty. We can create some dummy stuff here just to demonstrate something that is not empty inside of our package. So let me show you what it will be. For example, we can make a test process, business process, it's a type of configurable item designed for automation of some business actions in our creation system. So now I need it only as a template dummy stuff just to make it to make my package not empty. When I design my items, I must provide code. And by default system expects me to provide some prefix for this code. This prefix can be also set at system settings. You can search for prefix for schemas and packages name. You can open it. You can see default prefix is USR. You can change this prefix at the beginning of your project or you can even remove it if you do not like supporting prefixes. In my case, I do not need to disable it. So where it be as is, prefix usually helps me to detect my custom changes and defer them from base product stuff. So anything which has my prefix will be definitely made as part of my customization. So in general, I consider prefix as useful thing. But in some projects, developers decide not to support prefixes because they just tired of making them. So in my case, when I create a process, I must use this prefix. The same as my system setting, USR test process. We can name this stuff as test process. I need it only as a dumb desktop. So I do not really plan to make some business logic here. So my test process includes some start simple event and then terminate event. So this process is just doing nothing. I have no parameters, no special settings. I only have code and title. And I can save this sample diagram. It will be saved into my package, as you can see here. So I can close it. Now my package is not empty. And you see this item added to this package. You may note this big star nearby the item name. And this star tells us that our change is performed and not fully properly saved. In case if we work in this creation, no, no, no, external ID mode or it's also called file system development mode. It's kind of long name for this. So file system mode. In case if we work in this mode, this star is really important and helpful because it shows us that something was changed and not fully saved on disk. But if you will turn back to creation ID, this star will be almost useless because it will represent that your changes are not submitted to the SVN. And if you do not support SVN, so you will always have big set of such items with stars and it will not help you to detect some recent changes. So in our case, working with file system star means item was not fully saved on disk. Why we need to save it? Because creation shows us some changes and they must be submitted properly in order to make correct sets of steps, make correct development approach. So we can submit everything to file system download packages to file system. The reason why we have to do this is that some changes when we do them at configuration section are not initially and fully saved on disk. They are still created and saved in database first because it was historically and originally the first storage place of creation items in database and only several years later, possibility to save items on disk was added. And that's why we have some kind of legacy and historical stuff. And when you develop some items, they are anyway created in database first. Okay, so we can run this action download packages to file system. It will include all our editable packages, all the contents and save a set of files and folders on disk. When it finishes, it will show us some report, what have been done, and you will see this report easily. And also this star nearby the item name will disappear. Meanwhile, you can see the type of the item with the business process. Now you can see this small report includes text that this usr process was modified on disk, so it was fully saved. Now you see this star disappear. We can go to file system. Here is our app file system. We go to the source of the web, source of configuration, pkg, then we will find our devclassic package. And now you will see that it's not empty. You see schemas. Now we have some special folder. We see some set of files. It's not so easy to read such files. And luckily we will not need to modify them using external editors. This is a special set of settings called metadata. Metadata is information about our configurable items stored in a special system in their format. In a JSON string, we have a big number of different properties and values. And luckily we should not look here constantly. So it's just something that you need to know that it exists. So metadata represents in a structure of the item. And therefore some types of configurable items, it's not really designed to be edited out of creation. So only creation editor should be used for this. This metadata represents full structure of what we designed. And we can now have this stuff saved on disk. The reason why we saved it on disk is our attempt to organize a teamwork. So we want to make some changes then to make a common repository. Save our changes there in order for our team members to make them possible to get our changes from common repository. And that's how we will exchange settings between different developer environments within one development team doing the same project. So now as you can see, we are going closer to file system and to understanding how we can exchange settings between developers. I need to tell you that creation has two different flows of changes. Two different directions of how you can transport changes. First and the most necessary to know is delivery. So when you do some your solution or you have an existing solution and you want to save it and then import it somewhere else in order to test or to run in production, you can just export this package into file. You can export any package you see. System will produce zip archive file and this zip archive file can be found on disk here like this. And this zip archive file can be also uploaded on some other environments. Such uploading can be done with the settings. Then you go to application hub and then it's possible to add the new application with install from file option. So that's how you can get it from file and load it. If you do it many times, you will install from file many times and package will overwrite reviews. Package settings so you can do it multiple times if necessary. But this is delivery procedure which is designed to be used only for test and production purpose. But if your task is to share settings between developers, this export and import approach is not good. Because when you import such package at your another developer environment, you will see this package will be read only and also when it's imported, it fully overrides your contents. So it will be really hard to operate as a team where each team member can do his own contribution to the common repository. So such export and import is not designed for sharing settings between developers. We have to use a bit more sophisticated approach and that's why we are turned our environment into a file system development mode. So the step one is to make sure everything from your changes is saved on disk. And step two is to use any kind of version control systems to operate with set of your files and folders from your disk in order to deliver changes in order to transport your changes from files and folders to some common repository. And then other team members, other developer environments can take such settings from common repository from other, from common repository to another developer environments. So that's how it can be organized as a team. And now I will show you, I will use git as a version control system, the most popular for now. And in order to run git, I need some kind of good git client. I prefer to use visual studio code as a git client. So it started, visuals studio code, luckily it's a free of charge. So you can use it freely. Here is my visual studio code. Probably I need to close everything. Close folders. So I need to make just from scratch. And what I need to do. So first, before you enable any folders, before you operate with your git, if you don't have git client, you should click on this button source control. In order, if you don't have any git client installed, you will see only one button here. It will be called something like, oh, we have to update. Okay, maybe later. One single button will be install git client. In this case, you have to run your visual studio as administrator when you click on this button to automatically download and install official git client. And after this, you will see the same settings as I do. Also, you probably will need to run a couple of commands related to your client user name and email. But this is something very common. I think you can easily fix it if you face this difficulty with new terminal window and a bit of googling will tell you how to make full setup of your git client. In my case, this git client was already set. So I already have git client normally working. So I can now open folder and initialize repository in it. This is very important to understand how you should manage folders. So here, we have our application, to resolve the web, to resolve configuration, pkg folder, and we have a lot of subordinates, sub folders here. What are they? I will explain a bit later. But now you need to remember and understand that currently I have only one package. But very soon, I will have more than one package in my solution. So if I decide to make a repository route folder somewhere inside of my folder, representing a package, then it will be really hard for me to add any other packages here. So I will need to keep several repositories for several packages, which is also not so good. So possibly we can select upper level folder. This pkg folder will be my route working copy. Catalog working copy directory on my disk. And then as many packages as I need, I will be able to use inside of one single git repository. And also we will have to take care to remove from the repository. So I do not version a lot of other files here, which are not so intended to be changed. And they are not part of my solution. So I plan to use a pkg folder as a working copy route folder for my solution. I will do this with Visual Studio Code. And in Explorer tab, I'll just click Open folder. I need to find corresponding folder for my disk. And now probably it's time to explain why we have so many files and folders inside of pkg. So when I opened, you will see a lot of subordinate. Yes, I trust the authors, but you will see a lot of subordinate files and folders here. So the answer of what it is is quite complicated, especially as you are beginners. So probably you will need to watch this part of recording a couple of times to understand fully. First of all, you may notice that folder names here represent some packages names from your configuration. Let's look here. Let's start calendar base. Can you find it here? Yes, here is calendar base. Okay, next one, content builder. Content builder is also representing a package. Okay, CRT analytics dashboard. Okay, let's find it. Yes, you can see it. But total number of such folders is much less than 140. So it looks like such folders appear here as a result of presence, some packages in configuration. But for some reasons, not all the packages from our configuration form, they are owned folders on disk. So the answer of what it is is a bit complicated and it's called file content. Let me explain what it is. So generally, any package in relation may include unlimited number of items with different types like objects. We will study them today. C sharp sources, et cetera, site program code in C sharp language. A lot of JavaScript client modules representing page settings for client side. We have some data items. We will discuss them and they are used to keep some data records in your system, business processes and some other types of items. So in general, any package may include unlimited number of different configurable items. That's okay. But also, developers decided and architects of creation decided it would be nice to make a stability to add some additional file system stored functionality connected to the package. And they decided to make so called file contents. So if you have a package, any package may have its own file contents. And this file contents should be saved in PKG folder, then in folder name inside of it, which is the same as package name. And inside of it, we have files folder and it may include some DLLs. It may include some additional files and bin folder, which usually includes DLLs. And this file contents is usually having two types of files. It usually has some DLLs as a result of compilation. And for some cases, it may include some JavaScript stuff, JavaScript components. So generally, the answer is that in PKG folder, we have file contents, which is a legal valid part of some packages saved on disk. And we should treat it as redone this stuff. We should not remove or modify any part of base product packages file contents. So we should just simply ignore all of this stuff. So now we are going one step closer. You already know that we are interested only in packages that we design, ignoring everything else that we can see in PKG folder. Okay, now it's clear. So let's go to our Visual Studio code, which will work for us as a git client. Now we only opened some folder with big number of files. We are really interested only in some part of such files, but we are not interested in all the contents. So let's go to source control tab. And now it's time for us to make a git init command. So some of you already have some experiences git. You already know what it means. So we need to initialize a local repository to operate with git. This is a necessary, so it looks like mandatory step if you want to use git. We need to initialize repository. I prefer to use as much as possible of graphical user interface to operate with git because it's easier. It makes less chance of mistake and much more visual, so we can see what's happening here. So I will run initialize repository, which is the same as git init command. And it will initialize my git local repository in PKG folder. So I just click this. It performs some steps. And now we can see that at this source control tab, our git client detects huge number of modifications. Of course, most of them are at base product packages. So we do not plan to version such base product file content. We do not plan to submit it to version control system repository. So we need some tool to ignore this big part of of PKG folder. And we only need to keep and take care about packages that we decide to create ourselves. Now we have only one package that we are really interested in submitting. This package is called dev. Let me show you a dev classic package. So this is our package that we plan to operate. We want to ignore everything else. Custom packages also editable. But we agreed that it's not a good idea to use custom package for big project development. So I prefer to ignore custom package as well and keep it empty or only with some temporary stuff, which will be not submitted to version control. And we will be not shared with any other developers. So I have simply only one package here. So far, but soon I will have more packages. I need to ignore everything else. And from my previous experience, I already have a tool for this. If you have no previous experience, you probably know that in Git, you can ignore some parts of your working copy folder by use of git ignore tool. And I can find good example of git ignore tool at my git hub repository. So let's go to git hub.com. I need to sign in. I use my Microsoft Authenticator for this. Just a second. Authenticator helps me. GitHub. Yeah. Sorry. Change number. Okay. Okay, this one. Okay, successfully confirmed my person accessing GitHub. I recommend you also to register your account at GitHub. So what I need here is my repository. Confirm your counter and you'll have a recovery. No, no, no, no, no, no, no, no, no, no, wait. It's okay. So I have a lot of repositories at my account. Probably you can find it here. My repositories. And what I need here, I need some example of a recent, of a recent git ignore file. Originally, I had no examples, so some of my colleague proposed an example of git ignore file, originally made for Visual Studio. But now I have a better example, so I will have a less time to update it. So I already have some example of git ignore file. Of course, I will share it with you. Git ignore file is a file with empty name and git ignore extension. And the main reason of this file is to provide set of macro or a set of text templates, which will be used to find and exclude from the contents all stuff, which we consider as not necessary. Usually it's designed to exclude log files, some settings files, some technical files generated by your integrated development environment, temporary files, project files, sometimes executables, if you do not need them, debug files and so on. In my case, we will use this git ignore file to keep set of base product packages names to exclude our, to exclude them from our versioned contents. So I will simply copy all of this code. I will make my own and you git ignore file inside of pkg folder. The name of the file is dot git ignore. If you will do this with your Windows Explorer, make sure you set for display of the full file names with extensions. In this case, you will not fail and you will not create a dot git ignore dot text file. So I will create new git ignore file, paste this stuff there and save it. Now you will see immediate change happening in my repository, in my working copy, working copy source control tab. Now you see git ignore file, okay, great. We can still, we can also edit it here if necessary. And we still have some packages appear here. The reason is that my git ignore example was from version 812. Currently, we are running already new version. This version is 813, the latest available released version. And in this 813 version, some new changes and new file content appear for base product packages. As you can see, CRT omni channel app appear it here and I can add it to git ignore. Let me show you what happened. And also I do not need to put all of the files here. So package name is enough and CRT security. So I can type it menu CRT security and save it. Now you will see I cleared my versioned stuff. I only have my dev classic package here. I use the git ignore to remove big set of base product packages and base product file contents from versioned stuff. So git ignore helps me to do with this. I have a small poll for you. Could you please confirm, do you have any experiences git? And if yes, please type plus in our chat or if you don't have any experiences git and you do it first time, then please type minus in our chat. So it will help me to understand your current level of skills and knowledge about version control because today developer I think must have some basic experiences version controls because it's quite inevitable to operate as a team. So thanks for all of you who replied, you have some experiences git. Those who do not reply and please don't be shy understand that no one knows everything from the beginning. So everyone is studying every day. So some years before I also was not knowing about git at all. So this is something that you can learn and my task is to help you with it. So now we have settings for our git client to include only necessary parts of our code and we excluded everything else using git ignore. Also I wanted to show you in file system once we initialize git repository. You will see that a new folder appeared on my disk folder name is dot git and this folder is hidden. As you can see the file attributes here show us it's a hidden. So possibly I will not see this folder easily in my Windows Explorer, but here I already saw said show hidden items and also I already said for showing file name extensions there's not to be tricked by Windows. So now you can see hidden folder dot git even in Windows Explorer and dot git ignore file has a dot git ignore extension not text extension. So it is also important. Okay so this is my local git repository. I did not perform any commits to it. So I did not submit any changes there. So it's time to make my first commit. Let's do this my first commit ever. So it's just something fun text and text for your commits is important to describe your changes in general. Like you did some new section, your date improvements in integrations or you made some data fixes or anything else. So your commit text should help you to track history of your changes in future and it also will help others in your team to understand what actually you are changing and what is the sense of your changes or why you submit some new changes. So when I do commit it will run git commit action and it will save changes in my files into my local repository. My local repository now became a bit bigger. So it has a bit more files and folders now you can track it if interested, but the inner stuff here is really hard to read. So it's about some git secrets how it saves your commits, your changes and so my git repository is still local. So I did not share anything with my imagined team members. I need now I need remote global git repository that will be available for my team members. I will use git hub.com as a central git repository host so it will be my git server and I can create new repository. I will have a lot of repositories here and I can easily create new one more new repository for our training session stuff. Oh, have some for hours. Nice. And it will be a public repository so anyone can take information from it so you can also read this repository. You can use its contents. You can save it at your own and see what happens if you add your files to your creation. So I need this command repository to organize sharing of settings with my colleagues. This is very easy. I also avoid using commands. I use user interface because it's easier and quite straightforward. I will create new repository. It will be something like guided. I did it. May 2024. This name was not used inside of my account and no description, public repository. No readme file. I'm too lazy for this. I already have git ignore so no need to add it once more and no light so anyone can do anything with my code. Simply create repository. After doing this, it's time to think about some git commands to connect my remote repository with my local one. And we have set of commands that will help us to do this. So first command is git remote add origin. So I will connect remote repository to my local git client and my local git repository. I can do it with a terminal window. Actually, I can run any command line on my PC but I prefer to do it here just to be a bit more consistent and to show you what happens directly not far from my visual studio code. So I just paste this code git remote add origin. And as you can see, my remote repository has this URL. Okay, let's do this. Then we have a set next command. Select and main branch on my local one. git branch m main. And the most important command is git push which will transport changes from my local repository. So to transport my commits from local repository to this global one so it will become publicly available. git push. It usually needs some internet resource. You see pressing was used here. And finally, my remote repository was updated by a set of commits by stuff that I committed from my local one. We can check it out. So now my repository is ready. You can see some files and folders here. If you go inside, you will see that git keeps only files, only folders which are not empty. If we compare with our physical file system, you see for example data folder which is empty. And it's not present here because git is still not supporting empty folders. But it's okay. So it's not a big trouble. If you really need empty folders, you can use some place holder files. Creation is not sensitive for this. So even if we submit to version control only meaningful part excluding empty folders, system will still be okay with it. And now we have some stuff from our package which is not empty. So we have some files and folders committed to local git repository and then to common repository. So now it's globally available. And I can share my repository link for you. So you can also check it out if you have any git account and know any restrictions to access git hub.com from your PC. So this is my repository. And what the reason why I made the repository based on PKG folder. Now I have only one package and you can see this is a subordinate folder inside of my repository. If I have two more packages, it will be two more folders on this level. So having this kind of repository helps you to keep minimum number of repositories and maximum number of packages inside. So I can easily add more packages to my solution. And it will still be located at one repository. You can also see all the history of my comments. You can see changes there. So we will work with it a bit later. Now I will demonstrate what usually developers do when they operate with git and how they are, let's say, set of steps should look like. We are starting some steps at our development. For example, we open some configurable items. We do something very important. Okay, not so busy today. Let's do some read data. Let's say we will do some dummy thing or read data from a contact object. We are name full name. For example, equals to some value. No problem. Let's compare its value, like supervisor. This is just something that is a demo setting. So I do not actually need it so, so much, but this is something that I will read only one call. Okay, so this is just example read. An example of what we can do as business logic automation inside of a process. Let's imagine we did something useful, something very important for us and then we save our customization. This is an example. In real life, your package will include tens or even hundreds of items. You do some steps in your development. Finally, you decided some part of your solution is ready. So you can save everything. Then you go to your configuration section and download all the packages to file system. The main reason is to get rid of this star and make sure that all of your recent changes are properly saved on disk and represented at file system level. Originally, when you do customizations, they are saved in database. And only if you download on disk, it will be properly and fully saved on disk. Some items are also saved on disk while you edit them, but this download action ensures that everything is properly saved. So you must do this action when finished some development steps. Okay, I have some changes now on disk star, disappear it, so everything is properly saved. Let's go to Visual Studio Code and let's see what's changed here. You see, we have some changes in this character. For our process, something like date of modification changed. You can see changes in metadata. We have some new item added. We have some titles changed. So some position changed. It's really hard for processes to detect changes like this, but this is something that we do just an example of some customization made. Also, we have some new items appeared here probably because of our titles added to the process pieces, but okay, some test process and so on. So we have set of file changes. We can commit it as a commit example. Commit example one. And we can do git commit into our local repository. Great. Now, we have no changes. So we have some pending stuff that should be pushed to global repository. So we can again run this command git push or which is easier, I think, is to click on sync button, which means pull and push. Pull and push. In my case, it's like valid set of steps. So I prefer to do this. Pull and push and that's how this symbol automatically perform the same git push to my common git repository. Now we can go to git repository, reload it, and you see some history of changes. So we have two comets. Here is my commit history. You can see and compare changes. Let me show you here. You can compare changes in each file, in each separate file, what was changed there. I agree sometimes it's really hard to perform this type of comparison. And it's because of the metadata stuff here. But anyway, technically you have tools to perform such comparison. You have tools to track changes. And you can see what is changing, what is happening in your repository. You will see all users committing. You will see all history of commits. You will understand pretty much everything. What happens with your package on file system and this storage now is a common repository. So let's imagine we have another developer. Another developer originally has no own package at all. Another developer just installed new environment and they have no package at all. So only one single developer should create a package, should commit it to file system and then to version control repository. Another developer should go to this common repository. Another developer should organize their local git repository in VKG folder. And finally, pull changes from this common repository. You can also make some clone, but I think it's something that probably will be a bit more tricky because you will have to do it in a proper place on your disk. So finally, task for second developer will be to operate with their own package folder to make their own local git repository there. And then to get this folder out from git to local file system. We can do it with git pull commands or git clone commands that have a works better. And finally, creation is interested on the in VKG folder and the contents here. So finally, you will get this folder from git repository to some another developer environment. After you do this, you will have file system stuff like this. You probably will have empty folders for items that were not used so far like SQL scripts and data will be empty for some time. Then second developer must tell creation that PKG folder file system has something new. Creation will not detect it automatically. So you need to push it. You need to make a punch for your creation with the command update packages from file system. So second developer will perform this operation. And second developer will see results that some new files, new folders appear and even new package will appear at second developer environment. So that's how your package changes may travel from one environment to another. I mean, from one developer environment to another developer environment. This is very important to mention. We are talking about developer environments working with version control. Let's imagine another developer environment opens some changes or creates new items. Finally, saves on disk, then commits everything to file system, then performs git commit at git hub client, or sorry, at git client, probably it's a visual studio code. And then perform git pool and git push in order to update central repository. After this repository was updated, first developer may also perform git pool and git push. And that's how first developer will receive all changes in the package files. And then first developer must run this operation update packages from file system. So that's how you can exchange sidechinks between developer environments. And as you can see, it's fully 100% based only on files and folders. So no any special magic or special calls or special with services are involved into this. Only files and folders are enough to save changes, to extend and to exchange your services between developer environments. As you can see, it includes plenty of files. Let me show you 30 files are here. In big projects, you will have hundreds or even thousands of files. So it's much easier to miss something, but it offers you possibility of teamwork. You can change all the some parts of it, you will commit only changed items, changed parts to commit repositories. And everyone else can do the same. So that's how you can easily save. Modify two different items of the same package and work as a team. There are some warnings about this. Some items like processes and also objects are not designed to be simultaneously edited by different developers at the same time. So you should avoid situations where you have two different method data files. And you should avoid situations when you will have to merge them into one. So here you will see the main method data file, which is really hard to read. And it's probably not so practical. You should not try to make any manual changes here. Even in case if you got this situation when two developers made changes to the same item, I think the best way is to sacrifice changes from one of the side and submit another side changes into repository. And then ask first side to check out it and make changes again. So merge of method data is not designed and probably will not be successful. So you should not try and it's better to avoid this. So you may communicate with your team members and organize your work so they will not interfere into each other settings. But in one package, as you already remember, you may have hundreds of items. So if developer one, modifies item one, if developer two, modifies item two, there will be no conflict. They will successful and happily work with the same package. So you should be just worried about simultaneous access with the same item for different users, different developers. If you have any questions about it, any other ideas, feel free to ask. I will be happy to explain. So in general, now we made all major settings and you see how you can set up your common repository. Now you see how you can submit changes to this repository and we can move on with next topics. Probably before moving on, I offer you just five minutes break for a coffee. And then we will move on, ways working with object topic and managing data. So we finished with the question of git integration and it's time for us to think about working with objects and working in general with creation data model. So what you need to know about it is that the basis of all creation data model is a configurable item called object. You can easily create objects in your configuration and also when you do customization using no code tools. For example, when you operate with the application hub or with section wizard, system is capable to create number of objects automatically. But in order to study it, we need to make some examples manually. We understand it better if you do it by hands. And the creation has a lot of out of the box existing objects. So maybe a couple of hundreds here and a lot of them represent simple entities called lookups. Let's go to lookups and let's see what they are. So go to lookups. For example, we can sort, okay, I prefer to look here, select fields to display, switch to list view, and it was originally in tile view. So I plan to look at list view and also I need to create it on column just to make more comfortable sort. To make more comfortable sort in this list. So I can sort by name. For example, we can find a lookup called address types. So it's something simple address types. You can open it and we will see set of records representing types of addresses in creation by comb address business address actual or lingo address and so on. We have six records here. Such records are physically saved in the database. And we can go to the database using our database management tool, make new query, select everything from address type. You can see we have the same name of the database table working with it. So now you can see the same set of addresses, stored in the database, and some additional options are also supported here. So what do you need to know is any object created in creation. We'll finally turn into a table in database. So now we talk about general objects without special chemistry, without any tricks. So in general, if you create an object, it will have its own database representation as a table. One object means one table. Sometimes participants ask me participants are asking me about is it possible to have one object for many tables at a time. So normally not, it's not designed to be so. If you need to operate many tables and to get some aggregated data from them, you may use database views and then you will use a specially designed object for it. But in general, when you create an object and everything as usual, system will create and manage one database table. We can find this database table by name and this is address type. Let me find this one. So you can see table structure, all the columns. You can see it's a key field. You can see primary display, text, health and some others. We have a lot of base project lookups. You can see how many we have if you go to view in your lookup section, view summaries, top summaries, display number of records. And now you see we have 120 lookups out of the box studio product. If you work with more complicated solutions like sales, service or marketing, you will have even more lookups. And also we can easily create our own lookups and we will need them for our future settings. Lookups are generally used at the contents of data when you have a lookup column and you need to select some values from it. So building more complex solutions usually starts from making your lookups and that's why we will do some. Now I plan to do some changes in my package and it will be necessary for my future solution in classic UI. So this will be just an example for you and I will show you how to create new object from scratch and business sense of it will be some lookup for our future section that we will design. So let's imagine in future we plan to make a new section to keep some reality data information about houses and apartments for sale and for rental and obviously we need some lookups for them. For example we will keep realty records and we need to know information about type with the reality. So it will be a lookup we can call it realty type and I will show you how to create it from scratch. So select our package and the object. When you create a new object it means you are creating new entity in our system. New database table will be created. Working with replacing object will be covered with the data. So now let's make a new object. When creating a new object we can provide some properties for it. First of all we should take care about its code. As you can see system tries to avoid duplicate and that's why it generates some unique name for our object. Of course it's not good name. We would like to make its name by our own. We still have to use prefix because it will be not reject to do or to work with prefixes and we will have this prefix usr and that we can provide code for our new object. It will be realty type and also I plan to make two different solutions one for classic UI and other for freedom UI. So for classic UI I will have a suffix classic. So it has been a realty type classic. I do not want to share any lookups between two different solutions so let's why I will have made it fully separated and that's why all the lookups for classic part will be fully separated from lookups from freedom UI part. So this is our code. Code is very important. It must be made only of electing characters and underscore and sometimes you may also use digits but I recommend it to use only wetting characters and it must start from character and code will be used to create database table. So system is capable to make set of theories to the database like create table, alter table and add columns and so on. So we only provide some necessary properties and system will take care about database storage itself. This is also very important. So code will turn into database table. Tytone. It could be anything and even more it can be translated into other languages. Currently in my environment there are two active languages so I can easily set values here but in total we have probably 21 supported language. Let me quickly check. This is very interesting. CIS culture. It is a special object that keeps information about languages supported for translation into our system and it looks like we have now 323 languages. Sorry. Let's see the most recently added ones. So wow, it's interesting because previously I only remember added Japanese at the beginning of 2024 and now we have some very recently added languages. Hungarian language was added recently so greetings to Hungary and Croatian language. It looks like HR. It's probably Croatian. Yes, it's Croatian language. So you see more and more, let's say, national languages are added here and now we have 23 supported languages in our system. Some of them may be disabled others are active and if you want to use a certain language you should activate it. The reason of activation and deactivation is saving of system resources. If you do not need all 23 languages it's better to keep most of them as inactive system will save system resources for not necessary languages. So that's why we have active option and you can manage active or active language in settings. Then you can find languages apart and now you can see 23 languages and you can activate language if necessary by opening it, setting active and then save. But please, so this is a warning for you. If you activate the language it will consume system resources and usually activation takes some time maybe up to five minutes. So please be very careful with it. Now you see recently added Croatian language and Hungarian language. So this is something that is interesting and it's new for this version. Okay, let's go back. So if support of multiple languages is important for you, I recommend you to enable necessary languages and each time you develop some items, instantly provide corresponding translations for your items. In this case it will be hard to forget and hard to miss something that must be translated into other languages. We have also an alternative way to support multiple languages with the translation section, but I do not recommend you to work with it because when you initially go to translation section, it will take probably 15 minutes of time for initial preparation. So it's not so comfortable and I think it's much easier to provide correct translations just while you develop it. So in my case, it will be a real type classic real-time classic you might call it. If I want, I can support translations into other languages if necessary for my project. So cold and title they are important. Parent object is not mandatory, but it's also very important, especially if you make lookups. Inheritance helps us to get standard structure for objects, especially if we need some typical use of our object. In our future, we plan to use real-time classic as a lookup. So we can inherit structure for our object from some base objects that can be helpful in our case. The most commonly used base object is base entity. It helps to inherit key-thread historical columns and some behavior, setting some event handling that is necessary to operate in some lists and some cases. So base entity is like common parent item for all clear-show objects, but also we have base lookup. Base lookup is used especially when you need to create new lookups and that's why such two most commonly used items are displayed at the top and all others are shown in alphabetic order. So base entity and base lookup the most requested, the most frequently used are shown at the top. Okay, I need to base lookup for this. I have to confirm my change and once I do this, now you see I have new inherited columns list. I have eight inherited columns. The most interesting is probably ID as a key field. Its data type is unique identifier. You already saw examples of such unique identifiers in many creation tables, so such a hexadecimal big bar, a big line of code is example of a grid globally unique identifier. Physically it's saved as a 16 bytes integer, so such data needs 16 bytes in memory to be saved, but it's very common for creation, so all creation objects are based on unique identifier key fields, usually named as ID. Also we have name as a text as it used as a primary display column. Name is a mandatory, you can see required, yes, the data type is text 250, which is very typical, and you should know that creation uses unique code strings anywhere, so every text column you will find in creation is based on unique code text. It means you can simply save any national characters there, any kind of Arabic letters, Chinese letters, or even emoji can be saved into such text fields. So unique code is supported. Also we have so called historical columns, created on the date of creation, it's a date time date of creation of the record and created by this is a reference to a contact, so this is a Rookup column pointing to a contact of user who created the record. Modified on, we performed last, so the time when last modification of the record was performed and modified by is column representing who, what user contact performed modification. So we have a description name and description are business columns, all others are system columns and process listeners is an integer column for a very rare cases when record, level, event, handling is used in business processes. So what do you need to know? Inheriting from base lookup gets access and we get structure, so we inherit structure of system columns, the most important columns are ID as a key column and name is primary displayed column and they are important to work with lookups. Also you can find in main object that some inherited properties are shown here, ID, property which means key field, so this is not perfect title of the property should be named key field and ID is used as a key field and displayed values also not a perfect title, previously it was called primary displayed value, so the main text column which is shown in drop-down lists of lookups, so name will be used for this purpose but you can change if you want. Now any other special properties, we have some event handling made for this inherited from parent one, we will study event handling a bit later, so what do you need to know now when you do inheritance from base lookup, you automatically receive legacy of all columns that are intended to be used inside of lookups and usually it's enough, so usually you can create just code, title, inherit from base lookup and then save and publish and your object is ready. In my case I want to present and show you some additional features that could be interesting and also examples of how you can make your own custom columns in creation, so we will go to columns list and obviously we can add our own columns to the object, we have plenty of options for different database types, a lot of text options, the minimum supported is text 50 characters, then we have 250, 500, we have unlimited events, we have rich text which supports fonts, colors and styles like italic, underscore, etc. We have special texts for phone numbers, web links, emails and URLs and we have encrypted strings to keep passwords safely which will be not displayed as a text will be always displayed as a set of stars and we're rarely used CRC type which is a collision integer and it's used for checks, so it's like checks on columns, I never faced a working example how we can actually use it so just something like bizarre thing that possibly you will never use in your practice, so number is obviously integer and several types of decimals, currency is also decimal with two digits after decimal point, the difference from standard decimal is that standard decimal is 18 digits and two after decimal point, currency is 20 digits and two after decimal point, so 20 in total, two after decimal point, that's why we have so different but you see we can choose any necessary precision for the four-year solutions, okay date and time, quite of those, we have date time value, separately date, separately time, some other types like Boolean, like unique identifiers, like image link or color selection column file can be saved and lookups, lookups are mainly, so they are generally used and based on unique identifiers but lookups also keep preferential integrity, so when you have a lookup column system creates foreign key for you, so it keeps referential integrity which will not allow you to save into lookup column any value which is not faced in your lookup table, so we can try to make some examples, like make a new text column named code, title can be code, text is 250 and as example I can show you how default values can work for us, how we can make auto numbering, so we can search for default value and we can set auto number option, we can say prefix like CD which stands for code and number of digits are divided with two, first one will be CD01, CD02 and up to CD99 and then we'll have the next number, so XCD100 and so on, this is auto numbering which works pretty well and it doesn't require any programming, so this is a no code tool to make automatic numbering in your lines when you when user import ads data, that's how we can do this and if necessary can use custom indexing, you can also make your own custom indexes and even complex indexes, unique indexes can be added but generally creation takes care about indexing by its own quite well, it automatically creates indexes for lookup columns, so you probably will not face any significant performance issues in objects and data tables made by creation, so once we finished setup of our object we have to save it, save means saving only meta data, so inner data format to keep information about our configurable item, this type of item is also inherited from schema but the word schema I think it's hard to understand, so let's say configurable item which will be closer to its meaning and I think it's easier for you, so when we saved this item it will be shown in our package contents, now you can see database update required, so object can be applied to the database but it's not performed each time you save, only when you click publish, publish means apply changes to current application server and current database, in our case apply changes means create new table with corresponding set of columns and provide necessary column settings and everything should be well done at the database to make our object fully operational, if we do not publish our object will not be able to use this object in our system, so publish is necessary to make our object operational and useful for us, let's do this, some years ago publish took a lot of time, it may took up to one minute of time, now this operation is well automated and now we have no serious reasons to separate, save and publish also when you click publish save is performed automatically, so you may just use publish button, forget about save button and it will work for you because publish now works really fast, okay so when we finished with it we can close our page, by the way this page is called object editor or object designer and now we have our object status is okay, so you see it's applied to the database, we still have a C star which means not everything was saved on this but at this moment our object is already working, so it can be used for us and we can try to use it in our environment, let me show you how we can use it, we can go to studio work place, find lookups section, as you can see we have 120 existing lookups, one of the recent ones, you can see something strange, there is no name here but if we sort by date of creation, so this is a list of registered lookups and we can see what recent registrings were done, like white list of pages, open intersections, access to tag, your aunties or something like base product functionality, recently added here, so we can register our object that we created as lookup in order to make it easily managed and we can look at it and we can even fill it in with some data, so when we click new lookup it doesn't create new table, new lookup means register, existing object as lookup, our object is called reality type, we can name custom, we can provide custom title of this lookup, so name is separate from object as you can see, and we can save it, so this operation is just for registering object as lookup, once we did it, we can click open content and that's how we can manage our lookup contents, the easiest way to manage object data is to register any object as a lookup, then you will be able to see its contents, so we can create new record here and we can manually type some data, like first one, reality type which we work with, it will be probably house, so it's name private house, we can save it, this is so called editable list and we are not using any separate edit page for it, so we just manage data directly in this list, another one will be apartment, as you can see numbering works for us, automatically the no code tool, thanks developers for this, you can also use description, if you want, but i'm not really needed, so we can also add more reality types, what else, it could be office space, it could be parking lot, and something very unusual like a castle, it's just an example and i also wanted to show you some additional behavior here with a numbering, so let's imagine you try to create new one, but then no data, or something else, so you think that oh you don't want to create it, you see the code was generated, but then you just cancel, okay, if you create one more, you see the number goes on, you cancel, if you create one more, you see numbering is going on, and it will be not rolled back, the reason of why it performs, so when it generates, system does not know, are you planning to save it or not, so it generates new number, keeps, currently created number somewhere in the database, and so called sequence in the database structure, and then we have no option to roll it back, because while we are inputting such data, someone else also may create new records, so if system is expected to be used by thousands of users, we have no option to easily roll back such numbers, but it's not a big problem, even if you have some gaps and missing numbers, it's not a problem, really, so you see that numbering is generated using database tools, this is extremely reliable, and physically sequence database object is used for it, bus is telling us about an appointment, and we'll watch the video, thank you bus, see you tomorrow, thank you for your message, any other questions, please, you're welcome at any time, so now you understand, we input some data here, this data is physically saved in our real database, let me show it for you, example select ID, name, ROM, USR, real, T, type, classic, this is the name of my object, I expect to see the name, the same name of my data table, now you can see the same five records with some IDs are created, I can also search for, I created on, and also USR code, so here are my columns, you can see you can select all the data, so this is physical data saved in my database, it's pretty simple, and of course when you develop your big project, you will not pay so much attention to every single lookup, you will do it in much more automated way, but this is an example which will let you understand and will make better feeling of what object is and how it works, that's why we discuss it in so technical details, if you need to change something in your object, you can open it for editing, you can find corresponding proper to change it easily, if necessary, you can customize your columns, you may rename some columns, you can add the new columns, for existing columns you can slightly change their properties, it will be not possible to change the column code, but you can change column title if you want, so for an inherited columns, there are some limitations on what is available for you for change, so generally speaking you can manage your object, you can change them, then you can say even publish, that's how it will be applied, in big scale solutions, you will create tens of different lookups and create your escapeable to help you with it with automation of lookup creation using application hub tools or using section wizard for classic UI, so it will be not so boring each time when you create new object, this is technical right now just because we need some practice, we need to look at object structure, so okay we have our object ready, we have some data here, so how we can share it with our team members or how we can deliver it to test environment, of course we need to download packages to file system, if we want to submit everything to repository, but here is very frequent mistake that a lot of the gainers usually do, this will be about data part, so saving anything to disk here is okay, and in our package we only have test dummy process and we have our object, if we submit this contents to version control repository, it will mean that our package only includes structure, so it will be including this object, and some test process, if other developers install our changes, they will not see contents of lookups and they will not see, register it object as a lookup, so this is a very typical mistake of beginners, they see they are environment, they fill in with data, they think that everything looks okay, and then they just export their package, install for example, in test environment, and then they realize they miss lookup contents and they also miss lookup registering data, so we have technically only two options, how we can transport such data, the most recommended option is item called data, data items a special part of the package, and second option which is also supported, but it's harder to use is askel script, askel script can be used for any kind of data changes or any kind of askel operations that you want to run when your package is installed on some target environment, askel script is much harder to manage, and in general it's much more powerful, and much more dangerous, so you should only use askel script if you have enough askel experience, and I always recommend you to check your code with someone else who also have experience in askel just to make sure you will not do anything dangerous in your database, askel script can be easily used for permanent materials damage for your system, so your creation will not work anymore if you do intentionally some deletive system data, so two options to transport data, data items or askel scripts are recommended to use data items as much as possible, and when you create data item, this tool actually is a step shot of some data records taken from your source developer environment, obviously we need to specify what source object will be used for it, in my case I should select for my object code which I recently used to register, my lookup and lookup section, unfortunately you have to remember this code named by hard, and this object is called lookup, this lookup object includes a list of registr it, objects in our lookup section, and in general we have 121 records here, 121 records, and each single record in the lookup section represents registering of the object as lookup, we need it because probably we would like to be able to go to this lookup section to find corresponding object to open its contents on test environment just to check out that we have everything correctly here, so this registering was done as developer environment and it makes sense to transport it as part of our solution to test and production, such data is saved in a system object named lookup, that's why we go and search for the object named lookup, we can find it by name, by code, and we can also provide some unique name here, for example we can add something useful, reality type class something like this, I do it just to make it unique and good looking and self explanatory, so it will be easy to understand why we created this data item, as you can see system offered us set of columns, but we can also add a couple of more columns here, I'm interested in date of creation, created on column, here in the list of saved columns, data item is a snapshot of data, so we will take this data from our source database and save it as part of our package, bound data taps represent exact records, which will be saved into our data item, so you can manually add such records, in total we have 121 records, but most of them are based product contents, so we do not need to transport based product stuff, we expect it to be present at our target place target database, so we do not need all of them, we can use our created on date column to sort and easily find without user filters, you can also use filters, but I prefer to make it as easy as possible, so we can sort by descending order, by date of creation, order, register lookups, and that's how we can easily find our reality types single record, this is a registering of the reality type object as a lookup, we can only select this data, select button, and that's how we saved only one data row in this data object, then we just click save, and our snapshot of data, which includes only one data row, will be saved into our package now, you see data item is created, this is only registering of an object that's not the contents, so for the contents of the object, when we open it, we have five records here, this is our contents, we need to make one more data item, this is quite easy, add again data, and we select an object, we have to specify object code here, thanks developers, because code is unique, usr, real to type classic, you can easily find it, I prefer to use codes, because they are always unique and system keeps this uniqueness, and titles sometimes are a bit ambitious, especially if you use non-English language, so you may struggle with finding some corresponding title, and I prefer to use codes, okay, we can provide some common suffix just to make sure what we are doing here, if necessary we can add more columns, but the most important of course is bound data, and we can select all the records, all the records we have from source environment, will be saved into our package as a special part, as a data item, and we save it, and now our data item becomes part of our package, now you see stars here, which means our items are not fully saved, so we have to perform download packages to file system action, in order to save our stuff, no need to use camera standard, because it will be recorded, so we'll stop it, okay, so changes were saved on disk, stars disappeared, you can find all the items in our package here, including data part, now you see some data records are saved as a JSON data values, and you can see translations into all our supported 23 languages here, so data items also include translations, and it fully saves on disk, everything is correct, and now we have object and a couple of data items are presented at a distribution of object as a lookup, and a presented contents object, so now our solution is full, and if we export this package as zip archive, then if we import it somewhere on test environment, to work, and user will be able to find our new lookup in the lookup section, user will be able to find its contents, and user will see such data, maybe it's time to practice with git, and let's make one more commit, now you can see a lot of changes, 80 different changes, mainly this is our data parts, also we have new object here, and physically it means big set of files and folders used inside of our package folder, so we can name something like real, t, type, classic, lookup, add it, this is the sense of our change, we perform git commit to our local repository, then we do git pool and push to submit our changes to the common repository, great, everything is done, now common repository also felt such changes, you see three commits, and you can see common history if interesting, now you can see all the changes here, so it will be easy to check previous various current values and so on, so what I need to tell you about data items in addition, what do you know now, data items can be used not only for inserts, they are also used for updates, let me explain what I'm talking about, so originally we have five records for our data, and let's imagine we already exported our change, we imported it somewhere to test and production, and everything is okay, so our solution was successfully delivered to test and production, and our users are happy, but sometimes later probably analysts or business owners decided to do some changes, for example they decided to rename office space into just office, and we can do this only at developer environment, because we need to share all such changes to all other environments including testing production, so such changes should be started from developer environment first, and then someone decided to rename parking lot into just parking, so now we have some changes made at developer environment, and we need to populate them to all other systems, data items can help us with it, but you need to know how to properly set it up, let's open this data item for the contents of our lookup, you can also sort by data of modification to see the most recently updated items first, so we can see this one the most recent, let's open it, now I will tell you a bit more about how system operates with data, so let's imagine such data items are, so such data items is being loaded at target environment, system is capable to prevent duplicates, and it uses key columns to detect presence of the record, which is being processed right now, as you can see we have key or ID, so ID column is set as key, and when system will load within the procedure of loading your package, it will take first row, it will take this ID, and then it will check, do we have such data record at our target database or not? If not, yeah, it's okay, it will just insert all the columns that we have for this data record, and it's not a big deal, not a problem, but if record exists, system is capable to update existing record, and here you will face something which is a bit tricky, and you may fail for the first time, and you will have to look carefully at the settings of your columns, because system will perform update only for columns marked with the first update option, and by default, as you can see, no updates are asked here, so when record will be found, system will just skip it, because no columns should be updated, so if you changed names right here, and you know that such data was already traveled somewhere, and you need to update it, so you go to your corresponds data item, you make sure you set first update option for columns that you need to update, also you may check some other columns if you're not sure, and you also want to update, so you know the source of truth is your developer environment, so if something else was changed at your target system, then you have to update it anyway, so first update is not set by default, if you expect to perform update operation, you should take care about it, and once you do this, your update will work, also I need to tell you that in our real database, now we have office and parking, and if you carefully look here, you will see that we still have old values here, this is a proof of this concept, what I told you previously, that data item is a snapshot of your database contents, taken at a certain moment of time, so when this data item was created, we had older values here, that's why we can see it here, if you want to actualize it to make it actual and read it from your database, you can just click actualize data, when you do this, system will refresh data item contents, and now you see office and parking exactly as in our database now, let's check column settings, correct, and now we can save it, so if you create your data item like this, and if you took care about the first update option, then you changed some source data records in your source database, you should actualize data, make sure your data records are fully properly updated, and then just save it in your package, of course your date and time of the item will be changed, and next time when you export your package and import in some target environment, because of change the date of modification, this item will be processed, and corresponding updates will be performed, the same happens with our system shared with a git, so we need to save everything in file system, then we will commit our changes to our common repository, and it will be an example of how we can do some updates in data and populate it on other environments, now you can see we have only small part of changes here, so we have only some data changes, but they are present, so it will be, look up data updates, or maybe it's better to say that we have a real team type data updates, okay, so we can commit it to push, and that's how our changes will be correctly saved, and it's about updates, you may ask me about the delete scenario, what happens if in our source database, we finally realized that Castle will be never used, and should be deleted from developer environment and for testing production, and fortunately, data items cannot help us to delete such data, so if you really need to remove your data from target environments, you have the only way for this, this is SQL script, so as example I will show you how we can write such script, we can use search by name or by ID, and we can create this SQL script in our package, add SQL script, you should be really, really extremely careful with it, we will provide its name like usr, del, castle, real, tea type, of course in real life you will probably never use this, but this is some like a training example for you, so you can create SQL scripts for some specific needs, installation type determines the way, the moment of time, when your script will be executed in the scope of the package loading procedure, before package is at the very beginning, after package means after new tables will be created and processed, after schema data, its after package data was loaded, and uninstall app is a very rare case when you will need to run some scripts, when your application is removed from the system, so when it be at the very end, after schema data, we are not using backward compatibility, because it has so strict conditions, so it makes your SQL scripts almost useless, and the backward compatible is just an information of property, so we can just keep it off, so I will write some script like delete from usr, real, tea type, classic, this is our name of the object, and then where name equals something like this, so this is an example of a script which intentionally removes some data, and this script will remove nothing if no data found, this is easy example, I do not use ID, and I'm using this three name just to make it simple and easy to understand, such scripts are dangerous, so you should be very careful in doing such things, you can validate it, you can check, okay no problems, you can save such script, and also, which is interesting, you can even run such scripts on your environment, as you can see, status needs to be installed in database means that this script was not executed at this database, so if we run it now, you can go to actions in right part here, then install, which means run as go script, you can do it carefully, and if script finishes with an error, it still will have status, and also you will see its properties, and last error message text will show you last error, which happened with running this script, in my case it was successful, so my script executed with no errors, and now we can check our lookup columns, lookup contents, now you see castle disappeared, so it was physically removed from our source database, and also when this script will go to our package and will be executed on some target environments, also the script will remove necessary records from our target environments, you should be careful because if someone already started to use such data that you plan to remove, you will have some cascade problems with it, so you will have referential integrity exceptions, you will need to look at connected data, and ideally, you should think of it in your script, you should process such scenarios, and you should think of what to do with connected data entities, and also the script is not saved on disk, so if I will click download packages to the file system, I will have everything saved on disk, our session comes to an end today, and it looks like we have no enough time to work with a complex example of virtual objects, and I will show it a bit later, but today I plan to make a couple of more operational steps for us, so now we saved everything on disk, and later we will start with a building of our new applications, and we will need some base product parts which are very common to be used, I'm talking about contacts and accounts, and also we need some additional tools, so my plan is at the end of the day session, to show you how you can add some necessary, frequently used marketplace add-ons that will really help us to operate in future, so here my example with the lookup is almost done, and also when we removed some data from the lookup, you see our snapshot still keeps this castle, so this castle is no longer present on our database, and it makes sense to actualize data, now you see I removed it, even though if I do not remove it, my item was not changed, so it's not correct, I think that if I keep some data here, which is not present in real database, this is mistake, so I should avoid such mistakes, I should actualize data, not to keep any non-existent records in my contents of the package, so actualized data saved it, now everything is consistent, so my castle fully disappears from my contents here, and we can also save it again to disk, so my plan for today, for today's session and is to show you how to install some necessary marketplace add-ons into your environment, we will need it later, so I have opportunity to show you, let's go to settings, then go to application hub, this is a special part of managing our system with cell code applications, I will discuss and explain what application is tomorrow, currently we will use this application hub only for inserts, so only to add some useful items into our environment, so add new application, marketplace powered, so we can find a word of application there, and also we have some base product tools made by creation, now I need customers 360, because it enables contacts and accounts section in my system, so simply speak and when you install customers 360, you will have new sections in your system, you will have accounts and contacts designed in 3DOM UI, this is very useful, very commonly used, almost any project implementation on creation, uses contacts and accounts, so we will definitely need it, out of the box, stuff of our studio system does not include this, I will explain why, a bit later when we will talk about composable apps, so let's install customer 360, there is a high degree of integration and seamless connection, between my local website and marketplace.creasio.com, so I just click install, you see some automation works, it asks me to confirm, okay, no worries confirm, one more confirmation about app that I plan to install, anyway confirm where it be, so it will take just several seconds, possibly up to 30 seconds to install this app, and as a result, expect to see accounts and contacts sections added to my system, there will be displayed in 3DOM UI, so you will see the first 3DOM UI page at our sessions today, and the main reason why I do this is I need contacts and accounts in my future examples, when you added something to your app, it makes sense to download installation logs, this includes a lot of technical information, but sometimes it could be really helpful, and this installation logs can be kept for some time on your disk, just for future reference, because even in case of successful installation, sometimes you may face situations where you see something that you do not expect, and working with such logs can be efficient to check it out and to see some technical details about your installation, at least we can see how much time it took, so 1437 to 1510, it looks like 33 seconds, so it took on the 33 seconds to install this app, and all the technical steps that were done here are listed, so if interested you can see and find no warnings, no errors, you can see even some SQL scripts were installed, and also I just forgot to say that SQL script is database dependent, so when I created my own script, it was only for, let me show the properties here, it only for Microsoft SQL type of the database, if you need a similar script for Postgre, you have to create another SQL script, that's why base creation product, if you go filter by SQL script only, it always includes three types of SQL scripts for each business action that we need, for example, let me scroll down and find any kind of procedures, I create on the channel tables for Postgre, separately for Oracle, separately for Microsoft SQL, three different SQL syntaxes are supported, and that's why if your solution is intended to be supporting several different database engines, you have to make several scripts for it, but mainly when you develop your projects, you will know for sure target database types, so you only, you can focus only on corresponding target database type, it could be most frequently, it could be Microsoft SQL or Postgre, if you expect to deploy your solution in Creasio Cloud, it's highly likely that you will have Postgre SQL in the Cloud condition, so it makes sense to use the same type of the database for your own local development, but it's not mandatory, if you develop a Microsoft SQL and then deploy your solution on Postgre, it will also work, if you support all necessary database dependent settings like necessary scripts also for Postgre, not only for Microsoft SQL. Main part of configuration is not database specific, so when you develop an object, it will normally work in any type of supported databases. Okay, it was just a distraction, so let's go back to our logs, now you see it took only 33 seconds to install, it's interesting to see results, probably we need to reload main page just to suppress any kind of browser cache issues that possibly can appear, so now we can see a bit more workplaces, originally we had only one studio, now we have OAPS workplace studio and we have new one, which is called customer 360, we have context, the rhythm UI section here, you can easily check if the section is freedom UI or not, because only freedom UI section offers you, they offers you to shrink, list columns easily, in classic UI you cannot do this, so let's go for example into lookup section, you can't do this, you only can shrink columns by going to setup summaries, no, no, no, two setup columns that filled to display and that's how you can do such shrink manually, in freedom UI you can do it easily, so that's how you can easily detect which type of UI you are working with, but also you can remember position of buttons in freedom UI, managing buttons are usually the right part, and fonts are different, the style of the list is a bit different, a bit different functionality of buttons in list, and you can see you can hide and freeze buttons, freeze columns in list, so freedom UI is much more rich with UI capabilities and it's considered as a future of creation, and classic UI is now considered as a legacy which has a lot of implementation, so probably, southens or even tens of southens, different solutions are currently running all over the world in classic UI, and so creation supports both types of UI, so far. This is example of a classic UI, sorry, freedom UI list, you can open edit page, you will see page reach of controls with oh no no no no, this is a classic UI stuff, so this is still an example of a, it's not a glitch, it's kind of behavior connected with a cache and server side, so we have to log out, we're going to log in, then, I'm going to use my name, what's happened with my saved users, yeah, supervisor, okay, I want to use this, okay, probably developers changed some, we have an login page which now made it a bit harder to use saved passwords and browser, okay, so I logged in again, contact section, now you will see edit page, there's no any cache issue, this is example of a freedom UI, edit page, you still see some freedom UI capabilities, like possibility to shrink lists, more reach components with covers, customizations, and so on, but so, we'll study how to build such pages, you will know, and if some one of you already passed our customization course, you already know how to do such things, so this is example of a freedom UI user interface, accounts also shown as a list and edit page, so context represent physical persons, with names, emails, addresses, and so on, accounts represent companies, like Samsung, like Tesla, like others, so some companies that you may work with and you need to keep information about them in your system, this was example of customer C16 stored into our app, into our system, I have a couple more tools to be installed, let me quickly show it for you, it would be end of the day session, so not so hard, and still a bit strange, with application hub is empty here with me reward this page, because something unusual, yes, now it's better, now you see customer C360 is already in sold, and we will study what an application is, how it works, now we will just install a couple more apps from our market face, because we will need them in future examples, so market face powered, here I need tool named data binding, I will search by the word bind, easily finding this data binding tool, select it, click install button, thanks for automation here, confirm and install, this installation will take a bit longer, because it will need to compile my environment during this installation process, so this takes a bit longer, but it's still okay, and I need this data binding tool, because it helps to create data items easily, so data items can be automated, and you can create them with several clicks, and it's easier than to make everything manual, so data binding tool takes some time to install, it's pretty old tool, I think it exists maybe for five years, and it's designed for an older version of creation, and it also has a lot of support in classic UI, but now mainly we need it to support our creator of data items, and this help, so this tool helps to save our time and to reduce boring part of the work, you can download installation web to see how long it took to load this, let's check it out, our session is almost over, so, you see 24, 15, then 25, 16, it took like one minute and one second, and like 61 seconds took to install this solution, no errors, no any warnings here, perfect, everything is okay, everything is okay, so our app was installed, and one more final thing, so we can rule this, and you see data binding item, one more item which I want to install from Marketplace is a special tool called maintenance tools for creation, maintenance, maintenance tools was made by partner, which previously was named Syso, you probably saw its icon, now it's named Neo Technologies from Switzerland, and they use just a standard creation API, and this tool has two major functions, clear, ready sketch, but you don't really need it often, but the most important and useful feature is restart the app, restart application, unfortunately, creation doesn't have this function out of the box available in user interface, and partners from Neo Technologies decided to fix this issue, and they just made a UI button to do this, so this app simply adds a couple of buttons into our creation user interface to make it easy to restart the app or to clear ready sketch, I will use this restart app, we will need it, we cannot avoid it unfortunately, and in our examples you will see it, so you see 27.08 started, 27.18 finished, so it took only 10 seconds for installation, you probably will ask me why am I so obsessed with installation time, this is important because this is 10 seconds of downtime for your system, if you do some kind of installations on your production, your end users will not be able to operate with your system during this installation procedure, so we still have non-zero downtime, and this is important to track along it took for creation to install something, especially if you do it in the middle of working hours, so my installation was successful, we can also go back again to application hub, now you see one more app, InternetStools, and I can show you where this maintenance tools can be found, it will be into our settings page, physically it's called system designer, but now developers decided just to call settings, at the end of this page you will see new buttons, originally we had only advanced settings, but also now we have clear ready and restart application, we will need restart application later, unfortunately some study, like learning examples will require this restart application action, and we cannot avoid it in some cases, you will see later, and today session is over, thank you for your time, today we moved forward with working objects, we discussed how to build data items, how to operate with lookups, we also worked with Git, and tomorrow I plan to show you one more example with data this view, and we will move on with building user interface, I've went to focus on freedom UI, mainly on freedom UI, and if we will have some significant demand on QSQI stuff, for example you expect to work or support existing QSQI solutions, we will have to take time also to discuss some QSQI tools, but mainly my focus will be on freedom UI and programming inside of it, so thank you for your time today, our session is over, in case if you have any questions feel free to ask now, your homework as usual is to watch this video to represent all the steps or produce, all the steps for today session, working with your package, creating your lookup, your object, register it as lookup, and practice with data items, so this will be your homework, and tomorrow we will continue doing more complicated things, thank you, thank you for your time, questions Padi? Yeah, I do, just with the apps installed, are they installed then similar to how you would set up a package on the backend? Oh yes, physically they represent as packages, if you reload our configuration section, you will see that we have a couple of more packages here, and for example the package named GLB data binding represents our data binding tool, and the maintenance tools, let me find it, it's called CSL maintenance tools, is changes, customizations in our settings page to enable a couple of buttons, and customars 360, C30, 300, okay, CRT, customars 360, it's surprisingly low, I need a bit more, okay, let's search just for 360, yeah, customars 360 represents three packages in one archive, so what will study how application works, how it is created, and what is inside tomorrow, you will see that application finally keeps some packages behind it, and when we load such applications physically, we load one or several packages, here you see customars 360, it includes several packages, so that's how it works, and to physically application is a bit artificial thing, physical re-operators packages, so anyway, you can see everything which was customized here as a package and the package contents inside of configuration section, thank you, thank you, any other questions please, thank you, a valid ID mystery, yes, Brazil, thank you, when I am going to advance sitting, the configuration page doesn't work, it just reloads, it's because you're probably using Windows Home, if you use Windows home, you have to close previous page, in this case configuration page will be working normally, yeah, let me, I have no options how to make it better, unfortunately, probably you can consider an identity rule, you can upgrade to pro, Windows pro version, in this case you will have no such issue, this is kind of limitation, connect it to this web socket, and this is something that makes home different from pro, and it's not so comfortable, I agree, thank you, thank you, okay, and it looks like Tushar, had a question, yes, Tushar please, my question is like if we have a new lookup, like if we have three more lookups and we want how we can then update it, and like a system designer, do we have to create the data file again, or we can update in the existing data file, which you are sure, so probably you are talking about new data records added to existing lookups table, am I right? No, like if you, suppose if total number of lookups are 121, right now, if we add like five new lookups, then how we can bind those? Oh, if you have five new lookups, you have finally to create 10 new data items, or maybe less than 10, because one data item for lookups can include many records for registering, so the minimum amount of data items in your case will be 6, 1, 4, 5 lookup records, and 5 others for each separate data contents of your lookups. So simply speaking, any lookup should include data item for registering of the lookup and data item for the contents of the lookup. In this case, it will be the most comfortable for your end users, because they will always find all your lookups in production and lookups section, and they will be able to open it to see their contents normally, and data items guarantee such transport of records. Thanks. Thank you, Toshara. And that's all for today. If you will have more questions and understand that probably questions will appear later when you try to practice. So you may use my email, these send me messages, I will try to find time to answer you. So our tomorrow session will be as usual, and we will continue working with objects, and we will start to work with user interface programming. Thank you very much for your time. See you tomorrow. Bye. Good luck. See you tomorrow. Bye. Thank you. Thank you. Bye.",
    "chunk_type": "paragraph",
    "chunk_index": 0,
    "metadata": {
      "source_type": "video_transcript",
      "video_file": "Recording2.mp4",
      "duration": 8416.04
    },
    "word_count": 17806,
    "token_count": 20501,
    "context": {
      "heading": null,
      "paragraph_count": 1,
      "position_in_document": 0
    }
  }
]