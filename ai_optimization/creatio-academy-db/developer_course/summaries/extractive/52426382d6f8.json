{
  "summary_id": "52426382d6f8",
  "content_id": "c7028f12cf1e",
  "summary_type": "extractive",
  "summary_text": "Just to remind you, classic UI is a special old type of user interface, which you can still find in many system sections like system users, like system settings, like web services, you will see some specifics and no possibility to shrink columns easily. And step two is to use any kind of version control systems to operate with set of your files and folders from your disk in order to deliver changes in order to transport your changes from files and folders to some common repository. Also you can find in main object that some inherited properties are shown here, ID, property which means key field, so this is not perfect title of the property should be named key field and ID is used as a key field and displayed values also not a perfect title, previously it was called primary displayed value, so the main text column which is shown in drop-down lists of lookups, so name will be used for this purpose but you can change if you want. Now any other special properties, we have some event handling made for this inherited from parent one, we will study event handling a bit later, so what do you need to know now when you do inheritance from base lookup, you automatically receive legacy of all columns that are intended to be used inside of lookups and usually it's enough, so usually you can create just code, title, inherit from base lookup and then save and publish and your object is ready. In my case I want to present and show you some additional features that could be interesting and also examples of how you can make your own custom columns in creation, so we will go to columns list and obviously we can add our own columns to the object, we have plenty of options for different database types, a lot of text options, the minimum supported is text 50 characters, then we have 250, 500, we have unlimited events, we have rich text which supports fonts, colors and styles like italic, underscore, etc. We have special texts for phone numbers, web links, emails and URLs and we have encrypted strings to keep passwords safely which will be not displayed as a text will be always displayed as a set of stars and we're rarely used CRC type which is a collision integer and it's used for checks, so it's like checks on columns, I never faced a working example how we can actually use it so just something like bizarre thing that possibly you will never use in your practice, so number is obviously integer and several types of decimals, currency is also decimal with two digits after decimal point, the difference from standard decimal is that standard decimal is 18 digits and two after decimal point, currency is 20 digits and two after decimal point, so 20 in total, two after decimal point, that's why we have so different but you see we can choose any necessary precision for the four-year solutions, okay date and time, quite of those, we have date time value, separately date, separately time, some other types like Boolean, like unique identifiers, like image link or color selection column file can be saved and lookups, lookups are mainly, so they are generally used and based on unique identifiers but lookups also keep preferential integrity, so when you have a lookup column system creates foreign key for you, so it keeps referential integrity which will not allow you to save into lookup column any value which is not faced in your lookup table, so we can try to make some examples, like make a new text column named code, title can be code, text is 250 and as example I can show you how default values can work for us, how we can make auto numbering, so we can search for default value and we can set auto number option, we can say prefix like CD which stands for code and number of digits are divided with two, first one will be CD01, CD02 and up to CD99 and then we'll have the next number, so XCD100 and so on, this is auto numbering which works pretty well and it doesn't require any programming, so this is a no code tool to make automatic numbering in your lines when you when user import ads data, that's how we can do this and if necessary can use custom indexing, you can also make your own custom indexes and even complex indexes, unique indexes can be added but generally creation takes care about indexing by its own quite well, it automatically creates indexes for lookup columns, so you probably will not face any significant performance issues in objects and data tables made by creation, so once we finished setup of our object we have to save it, save means saving only meta data, so inner data format to keep information about our configurable item, this type of item is also inherited from schema but the word schema I think it's hard to understand, so let's say configurable item which will be closer to its meaning and I think it's easier for you, so when we saved this item it will be shown in our package contents, now you can see database update required, so object can be applied to the database but it's not performed each time you save, only when you click publish, publish means apply changes to current application server and current database, in our case apply changes means create new table with corresponding set of columns and provide necessary column settings and everything should be well done at the database to make our object fully operational, if we do not publish our object will not be able to use this object in our system, so publish is necessary to make our object operational and useful for us, let's do this, some years ago publish took a lot of time, it may took up to one minute of time, now this operation is well automated and now we have no serious reasons to separate, save and publish also when you click publish save is performed automatically, so you may just use publish button, forget about save button and it will work for you because publish now works really fast, okay so when we finished with it we can close our page, by the way this page is called object editor or object designer and now we have our object status is okay, so you see it's applied to the database, we still have a C star which means not everything was saved on this but at this moment our object is already working, so it can be used for us and we can try to use it in our environment, let me show you how we can use it, we can go to studio work place, find lookups section, as you can see we have 120 existing lookups, one of the recent ones, you can see something strange, there is no name here but if we sort by date of creation, so this is a list of registered lookups and we can see what recent registrings were done, like white list of pages, open intersections, access to tag, your aunties or something like base product functionality, recently added here, so we can register our object that we created as lookup in order to make it easily managed and we can look at it and we can even fill it in with some data, so when we click new lookup it doesn't create new table, new lookup means register, existing object as lookup, our object is called reality type, we can name custom, we can provide custom title of this lookup, so name is separate from object as you can see, and we can save it, so this operation is just for registering object as lookup, once we did it, we can click open content and that's how we can manage our lookup contents, the easiest way to manage object data is to register any object as a lookup, then you will be able to see its contents, so we can create new record here and we can manually type some data, like first one, reality type which we work with, it will be probably house, so it's name private house, we can save it, this is so called editable list and we are not using any separate edit page for it, so we just manage data directly in this list, another one will be apartment, as you can see numbering works for us, automatically the no code tool, thanks developers for this, you can also use description, if you want, but i'm not really needed, so we can also add more reality types, what else, it could be office space, it could be parking lot, and something very unusual like a castle, it's just an example and i also wanted to show you some additional behavior here with a numbering, so let's imagine you try to create new one, but then no data, or something else, so you think that oh you don't want to create it, you see the code was generated, but then you just cancel, okay, if you create one more, you see the number goes on, you cancel, if you create one more, you see numbering is going on, and it will be not rolled back, the reason of why it performs, so when it generates, system does not know, are you planning to save it or not, so it generates new number, keeps, currently created number somewhere in the database, and so called sequence in the database structure, and then we have no option to roll it back, because while we are inputting such data, someone else also may create new records, so if system is expected to be used by thousands of users, we have no option to easily roll back such numbers, but it's not a big problem, even if you have some gaps and missing numbers, it's not a problem, really, so you see that numbering is generated using database tools, this is extremely reliable, and physically sequence database object is used for it, bus is telling us about an appointment, and we'll watch the video, thank you bus, see you tomorrow, thank you for your message, any other questions, please, you're welcome at any time, so now you understand, we input some data here, this data is physically saved in our real database, let me show it for you, example select ID, name, ROM, USR, real, T, type, classic, this is the name of my object, I expect to see the name, the same name of my data table, now you can see the same five records with some IDs are created, I can also search for, I created on, and also USR code, so here are my columns, you can see you can select all the data, so this is physical data saved in my database, it's pretty simple, and of course when you develop your big project, you will not pay so much attention to every single lookup, you will do it in much more automated way, but this is an example which will let you understand and will make better feeling of what object is and how it works, that's why we discuss it in so technical details, if you need to change something in your object, you can open it for editing, you can find corresponding proper to change it easily, if necessary, you can customize your columns, you may rename some columns, you can add the new columns, for existing columns you can slightly change their properties, it will be not possible to change the column code, but you can change column title if you want, so for an inherited columns, there are some limitations on what is available for you for change, so generally speaking you can manage your object, you can change them, then you can say even publish, that's how it will be applied, in big scale solutions, you will create tens of different lookups and create your escapeable to help you with it with automation of lookup creation using application hub tools or using section wizard for classic UI, so it will be not so boring each time when you create new object, this is technical right now just because we need some practice, we need to look at object structure, so okay we have our object ready, we have some data here, so how we can share it with our team members or how we can deliver it to test environment, of course we need to download packages to file system, if we want to submit everything to repository, but here is very frequent mistake that a lot of the gainers usually do, this will be about data part, so saving anything to disk here is okay, and in our package we only have test dummy process and we have our object, if we submit this contents to version control repository, it will mean that our package only includes structure, so it will be including this object, and some test process, if other developers install our changes, they will not see contents of lookups and they will not see, register it object as a lookup, so this is a very typical mistake of beginners, they see they are environment, they fill in with data, they think that everything looks okay, and then they just export their package, install for example, in test environment, and then they realize they miss lookup contents and they also miss lookup registering data, so we have technically only two options, how we can transport such data, the most recommended option is item called data, data items a special part of the package, and second option which is also supported, but it's harder to use is askel script, askel script can be used for any kind of data changes or any kind of askel operations that you want to run when your package is installed on some target environment, askel script is much harder to manage, and in general it's much more powerful, and much more dangerous, so you should only use askel script if you have enough askel experience, and I always recommend you to check your code with someone else who also have experience in askel just to make sure you will not do anything dangerous in your database, askel script can be easily used for permanent materials damage for your system, so your creation will not work anymore if you do intentionally some deletive system data, so two options to transport data, data items or askel scripts are recommended to use data items as much as possible, and when you create data item, this tool actually is a step shot of some data records taken from your source developer environment, obviously we need to specify what source object will be used for it, in my case I should select for my object code which I recently used to register, my lookup and lookup section, unfortunately you have to remember this code named by hard, and this object is called lookup, this lookup object includes a list of registr it, objects in our lookup section, and in general we have 121 records here, 121 records, and each single record in the lookup section represents registering of the object as lookup, we need it because probably we would like to be able to go to this lookup section to find corresponding object to open its contents on test environment just to check out that we have everything correctly here, so this registering was done as developer environment and it makes sense to transport it as part of our solution to test and production, such data is saved in a system object named lookup, that's why we go and search for the object named lookup, we can find it by name, by code, and we can also provide some unique name here, for example we can add something useful, reality type class something like this, I do it just to make it unique and good looking and self explanatory, so it will be easy to understand why we created this data item, as you can see system offered us set of columns, but we can also add a couple of more columns here, I'm interested in date of creation, created on column, here in the list of saved columns, data item is a snapshot of data, so we will take this data from our source database and save it as part of our package, bound data taps represent exact records, which will be saved into our data item, so you can manually add such records, in total we have 121 records, but most of them are based product contents, so we do not need to transport based product stuff, we expect it to be present at our target place target database, so we do not need all of them, we can use our created on date column to sort and easily find without user filters, you can also use filters, but I prefer to make it as easy as possible, so we can sort by descending order, by date of creation, order, register lookups, and that's how we can easily find our reality types single record, this is a registering of the reality type object as a lookup, we can only select this data, select button, and that's how we saved only one data row in this data object, then we just click save, and our snapshot of data, which includes only one data row, will be saved into our package now, you see data item is created, this is only registering of an object that's not the contents, so for the contents of the object, when we open it, we have five records here, this is our contents, we need to make one more data item, this is quite easy, add again data, and we select an object, we have to specify object code here, thanks developers, because code is unique, usr, real to type classic, you can easily find it, I prefer to use codes, because they are always unique and system keeps this uniqueness, and titles sometimes are a bit ambitious, especially if you use non-English language, so you may struggle with finding some corresponding title, and I prefer to use codes, okay, we can provide some common suffix just to make sure what we are doing here, if necessary we can add more columns, but the most important of course is bound data, and we can select all the records, all the records we have from source environment, will be saved into our package as a special part, as a data item, and we save it, and now our data item becomes part of our package, now you see stars here, which means our items are not fully saved, so we have to perform download packages to file system action, in order to save our stuff, no need to use camera standard, because it will be recorded, so we'll stop it, okay, so changes were saved on disk, stars disappeared, you can find all the items in our package here, including data part, now you see some data records are saved as a JSON data values, and you can see translations into all our supported 23 languages here, so data items also include translations, and it fully saves on disk, everything is correct, and now we have object and a couple of data items are presented at a distribution of object as a lookup, and a presented contents object, so now our solution is full, and if we export this package as zip archive, then if we import it somewhere on test environment, to work, and user will be able to find our new lookup in the lookup section, user will be able to find its contents, and user will see such data, maybe it's time to practice with git, and let's make one more commit, now you can see a lot of changes, 80 different changes, mainly this is our data parts, also we have new object here, and physically it means big set of files and folders used inside of our package folder, so we can name something like real, t, type, classic, lookup, add it, this is the sense of our change, we perform git commit to our local repository, then we do git pool and push to submit our changes to the common repository, great, everything is done, now common repository also felt such changes, you see three commits, and you can see common history if interesting, now you can see all the changes here, so it will be easy to check previous various current values and so on, so what I need to tell you about data items in addition, what do you know now, data items can be used not only for inserts, they are also used for updates, let me explain what I'm talking about, so originally we have five records for our data, and let's imagine we already exported our change, we imported it somewhere to test and production, and everything is okay, so our solution was successfully delivered to test and production, and our users are happy, but sometimes later probably analysts or business owners decided to do some changes, for example they decided to rename office space into just office, and we can do this only at developer environment, because we need to share all such changes to all other environments including testing production, so such changes should be started from developer environment first, and then someone decided to rename parking lot into just parking, so now we have some changes made at developer environment, and we need to populate them to all other systems, data items can help us with it, but you need to know how to properly set it up, let's open this data item for the contents of our lookup, you can also sort by data of modification to see the most recently updated items first, so we can see this one the most recent, let's open it, now I will tell you a bit more about how system operates with data, so let's imagine such data items are, so such data items is being loaded at target environment, system is capable to prevent duplicates, and it uses key columns to detect presence of the record, which is being processed right now, as you can see we have key or ID, so ID column is set as key, and when system will load within the procedure of loading your package, it will take first row, it will take this ID, and then it will check, do we have such data record at our target database or not? If not, yeah, it's okay, it will just insert all the columns that we have for this data record, and it's not a big deal, not a problem, but if record exists, system is capable to update existing record, and here you will face something which is a bit tricky, and you may fail for the first time, and you will have to look carefully at the settings of your columns, because system will perform update only for columns marked with the first update option, and by default, as you can see, no updates are asked here, so when record will be found, system will just skip it, because no columns should be updated, so if you changed names right here, and you know that such data was already traveled somewhere, and you need to update it, so you go to your corresponds data item, you make sure you set first update option for columns that you need to update, also you may check some other columns if you're not sure, and you also want to update, so you know the source of truth is your developer environment, so if something else was changed at your target system, then you have to update it anyway, so first update is not set by default, if you expect to perform update operation, you should take care about it, and once you do this, your update will work, also I need to tell you that in our real database, now we have office and parking, and if you carefully look here, you will see that we still have old values here, this is a proof of this concept, what I told you previously, that data item is a snapshot of your database contents, taken at a certain moment of time, so when this data item was created, we had older values here, that's why we can see it here, if you want to actualize it to make it actual and read it from your database, you can just click actualize data, when you do this, system will refresh data item contents, and now you see office and parking exactly as in our database now, let's check column settings, correct, and now we can save it, so if you create your data item like this, and if you took care about the first update option, then you changed some source data records in your source database, you should actualize data, make sure your data records are fully properly updated, and then just save it in your package, of course your date and time of the item will be changed, and next time when you export your package and import in some target environment, because of change the date of modification, this item will be processed, and corresponding updates will be performed, the same happens with our system shared with a git, so we need to save everything in file system, then we will commit our changes to our common repository, and it will be an example of how we can do some updates in data and populate it on other environments, now you can see we have only small part of changes here, so we have only some data changes, but they are present, so it will be, look up data updates, or maybe it's better to say that we have a real team type data updates, okay, so we can commit it to push, and that's how our changes will be correctly saved, and it's about updates, you may ask me about the delete scenario, what happens if in our source database, we finally realized that Castle will be never used, and should be deleted from developer environment and for testing production, and fortunately, data items cannot help us to delete such data, so if you really need to remove your data from target environments, you have the only way for this, this is SQL script, so as example I will show you how we can write such script, we can use search by name or by ID, and we can create this SQL script in our package, add SQL script, you should be really, really extremely careful with it, we will provide its name like usr, del, castle, real, tea type, of course in real life you will probably never use this, but this is some like a training example for you, so you can create SQL scripts for some specific needs, installation type determines the way, the moment of time, when your script will be executed in the scope of the package loading procedure, before package is at the very beginning, after package means after new tables will be created and processed, after schema data, its after package data was loaded, and uninstall app is a very rare case when you will need to run some scripts, when your application is removed from the system, so when it be at the very end, after schema data, we are not using backward compatibility, because it has so strict conditions, so it makes your SQL scripts almost useless, and the backward compatible is just an information of property, so we can just keep it off, so I will write some script like delete from usr, real, tea type, classic, this is our name of the object, and then where name equals something like this, so this is an example of a script which intentionally removes some data, and this script will remove nothing if no data found, this is easy example, I do not use ID, and I'm using this three name just to make it simple and easy to understand, such scripts are dangerous, so you should be very careful in doing such things, you can validate it, you can check, okay no problems, you can save such script, and also, which is interesting, you can even run such scripts on your environment, as you can see, status needs to be installed in database means that this script was not executed at this database, so if we run it now, you can go to actions in right part here, then install, which means run as go script, you can do it carefully, and if script finishes with an error, it still will have status, and also you will see its properties, and last error message text will show you last error, which happened with running this script, in my case it was successful, so my script executed with no errors, and now we can check our lookup columns, lookup contents, now you see castle disappeared, so it was physically removed from our source database, and also when this script will go to our package and will be executed on some target environments, also the script will remove necessary records from our target environments, you should be careful because if someone already started to use such data that you plan to remove, you will have some cascade problems with it, so you will have referential integrity exceptions, you will need to look at connected data, and ideally, you should think of it in your script, you should process such scenarios, and you should think of what to do with connected data entities, and also the script is not saved on disk, so if I will click download packages to the file system, I will have everything saved on disk, our session comes to an end today, and it looks like we have no enough time to work with a complex example of virtual objects, and I will show it a bit later, but today I plan to make a couple of more operational steps for us, so now we saved everything on disk, and later we will start with a building of our new applications, and we will need some base product parts which are very common to be used, I'm talking about contacts and accounts, and also we need some additional tools, so my plan is at the end of the day session, to show you how you can add some necessary, frequently used marketplace add-ons that will really help us to operate in future, so here my example with the lookup is almost done, and also when we removed some data from the lookup, you see our snapshot still keeps this castle, so this castle is no longer present on our database, and it makes sense to actualize data, now you see I removed it, even though if I do not remove it, my item was not changed, so it's not correct, I think that if I keep some data here, which is not present in real database, this is mistake, so I should avoid such mistakes, I should actualize data, not to keep any non-existent records in my contents of the package, so actualized data saved it, now everything is consistent, so my castle fully disappears from my contents here, and we can also save it again to disk, so my plan for today, for today's session and is to show you how to install some necessary marketplace add-ons into your environment, we will need it later, so I have opportunity to show you, let's go to settings, then go to application hub, this is a special part of managing our system with cell code applications, I will discuss and explain what application is tomorrow, currently we will use this application hub only for inserts, so only to add some useful items into our environment, so add new application, marketplace powered, so we can find a word of application there, and also we have some base product tools made by creation, now I need customers 360, because it enables contacts and accounts section in my system, so simply speak and when you install customers 360, you will have new sections in your system, you will have accounts and contacts designed in 3DOM UI, this is very useful, very commonly used, almost any project implementation on creation, uses contacts and accounts, so we will definitely need it, out of the box, stuff of our studio system does not include this, I will explain why, a bit later when we will talk about composable apps, so let's install customer 360, there is a high degree of integration and seamless connection, between my local website and marketplace.creasio.com, so I just click install, you see some automation works, it asks me to confirm, okay, no worries confirm, one more confirmation about app that I plan to install, anyway confirm where it be, so it will take just several seconds, possibly up to 30 seconds to install this app, and as a result, expect to see accounts and contacts sections added to my system, there will be displayed in 3DOM UI, so you will see the first 3DOM UI page at our sessions today, and the main reason why I do this is I need contacts and accounts in my future examples, when you added something to your app, it makes sense to download installation logs, this includes a lot of technical information, but sometimes it could be really helpful, and this installation logs can be kept for some time on your disk, just for future reference, because even in case of successful installation, sometimes you may face situations where you see something that you do not expect, and working with such logs can be efficient to check it out and to see some technical details about your installation, at least we can see how much time it took, so 1437 to 1510, it looks like 33 seconds, so it took on the 33 seconds to install this app, and all the technical steps that were done here are listed, so if interested you can see and find no warnings, no errors, you can see even some SQL scripts were installed, and also I just forgot to say that SQL script is database dependent, so when I created my own script, it was only for, let me show the properties here, it only for Microsoft SQL type of the database, if you need a similar script for Postgre, you have to create another SQL script, that's why base creation product, if you go filter by SQL script only, it always includes three types of SQL scripts for each business action that we need, for example, let me scroll down and find any kind of procedures, I create on the channel tables for Postgre, separately for Oracle, separately for Microsoft SQL, three different SQL syntaxes are supported, and that's why if your solution is intended to be supporting several different database engines, you have to make several scripts for it, but mainly when you develop your projects, you will know for sure target database types, so you only, you can focus only on corresponding target database type, it could be most frequently, it could be Microsoft SQL or Postgre, if you expect to deploy your solution in Creasio Cloud, it's highly likely that you will have Postgre SQL in the Cloud condition, so it makes sense to use the same type of the database for your own local development, but it's not mandatory, if you develop a Microsoft SQL and then deploy your solution on Postgre, it will also work, if you support all necessary database dependent settings like necessary scripts also for Postgre, not only for Microsoft SQL. Okay, it was just a distraction, so let's go back to our logs, now you see it took only 33 seconds to install, it's interesting to see results, probably we need to reload main page just to suppress any kind of browser cache issues that possibly can appear, so now we can see a bit more workplaces, originally we had only one studio, now we have OAPS workplace studio and we have new one, which is called customer 360, we have context, the rhythm UI section here, you can easily check if the section is freedom UI or not, because only freedom UI section offers you, they offers you to shrink, list columns easily, in classic UI you cannot do this, so let's go for example into lookup section, you can't do this, you only can shrink columns by going to setup summaries, no, no, no, two setup columns that filled to display and that's how you can do such shrink manually, in freedom UI you can do it easily, so that's how you can easily detect which type of UI you are working with, but also you can remember position of buttons in freedom UI, managing buttons are usually the right part, and fonts are different, the style of the list is a bit different, a bit different functionality of buttons in list, and you can see you can hide and freeze buttons, freeze columns in list, so freedom UI is much more rich with UI capabilities and it's considered as a future of creation, and classic UI is now considered as a legacy which has a lot of implementation, so probably, southens or even tens of southens, different solutions are currently running all over the world in classic UI, and so creation supports both types of UI, so far. This is example of a classic UI, sorry, freedom UI list, you can open edit page, you will see page reach of controls with oh no no no no, this is a classic UI stuff, so this is still an example of a, it's not a glitch, it's kind of behavior connected with a cache and server side, so we have to log out, we're going to log in, then, I'm going to use my name, what's happened with my saved users, yeah, supervisor, okay, I want to use this, okay, probably developers changed some, we have an login page which now made it a bit harder to use saved passwords and browser, okay, so I logged in again, contact section, now you will see edit page, there's no any cache issue, this is example of a freedom UI, edit page, you still see some freedom UI capabilities, like possibility to shrink lists, more reach components with covers, customizations, and so on, but so, we'll study how to build such pages, you will know, and if some one of you already passed our customization course, you already know how to do such things, so this is example of a freedom UI user interface, accounts also shown as a list and edit page, so context represent physical persons, with names, emails, addresses, and so on, accounts represent companies, like Samsung, like Tesla, like others, so some companies that you may work with and you need to keep information about them in your system, this was example of customer C16 stored into our app, into our system, I have a couple more tools to be installed, let me quickly show it for you, it would be end of the day session, so not so hard, and still a bit strange, with application hub is empty here with me reward this page, because something unusual, yes, now it's better, now you see customer C360 is already in sold, and we will study what an application is, how it works, now we will just install a couple more apps from our market face, because we will need them in future examples, so market face powered, here I need tool named data binding, I will search by the word bind, easily finding this data binding tool, select it, click install button, thanks for automation here, confirm and install, this installation will take a bit longer, because it will need to compile my environment during this installation process, so this takes a bit longer, but it's still okay, and I need this data binding tool, because it helps to create data items easily, so data items can be automated, and you can create them with several clicks, and it's easier than to make everything manual, so data binding tool takes some time to install, it's pretty old tool, I think it exists maybe for five years, and it's designed for an older version of creation, and it also has a lot of support in classic UI, but now mainly we need it to support our creator of data items, and this help, so this tool helps to save our time and to reduce boring part of the work, you can download installation web to see how long it took to load this, let's check it out, our session is almost over, so, you see 24, 15, then 25, 16, it took like one minute and one second, and like 61 seconds took to install this solution, no errors, no any warnings here, perfect, everything is okay, everything is okay, so our app was installed, and one more final thing, so we can rule this, and you see data binding item, one more item which I want to install from Marketplace is a special tool called maintenance tools for creation, maintenance, maintenance tools was made by partner, which previously was named Syso, you probably saw its icon, now it's named Neo Technologies from Switzerland, and they use just a standard creation API, and this tool has two major functions, clear, ready sketch, but you don't really need it often, but the most important and useful feature is restart the app, restart application, unfortunately, creation doesn't have this function out of the box available in user interface, and partners from Neo Technologies decided to fix this issue, and they just made a UI button to do this, so this app simply adds a couple of buttons into our creation user interface to make it easy to restart the app or to clear ready sketch, I will use this restart app, we will need it, we cannot avoid it unfortunately, and in our examples you will see it, so you see 27.08 started, 27.18 finished, so it took only 10 seconds for installation, you probably will ask me why am I so obsessed with installation time, this is important because this is 10 seconds of downtime for your system, if you do some kind of installations on your production, your end users will not be able to operate with your system during this installation procedure, so we still have non-zero downtime, and this is important to track along it took for creation to install something, especially if you do it in the middle of working hours, so my installation was successful, we can also go back again to application hub, now you see one more app, InternetStools, and I can show you where this maintenance tools can be found, it will be into our settings page, physically it's called system designer, but now developers decided just to call settings, at the end of this page you will see new buttons, originally we had only advanced settings, but also now we have clear ready and restart application, we will need restart application later, unfortunately some study, like learning examples will require this restart application action, and we cannot avoid it in some cases, you will see later, and today session is over, thank you for your time, today we moved forward with working objects, we discussed how to build data items, how to operate with lookups, we also worked with Git, and tomorrow I plan to show you one more example with data this view, and we will move on with building user interface, I've went to focus on freedom UI, mainly on freedom UI, and if we will have some significant demand on QSQI stuff, for example you expect to work or support existing QSQI solutions, we will have to take time also to discuss some QSQI tools, but mainly my focus will be on freedom UI and programming inside of it, so thank you for your time today, our session is over, in case if you have any questions feel free to ask now, your homework as usual is to watch this video to represent all the steps or produce, all the steps for today session, working with your package, creating your lookup, your object, register it as lookup, and practice with data items, so this will be your homework, and tomorrow we will continue doing more complicated things, thank you, thank you for your time, questions Padi? Oh yes, physically they represent as packages, if you reload our configuration section, you will see that we have a couple of more packages here, and for example the package named GLB data binding represents our data binding tool, and the maintenance tools, let me find it, it's called CSL maintenance tools, is changes, customizations in our settings page to enable a couple of buttons, and customars 360, C30, 300, okay, CRT, customars 360, it's surprisingly low, I need a bit more, okay, let's search just for 360, yeah, customars 360 represents three packages in one archive, so what will study how application works, how it is created, and what is inside tomorrow, you will see that application finally keeps some packages behind it, and when we load such applications physically, we load one or several packages, here you see customars 360, it includes several packages, so that's how it works, and to physically application is a bit artificial thing, physical re-operators packages, so anyway, you can see everything which was customized here as a package and the package contents inside of configuration section, thank you, thank you, any other questions please, thank you, a valid ID mystery, yes, Brazil, thank you, when I am going to advance sitting, the configuration page doesn't work, it just reloads, it's because you're probably using Windows Home, if you use Windows home, you have to close previous page, in this case configuration page will be working normally, yeah, let me, I have no options how to make it better, unfortunately, probably you can consider an identity rule, you can upgrade to pro, Windows pro version, in this case you will have no such issue, this is kind of limitation, connect it to this web socket, and this is something that makes home different from pro, and it's not so comfortable, I agree, thank you, thank you, okay, and it looks like Tushar, had a question, yes, Tushar please, my question is like if we have a new lookup, like if we have three more lookups and we want how we can then update it, and like a system designer, do we have to create the data file again, or we can update in the existing data file, which you are sure, so probably you are talking about new data records added to existing lookups table, am I right?",
  "key_points": [
    "Just to remind you, classic UI is a special old type of user interface, which you can still find in many system sections like system users, like system settings, like web services, you will see some specifics and no possibility to shrink columns easily.",
    "And step two is to use any kind of version control systems to operate with set of your files and folders from your disk in order to deliver changes in order to transport your changes from files and folders to some common repository.",
    "Also you can find in main object that some inherited properties are shown here, ID, property which means key field, so this is not perfect title of the property should be named key field and ID is used as a key field and displayed values also not a perfect title, previously it was called primary displayed value, so the main text column which is shown in drop-down lists of lookups, so name will be used for this purpose but you can change if you want.",
    "Now any other special properties, we have some event handling made for this inherited from parent one, we will study event handling a bit later, so what do you need to know now when you do inheritance from base lookup, you automatically receive legacy of all columns that are intended to be used inside of lookups and usually it's enough, so usually you can create just code, title, inherit from base lookup and then save and publish and your object is ready.",
    "In my case I want to present and show you some additional features that could be interesting and also examples of how you can make your own custom columns in creation, so we will go to columns list and obviously we can add our own columns to the object, we have plenty of options for different database types, a lot of text options, the minimum supported is text 50 characters, then we have 250, 500, we have unlimited events, we have rich text which supports fonts, colors and styles like italic, underscore, etc."
  ],
  "keywords": [
    "data",
    "git",
    "need",
    "package",
    "object",
    "like",
    "repository",
    "file",
    "changes",
    "make"
  ],
  "topics": [],
  "summary_length": 7935,
  "original_length": 17806,
  "compression_ratio": 0.44563630236998764,
  "confidence_score": -10.683142901518677,
  "created_timestamp": "2025-07-23T17:00:54.716127",
  "metadata": {
    "selected_sentence_count": 10,
    "total_sentence_count": 753,
    "method": "tfidf_position_ranking"
  }
}